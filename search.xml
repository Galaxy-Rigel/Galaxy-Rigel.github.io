<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈前端面筋 (CSS篇)</title>
      <link href="post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart3/"/>
      <url>post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart3/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5-新特性、语义化"><a href="#HTML5-新特性、语义化" class="headerlink" title="HTML5 新特性、语义化"></a>HTML5 新特性、语义化</h2><ol><li><p>概念：<br>HTML5 的语义化指的是合理正确的使用语义化的标签来创建页面结构。【正确的标签做正确的事】</p></li><li><p>语义化标签：<br>header nav main article section aside footer</p></li><li><p>语义化的优点:</p><ul><li>在没 CSS 样式的情况下，页面整体也会呈现很好的结构效果</li><li>代码结构清晰，易于阅读，</li><li>利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li><li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ul></li></ol><h2 id="CSS-选择器及其优先级"><a href="#CSS-选择器及其优先级" class="headerlink" title="CSS 选择器及其优先级"></a>CSS 选择器及其优先级</h2><p><strong>选择器</strong></p><ul><li>  选择器(#myid)</li><li>  类选择器(.myclass)</li><li>  属性选择器(a[rel=”external”])</li><li>  伪类选择器(a:hover, li:nth-child)</li><li>  标签选择器(div, h1,p)</li><li>  相邻选择器（h1 + p）</li><li>  子选择器(ul &gt; li)</li><li>  后代选择器(li a)</li><li>  通配符选择器(*)</li></ul><p><strong>优先级</strong></p><ul><li>  !important</li><li>  内联（1000）</li><li>  id 选择器（0100）</li><li>  类/属性/伪类选择器 （0010）</li><li>  元素/伪元素选择器 （0001）</li><li>  关系选择器/通配 （0000）</li></ul><blockquote><p>!important &gt; 内联选择器 &gt; id 选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配 &gt; 继承 &gt; 浏览器默认</p></blockquote><h2 id="position-的值及其区别"><a href="#position-的值及其区别" class="headerlink" title="position 的值及其区别"></a>position 的值及其区别</h2><p><strong>固定定位 fixed：</strong> 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。</p><p><strong>相对定位 relative：</strong> 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</p><p><strong>绝对定位 absolute：</strong> 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</p><p><strong>粘性定位 sticky：</strong> 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。</p><p><strong>默认定位 Static：</strong> 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。</p><h2 id="box-sizing-属性"><a href="#box-sizing-属性" class="headerlink" title="box-sizing 属性"></a>box-sizing 属性</h2><p><strong>box-sizing</strong> 规定两个并排的带边框的框，语法为 box-sizing：content-box/border-box/inherit<br><strong>content-box</strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】<br><strong>border-box：</strong>为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】<br><strong>inherit：</strong>继承父元素的 box-sizing 值。</p><h2 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h2><p>CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。</p><p>在标准的盒子模型中，width 指 content 部分的宽度。<br>在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度。</p><p>故在计算盒子的宽度时存在差异：<br><strong>标准盒模型：</strong> 一个块的总宽度 = width+margin(左右)+padding(左右)+border(左右)<br><strong>怪异盒模型：</strong> 一个块的总宽度 = width+margin（左右）（既 width 已经包含了 padding 和 border 值）</p><h2 id="BFC-块级格式上下文"><a href="#BFC-块级格式上下文" class="headerlink" title="BFC(块级格式上下文)"></a>BFC(块级格式上下文)</h2><p><strong>概念</strong></p><p>BFC 是 Block Formatting Context 的缩写，即块级格式化上下文。BFC 是 CSS 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。</p><p><strong>BFC 的原理布局规则</strong></p><ul><li>  内部的 Box 会在垂直方向，一个接一个地放置</li><li>  Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li><li>  每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反</li><li>  BFC 的区域不会与 float box 重叠</li><li>  BFC 是一个独立容器，容器里面的子元素不会影响到外面的元素</li><li>  计算 BFC 的高度时，浮动元素也参与计算高度</li><li>  元素的类型和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。</li></ul><p><strong>如何创建 BFC？</strong></p><ul><li>  根元素，即 HTML 元素</li><li>  float 的值不为 none</li><li>  position 为 absolute 或 fixed</li><li>  display 的值为 inline-block、table-cell、table-caption</li><li>  overflow 的值不为 visible</li></ul><p><strong>BFC 的使用场景</strong></p><ul><li>  去除边距重叠现象</li><li>  清除浮动（让父元素的高度包含子浮动元素）</li><li>  避免某元素被浮动元素覆盖</li><li>  避免多列布局由于宽度计算四舍五入而自动换行</li></ul><h2 id="元素水平垂直居中"><a href="#元素水平垂直居中" class="headerlink" title="元素水平垂直居中"></a>元素水平垂直居中</h2><p><strong>水平居中</strong></p><p>对于 行内元素 : text-align: center;</p><p>对于确定宽度的块级元素：</p><ol><li>width 和 margin 实现。margin: 0 auto;</li><li>绝对定位和 margin-left: -width/2, 前提是父元素 position: relative</li></ol><p>对于宽度未知的块级元素</p><ol><li>table 标签配合 margin 左右 auto 实现水平居中。使用 table 标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右 margin 为 auto。</li><li>inline-block 实现水平居中方法。display：inline-block 和 text-align:center 实现水平居中。</li><li>绝对定位+transform，translateX 可以移动本身元素的 50%。</li><li>flex 布局使用 justify-content:center</li></ol><p><strong>垂直居中</strong></p><ol><li>利用 line-height 实现居中，这种方法适合纯文字类</li><li>通过设置父容器 相对定位 ，子级设置 绝对定位，标签通过 margin 实现自适应居中</li><li>弹性布局 flex :父级设置 display: flex; 子级设置 margin 为 auto 实现自适应居中</li><li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现<br>table 布局，父级通过转换成表格形式，然后子级设置 vertical-align 实现。（需要注意的是：vertical-align: middle 使用的前提条件是内联元素以及 display 值为 table-cell 的元素）。</li></ol><h2 id="隐藏页面中某个元素"><a href="#隐藏页面中某个元素" class="headerlink" title="隐藏页面中某个元素"></a>隐藏页面中某个元素</h2><ol><li>opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如 click 事件，那么点击该区域，也能触发点击事件的</li><li>visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</li><li>display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</li></ol><h2 id="css-实现三角符号"><a href="#css-实现三角符号" class="headerlink" title="css 实现三角符号"></a>css 实现三角符号</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记忆口诀：盒子宽高均为零，三面边框皆透明。 */</span></span><br><span class="line"><span class="selector-tag">div</span>:after &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">100px</span> solid <span class="number">#ff0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><h3 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h3><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”,用来为盒状模型提供最大的灵活性。指定容器 display: flex 即可。 简单的分为容器属性和元素属性。</p><p><strong>容器的属性：</strong></p><ul><li>flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column |<br>  column-reverse;</li><li>  flex-wrap：决定换行规则 flex-wrap: nowrap | wrap | wrap-reverse;</li><li>  flex-flow：属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</li><li>  justify-content：对其方式，水平主轴对齐方式</li><li>  align-items：对齐方式，竖直轴线方向</li><li>  align-content:属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p><strong>项目的属性（元素的属性）：</strong></p><ul><li>  order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0</li><li>  flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大</li><li>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不<br>  缩小</li><li>  flex-basis 属性：定义了在分配多余的空间，项目占据的空间。</li><li>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。该属性有三个常用快捷值：auto (1 1<br>  auto) 和 1 (1 1 0%) 和 none (0 0 auto)。</li><li>  align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖</li><li>  align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局</li></ul><h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><p>通过百分比单位 “ % “ 来实现响应式的效果。通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相 对于 height，width 百分比相对于 width。 padding、border、margin 等等不论是垂直方向还是水平方向，都相对于直接父元素的 width。 除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。</p><p><strong>缺点：</strong></p><ul><li>  计算困难</li><li>  各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。</li></ul><h3 id="table-布局"><a href="#table-布局" class="headerlink" title="table 布局"></a>table 布局</h3><p>table 布局在如今已经很少使用，原因是：table 布局比其它 html 标记占更多的字节，会阻挡浏览器渲染引擎的渲染顺序，会影响其内部的某些布局属性的生效。</p><p>使用 table 布局有两种方式</p><ul><li>  table 标签</li><li>  display：table</li></ul><h3 id="float-布局"><a href="#float-布局" class="headerlink" title="float 布局"></a>float 布局</h3><p>浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。</p><p><strong>优点</strong></p><p>这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与 inline-block 还是有一些区别的，第一个就是关于横向排序的时候，float 可以设置方向而 inline-block 方向是固定的；还有一个就是 inline-block 在使用时有时会有空白间隙的问题<br><strong>缺点</strong></p><p>最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，会造成父级元素高度塌陷。</p><h3 id="响应式布局（媒体查询）"><a href="#响应式布局（媒体查询）" class="headerlink" title="响应式布局（媒体查询）"></a>响应式布局（媒体查询）</h3><p>响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。传统的开发方式是 PC 端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就够。</p><p><strong>优点</strong></p><p>面对不同分辨率设备灵活性强<br>能够快捷解决多设备显示适应问题</p><p><strong>缺点</strong></p><ul><li>  仅适用布局、信息、框架并不复杂的部门类型网站</li><li>  兼容各种设备工作量大，效率低下</li><li>  代码累赘，会出现隐藏无用的元素，加载时间加长</li><li>  其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li><li>  一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li></ul><h3 id="grid-网格布局"><a href="#grid-网格布局" class="headerlink" title="grid 网格布局"></a>grid 网格布局</h3><p>todo</p><h2 id="使用-rem-vw-实现移动端适配"><a href="#使用-rem-vw-实现移动端适配" class="headerlink" title="使用 rem+vw 实现移动端适配"></a>使用 rem+vw 实现移动端适配</h2><p>如何利用 rem+vw 进行屏幕适配呢？我们以设计稿为 750px 为基准</p><ol><li>设置 meta 标签 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>设置根元素 html 的 font-size:13.3333333vw</li></ol><p>为什么 font-size=13.33333333vw?</p><blockquote><p>100vw=750px =&gt; 1px = 0.1333333vw =&gt; 1rem=100px=13.333333vw,取 100px 是为了方便计算</p></blockquote><p>下面分析下原理吧, 上面我们说了 vw 表示 1%的屏幕宽度,而我们的设计稿通常是 750px 的,屏幕一共是 100vw,对应 750px,那么 1px 就是 0.1333333vw,。</p><p>同时我们知道 rem,rem 是相对 html 元素的字体大小，为了方便计算,我们取 html 的 font-size=100px,通过上面的计算结果 1px 是 0.13333333vw,那么 100px 就是 13.333333vw 了</p><p>所以，我们让 1rem=100px=13.333333vw</p><p>那么在项目上就很好地可以进行使用了</p><p>当我们通过 ps 测量一个 div 的大小为 width:200px,height:137px 时，我们就可以这样写，ps 量出来的像素直接除以 100，计算小数很方便</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2rem</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.37rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js原型链</title>
      <link href="post/js%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>post/js%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/prototype.jpg" alt="prototype"></p><h3 id="先看第一行"><a href="#先看第一行" class="headerlink" title="先看第一行"></a>先看第一行</h3><p>我们定义的 show 函数在 Foo.prototype 中，当我们执行 f1.show()时，js 发现 f1 本身没有 show 这个属性，所以它就到 f1 的原型（也就是__proto__指向的对象）去找，找到了就可以调用。</p><blockquote><p>注：每个对象都有一个方法 hasOwnProperty()来检查对象本身是否有某个属性，如果有则返回 true；如果这个属性在它的原型链上或原型链上都没有，则返回 false；</p></blockquote><p>图片第一行告诉了我们 4 点：</p><ol><li>所有函数都有一个 prototype 指针，指向原型对象，如图中的 Foo 的 prototype 指针。prototype 指针的意义是，当我们使用这个构造函数 new 出新对象的时候，新对象的原型是谁。</li><li>构造函数的 prototype 所指向的原型对象有一个 constructor 指针，指回构造函数。如图中 Foo.prototype 的 constructor 指针指向 Foo。constructor 指针有助于我们找到一个对象的构造函数是谁。</li><li>__proto__每个对象都有，js 在 new 一个对象的时候，会将它的__proto__指向构造函数的 prototype 指向的那个对象。在上图中，f1、f2 这些实例对象的__proto__都指向了 Foo.prototype。</li><li>如果一个对象的__proto__`指向了另一个对象，那么前者就继承了后者的所有属性。</li></ol><h3 id="接着图片往下看，它展示了-js-对象继承关系"><a href="#接着图片往下看，它展示了-js-对象继承关系" class="headerlink" title="接着图片往下看，它展示了 js 对象继承关系"></a>接着图片往下看，它展示了 js 对象继承关系</h3><p>我们先看看 Foo 的原型吧！Foo 是一个函数，它的构造函数是 js 内部的 function Function()，Function 的 prototype 指向了一个对象 Function.prototype，因此 Foo 的__proto__就指向了 Function.prototype，如图。</p><blockquote><p>所有的函数都以 function Function()为构造函数，因此，所有函数（包括 function Function()和 function Object()）的__proto__都指向 Function.prototype 这个对象，这个对象中定义了所有函数都共有的方法，比如 call()、apply()等。</p></blockquote><p>我们继续深入下去，Function.prototype 这个对象，它就是一个普通的对象，它的构造函数是 js 内置的 function Object()，function Object()的 prototype 指向 Object.prototype，因此 Function.prototype.__proto__就指向 Object.prototype，这个对象中定义了所有对象共有的属性，比如我们之前说的 hasOwnProperty()和 toString()等。</p><blockquote><p>同理，Foo.prototype 和其他自定义的对象也是__proto__指向 Object.prototype 对象，就不需要说明了。</p></blockquote><p>Object.prototype 就是原型链的终点了，它的__proto__是 null，js 查找属性时，如果到这里还没有找到，那就是 undefined 了。</p><p>到这里就不难理解为什么我们说在 js 中，函数也是对象了，它就是继承自对象的！</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> prototype </tag>
            
            <tag> 原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js引擎解析过程</title>
      <link href="post/js%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
      <url>post/js%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h2><p>语法检查是 JavaScript 解析器的工作之一，包括 Î<strong>词法分析</strong>和<strong>语法分析</strong></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>把 JavaScript 代码（字符创）逐字转换为<strong>标记流</strong></p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a = (b - c);</span></span><br></pre></td></tr></table></figure><p>转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME <span class="string">&quot;a&quot;</span></span><br><span class="line">EQUALS</span><br><span class="line">OPEN_PARENTHESIS</span><br><span class="line">NAME <span class="string">&quot;b&quot;</span></span><br><span class="line">MINUS</span><br><span class="line">NAME <span class="string">&quot;c&quot;</span></span><br><span class="line">CLOSE_PARENTHESIS</span><br><span class="line">SEMICOLON</span><br></pre></td></tr></table></figure><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析：JavaScript 语法分析器在经过词法分析后，将记号流按照 ECMAScript 标准把词法分析所产生的记号生成<strong>语法树 AS</strong>T。</p><h2 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h2><h3 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h3><ol><li>将 JavaScript 引擎将语法检查正确后生成的语法树复制到当前执行上下文中。</li><li>JavaScript 引擎会对语法树当中的<strong>变量声明</strong>、<strong>函数声明</strong>以及<strong>函数的形参</strong>进行属性填充（ 声明提升）。</li></ol><p><strong>执行上下文包括：变量对象、作用域链、this</strong></p><ul><li>  变量对象（Variable Object）:由变量声明（var declaration）、函数声明（function declaration）、参数（arguments）构成。</li><li>  作用域链（Scope Chain）: 变量对象+父级作用域</li><li>  this ：一旦进入代码执行阶段的上下文中（预编译后的代码执行阶段），this 的值就不会变了。</li></ul><p><strong>变量对象/活动对象（VO/AO）属性填充</strong></p><ul><li><p>  变量对象/活动对象（VO/AO）填充的顺序：函数的形参-&gt;函数声明-&gt;变量声明；在变量对象/活动对象（VO/AO）中权重高低也按照函数的形参-&gt;函数声明-&gt;变量声明顺序来。</p></li><li><p>  函数的形参：执行上下文的变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为 undefined。</p></li><li><p>  函数声明：执行上下文的变量对象的一个属性，属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则会替换它的值。</p></li><li><p>变量声明：执行上下文的变量对象的一个属性，其属性名即为变量名，其值为 undefined；如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的函数声明的属性，该声明会被忽略掉，但其包含的赋值操作不会忽略。</p><pre><code>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数提升优先级高于变量提升，所以b取函数</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    alert(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b <span class="comment">// 被忽略，因为函数声明优先级高于变量声明</span></span><br><span class="line">alert(b) <span class="comment">// function b(a) &#123; alert(a); &#125;</span></span><br><span class="line">b() <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>经过“预解析”创建执行上下文之后，就进入执行代码阶段，VO/AO 就会重新赋予真实的值，“预解析”阶段赋予的 undefined 值会被覆盖。</p><p>此阶段才是程序真正进入执行阶段，Javascript 引擎会一行一行的读取并运行代码。此时那些变量都会重新赋值。</p><p>假如变量是定义在函数内的，而函数从头到尾都没被激活（调用）的话，则变量值永远都是 undefined 值。</p><p>进入了执行代码阶段，在“预解析”阶段所创建的任何东西可能都会改变，不仅仅是 VO/AO，this 和作用域链也会因为某些语句而改变，后面会讲到。</p><p>​ <strong>作用域链（Scope Chain）</strong></p><p>​ 作用域链是处理标识符时进行<strong>变量查询</strong>的变量对象列表，每个执行上下文都有自己的变量对象：对于全局上下文而言，其变量对象就是全局对象本身；对于函数而言，其变量对象就是活动对象。</p><p><strong>作用域链和执行上下文的关系</strong></p><p>在 Javascript 中只有函数能规定作用域，全局执行上下文中的 Scope 是全局上下文中的属性，也是最外层的作用域链。<br>函数内部的属性（作用域）是在“预解析”的时候就已经存在的了，它包含了所有上层变量对象，并一直保存在函数中。就算函数永远都没被激活（调用），也都还是存在函数对象上。</p><p><strong>执行上下文定义的 Scope 属性变化过程</strong></p><p>执行上下文中的[AO]是函数的活动对象，而[[Scope]]则是该函数属性作用域。当前函数的 AO 永远是在最前面的，保存在堆栈上，而每当函数激活的时候，这些 AO 都会压栈到该堆栈上，查询变量是先从栈顶开始查找，也就是说作用域链的栈顶永远是当前正在执行的代码所在环境的 VO/AO（当函数调用结束后，则会从栈顶移除）。</p><p>通俗点讲就是：JavaScript 解释器通过作用域链将不同执行位置上的变量对象串连成列表，并借助这个列表帮助 JavaScript 解释器检索变量的值。作用域链相当于一个索引表，并通过编号来存储它们的嵌套关系。当 JavaScript 解释器检索变量的值，会按着这个索引编号进行快速查找，直到找到全局对象为止，如果没有找到值，则传递一个特殊的 undefined 值。</p><p>是不是又想到了一条 JavaScript 高效准则：为什么说在该函数内定义的变量，能减少函数嵌套能提高 JavaScript 的效率？因为函数定义的变量，此变量永远在栈顶，这样子查询变量的时间变短了。</p><p><strong>作用域链特性</strong><br>闭包是作用域链特性的应用</p><p>保证查询有序的访问所有变量和函数<br>作用域链感觉就是一个 VO 链表，当访问一个变量时，先在链表的第一个 VO 上查找，如果没有找到则继续在第二个 VO 上查找，直到搜索结束，也就是搜索到全局执行环境的 VO 中。这也就形成了作用域链的概念。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前端面筋（浏览器篇）</title>
      <link href="post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart2/"/>
      <url>post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart2/</url>
      
        <content type="html"><![CDATA[<h2 id="从输入-URL-到页面加载的全过程"><a href="#从输入-URL-到页面加载的全过程" class="headerlink" title="从输入 URL 到页面加载的全过程"></a>从输入 URL 到页面加载的全过程</h2><p><img src="/img/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B.png"></p><ol><li><p>在浏览器中输入 URL。</p></li><li><p>查找 DNS 缓存</p><ul><li>浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求；</li><li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的 DNS 查询缓存)；</li><li>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存；</li><li>ISP 缓存：若上述均失败，继续向 ISP 搜索。</li></ul></li><li><p>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址。DNS 服务器是基于 UDP 的，因此会用到 UDP 协议。</p></li><li><p>建立 TCP 连接：解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接。</p></li><li><p>发起 HTTP 请求：浏览器发起读取文件的 HTTP 请求，该请求报文作为 TCP 三次握手的第三次数据发送给服务器</p></li><li><p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 html 文件发送给浏览器</p></li><li><p>关闭 TCP 连接：通过四次挥手释放 TCP 连接</p></li><li><p>浏览器渲染（渲染引擎）：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后的解析流程为：</p><ol><li>构建 DOM 树：词法分析然后解析成 DOM 树（dom tree），是由 dom 元素及属性节点组成，树的根是 document 对象</li><li>构建 CSS 规则树：生成 CSS 规则树（CSS Rule Tree）</li><li>构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，并构建出渲染树（render tree）</li><li>布局（Layout）：计算出每个节点在屏幕中的位置</li><li>绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。</li></ol><p> <img src="/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png"></p></li><li><p>JS 引擎解析过程（具体看另一篇文章：<a href="/post/js%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B">js 引擎解析详解</a>）</p><ol><li>语法检查</li><li>预编译</li><li>执行</li></ol></li></ol><h2 id="浏览器重绘与重排"><a href="#浏览器重绘与重排" class="headerlink" title="浏览器重绘与重排"></a>浏览器重绘与重排</h2><ul><li>  重排/回流（Reflow）：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li><li>  重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</li><li>  『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』</li></ul><h2 id="如何出发重排和重绘"><a href="#如何出发重排和重绘" class="headerlink" title="如何出发重排和重绘"></a>如何出发重排和重绘</h2><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>  添加、删除、更新 DOM 节点</li><li>  通过 display: none 隐藏一个 DOM 节点-触发重排和重绘</li><li>  通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化</li><li>  移动或者给页面中的 DOM 节点添加动画</li><li>  添加一个样式表，调整样式属性</li><li>  用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><h2 id="如何避免重绘或者重排"><a href="#如何避免重绘或者重排" class="headerlink" title="如何避免重绘或者重排"></a>如何避免重绘或者重排</h2><ul><li>  集中改变样式，不要一条一条地修改 DOM 的样式。</li><li>  不要把 DOM 结点的属性值放在循环里当成循环里的变量。</li><li>  为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</li><li>  不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</li><li>  尽量只修改 position：absolute 或 fixed 元素，对其他元素影响不大</li><li>  动画开始 GPU 加速，translate 使用 3D 变化</li><li>  提升为合成层</li></ul><h2 id="浏览器缓存-强制缓存-amp-协商缓存"><a href="#浏览器缓存-强制缓存-amp-协商缓存" class="headerlink" title="浏览器缓存 强制缓存&amp;协商缓存"></a>浏览器缓存 强制缓存&amp;协商缓存</h2><ul><li><p>强制缓存<br>  强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <strong>Expires</strong> 和 <strong>Cache-Control</strong>，其中 Cache-Control 优先级比 Expires 高。<br>  强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol></li><li><p>协商缓存<br>  协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<strong>Last-Modified / If-Modified-Since</strong> 和 <strong>Etag / If-None-Match</strong>，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。协商缓存主要有以下两种情况：</p><ul><li>  协商缓存生效，返回 304</li><li>  协商缓存失效，返回 200 和请求结果结果</li></ul></li></ul><h2 id="介绍一下-304-过程"><a href="#介绍一下-304-过程" class="headerlink" title="介绍一下 304 过程"></a>介绍一下 304 过程</h2><ol><li>浏览器请求资源时首先命中资源的 <strong>Expires</strong> 和 <strong>Cache-Control</strong>，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过 <strong>Cache-control: max-age</strong> 指定最大生命周期，<strong>状态仍然返回 200</strong>，但不会请求数据，在浏览器中能明显看到 from cache 字样。</li><li>强缓存失效，进入协商缓存阶段，首先验证 <strong>ETag</strong> ,ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据客户端上送的 <strong>If-None-Match</strong> 值来判断是否命中缓存。</li><li>协商缓存 <strong>Last-Modify/If-Modify-Since</strong> 阶段，客户端第一次请求资源时，服务服返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;no-cache&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> hash = crypto.createHash(<span class="string">&#x27;sha1&#x27;</span>).update(content).digest(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">res.setHeader(<span class="string">&#x27;Etag&#x27;</span>, hash)</span><br><span class="line"><span class="keyword">if</span> (req.headers[<span class="string">&#x27;if-none-match&#x27;</span>] === hash) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Etag协商缓存命中.....&#x27;</span>)</span><br><span class="line">    res.statusCode = <span class="number">304</span></span><br><span class="line">    res.end()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说一下进程、线程和协程"><a href="#说一下进程、线程和协程" class="headerlink" title="说一下进程、线程和协程"></a>说一下进程、线程和协程</h2><ul><li><p>  进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p></li><li><p>  线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程 ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p></li><li><p>  协程，英文 Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p></li><li><p>进程和线程的区别与联系</p><p>  【区别】：</p><ul><li>  调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li><li>  并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</li><li>  拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</li><li>  系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</li></ul><p>  【联系】：</p><ul><li>  一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</li><li>  资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li><li>  处理机分给线程，即真正在处理机上运行的是线程；</li><li>  线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 重绘 </tag>
            
            <tag> 重排 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前端面筋（网络篇）</title>
      <link href="post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart1/"/>
      <url>post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart1/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h4 id="HTTP-和-HTTPS-基本概念"><a href="#HTTP-和-HTTPS-基本概念" class="headerlink" title="HTTP 和 HTTPS 基本概念"></a>HTTP 和 HTTPS 基本概念</h4><ul><li>  HTTP 是超文本协议，用于从服务器传输超文本到客户端的超文本协议。</li><li>  HTTPS 是安全的 HTTP 通道，在 HTTP 下加入 SSL 层进行加密处理数据。其作用是保证数据传输的安全性和完整性。</li></ul><h4 id="HTTP-和-HTTPS-的区别和优缺点"><a href="#HTTP-和-HTTPS-的区别和优缺点" class="headerlink" title="HTTP 和 HTTPS 的区别和优缺点"></a>HTTP 和 HTTPS 的区别和优缺点</h4><ul><li>  HTTP 是超文本传输协议，明文传输数据；HTTPS 要比 HTTP 更安全，HTTPS 通过 SSL 层加密数据，在传输过程中保证数据安全，可靠，完整。</li><li>  HTTP 默认端口 80；HTTPS 默认端口 443。</li><li>  HTTP 连接简单，无状态；HTTPS 在握手阶段相对耗时，会增加页面加载时长。</li><li>  HTTPS 的缓存不如 HTTP 高效。</li><li>  HTTPS 需要 CA 证书，费用较高。</li><li>  SSL 证书需要绑定 IP，不能在用一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ul><h4 id="HTTPS-协议的工作原理"><a href="#HTTPS-协议的工作原理" class="headerlink" title="HTTPS 协议的工作原理"></a>HTTPS 协议的工作原理</h4><ol><li>客户端使用 HTTPS url 访问服务端，服务端<strong>建立 ssl 连接</strong>。</li><li>服务端接收到客户端请求后，会将<strong>网站证书（证书包含公钥）</strong>发送给客户端。</li><li>服务端和客户端开始协商 ssl 链接的<strong>安全等级</strong>。</li><li>客户端建立<strong>会话密钥</strong>，然后通过公钥加密数据后发送服务端。</li><li>服务端通过<strong>私钥</strong>解密数据完成通信。</li></ol><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><ol><li>第一次握手：建立连接时，客户端发送<strong>syn 包</strong>（syn=j）到服务器，并进入<strong>SYN_SENT</strong>状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到 syn 包并确认客户的 SYN（ack=j+1），同时也发送一个自己的 SYN 包（syn=k），即<strong>SYN+ACK 包</strong>，此时服务器进入<strong>SYN_RECV</strong>状态。</li><li>第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送<strong>确认包 ACK</strong>(ack=k+1），此包发送完毕，客户端和服务器进入<strong>ESTABLISHED</strong>（TCP 连接成功）状态，完成三次握手。</li></ol><h2 id="TCP-IP-如何保证数据包传输的有序可靠"><a href="#TCP-IP-如何保证数据包传输的有序可靠" class="headerlink" title="TCP/IP 如何保证数据包传输的有序可靠"></a>TCP/IP 如何保证数据包传输的有序可靠</h2><p>对字节流分段并进行编号然后通过  <strong>ACK 回复</strong>和<strong>超时重发</strong>这两个机制来保证。</p><ol><li>为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区。</li><li>并为每个已发送的数据包启动一个超时定时器。</li><li>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区。</li><li>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</li><li>接收方收到数据包后，先进行 CRC 校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</li></ol><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><ol><li>TCP 是面向连接的，而 UDP 是面向无连接的。</li><li>TCP 仅支持单播传输，UDP 支持单播，多播，广播。</li><li>TCP 传输的可靠性，UDP 面向无连接，不可靠的传输协议。</li><li>UDP 传输速率比 TCP 快，实时性好。</li></ol><h2 id="HTTP-跨域请求问题"><a href="#HTTP-跨域请求问题" class="headerlink" title="HTTP 跨域请求问题"></a>HTTP 跨域请求问题</h2><ul><li><p>跨域原理<br>  跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。<br>  同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p></li><li><p>解决方案</p><ol><li>JSONP:前端构造 script 标签请求指定 URL(由 script 标签发出的 GET 请求不受同源策略限制)，服务器返 回一个函数执行语句，该函数名称通常由查询参 callback 的值决定，函数的参数为服务器返回的 json 数据。该函数在前端执行后即可获取数据。</li><li>代理服务器：请求同源服务器，通过该服务器转发请求至目标服务器，得到结果再转发给前端。前端开发中测试服务器的代理功能就是采用的该解决方案，但是最终发布上线时如果 web 应用和 接口服务器不在一起仍会跨域。</li><li>CORS（Cross Origin Resource Share） 跨域资源共享，后端方案</li></ol><ul><li><p>响应简单请求：<br>  简单请求：method 为 get/post/head,并且没有自定义请求头，且 Content-Type 为 application/x-www-form-urlencoded,multipart/form-data 或者 text/plain 之一,否则都是复杂请求。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://localhost:3000&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>响应复杂请求：预检 preflight 请求,需要响应浏览器发出的 options 请求</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端,定义了自定义请求头，属于复杂请求</span></span><br><span class="line">axios.post(<span class="string">&#x27;api/users&#x27;</span>, &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, &#123; <span class="attr">headers</span>: &#123; <span class="string">&#x27;x-token&#x27;</span>: <span class="string">&#x27;xxxxxx&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端响应,post请求的复杂请求还需要在&quot;Access-Control-Allow-Headers&quot; 允许 &quot;Content-Type&quot;</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Method&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;custom-header,Content-Type&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果要携带 cookie 信息，则请求变为 credential 请求：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端，为true时，服务端需要 &#x27;Access-Control-Allow-Credentials&#x27;:&#x27;true&#x27;</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// credential请求，预检options中和/users接口中均需添加</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置cookie</span></span><br><span class="line">res.setHeaders(<span class="string">&#x27;Set-Cookie&#x27;</span>, <span class="string">&#x27;cookie1=aaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应复杂请求</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Method&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;custom-header,Content-Type&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Cookie、sessionStorage、localStorage-区别"><a href="#Cookie、sessionStorage、localStorage-区别" class="headerlink" title="Cookie、sessionStorage、localStorage 区别"></a>Cookie、sessionStorage、localStorage 区别</h2><ul><li>相同点：<br>  存储在客户端</li><li>不同点：<ul><li>  cookie 数据大小不能超过 4k；sessionStorage 和 localStorage 的存储比 cookie 大得多，可以达到 5M+</li><li>  cookie 设置的过期时间之前一直有效；localStorage 永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除</li><li>  cookie 的数据会自动的传递到服务器；sessionStorage 和 localStorage 数据保存在本地</li></ul></li></ul><h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><p>TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><ul><li><p>粘包出现原因<br>  简单得说，在流传输中出现，UDP 不会出现粘包，因为它有消息边界粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。</p></li><li><p>为了避免粘包现象，可采取以下几种措施：</p><ol><li>对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP 提供了强制数据立即传送的操作指令 push，TCP 软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</li><li>对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</li><li>由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。分包多发。</li></ol></li><li><p>以上提到的三种措施，都有其不足之处。</p><ol><li>第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</li><li>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</li><li>第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
