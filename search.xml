<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈前端面筋（浏览器篇）</title>
      <link href="post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart2/"/>
      <url>post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart2/</url>
      
        <content type="html"><![CDATA[<h2 id="从输入-URL-到页面加载的全过程"><a href="#从输入-URL-到页面加载的全过程" class="headerlink" title="从输入 URL 到页面加载的全过程"></a>从输入 URL 到页面加载的全过程</h2><p><img src="/img/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B.png"></p><ol><li><p>在浏览器中输入 URL。</p></li><li><p>查找 DNS 缓存</p><ul><li>浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求；</li><li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的 DNS 查询缓存)；</li><li>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存；</li><li>ISP 缓存：若上述均失败，继续向 ISP 搜索。</li></ul></li><li><p>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址。DNS 服务器是基于 UDP 的，因此会用到 UDP 协议。</p></li><li><p>建立 TCP 连接：解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接。</p></li><li><p>发起 HTTP 请求：浏览器发起读取文件的 HTTP 请求，该请求报文作为 TCP 三次握手的第三次数据发送给服务器</p></li><li><p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 html 文件发送给浏览器</p></li><li><p>关闭 TCP 连接：通过四次挥手释放 TCP 连接</p></li><li><p>浏览器渲染（渲染引擎）：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后的解析流程为：</p><ol><li>构建 DOM 树：词法分析然后解析成 DOM 树（dom tree），是由 dom 元素及属性节点组成，树的根是 document 对象</li><li>构建 CSS 规则树：生成 CSS 规则树（CSS Rule Tree）</li><li>构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，并构建出渲染树（render tree）</li><li>布局（Layout）：计算出每个节点在屏幕中的位置</li><li>绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。</li></ol><p> <img src="/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png"></p></li><li><p>JS引擎解析过程（具体看另一篇文章：<a href="/post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart1">js引擎解析详解</a>）</p><ol><li>语法检查</li><li>预编译</li><li>执行</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 重绘 </tag>
            
            <tag> 重排 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前端面筋（网络篇）</title>
      <link href="post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart1/"/>
      <url>post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart1/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h4 id="HTTP-和-HTTPS-基本概念"><a href="#HTTP-和-HTTPS-基本概念" class="headerlink" title="HTTP 和 HTTPS 基本概念"></a>HTTP 和 HTTPS 基本概念</h4><ul><li>  HTTP 是超文本协议，用于从服务器传输超文本到客户端的超文本协议。</li><li>  HTTPS 是安全的 HTTP 通道，在 HTTP 下加入 SSL 层进行加密处理数据。其作用是保证数据传输的安全性和完整性。</li></ul><h4 id="HTTP-和-HTTPS-的区别和优缺点"><a href="#HTTP-和-HTTPS-的区别和优缺点" class="headerlink" title="HTTP 和 HTTPS 的区别和优缺点"></a>HTTP 和 HTTPS 的区别和优缺点</h4><ul><li>  HTTP 是超文本传输协议，明文传输数据；HTTPS 要比 HTTP 更安全，HTTPS 通过 SSL 层加密数据，在传输过程中保证数据安全，可靠，完整。</li><li>  HTTP 默认端口 80；HTTPS 默认端口 443。</li><li>  HTTP 连接简单，无状态；HTTPS 在握手阶段相对耗时，会增加页面加载时长。</li><li>  HTTPS 的缓存不如 HTTP 高效。</li><li>  HTTPS 需要 CA 证书，费用较高。</li><li>  SSL 证书需要绑定 IP，不能在用一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ul><h4 id="HTTPS-协议的工作原理"><a href="#HTTPS-协议的工作原理" class="headerlink" title="HTTPS 协议的工作原理"></a>HTTPS 协议的工作原理</h4><ol><li>客户端使用 HTTPS url 访问服务端，服务端<strong>建立 ssl 连接</strong>。</li><li>服务端接收到客户端请求后，会将<strong>网站证书（证书包含公钥）</strong>发送给客户端。</li><li>服务端和客户端开始协商 ssl 链接的<strong>安全等级</strong>。</li><li>客户端建立<strong>会话密钥</strong>，然后通过公钥加密数据后发送服务端。</li><li>服务端通过<strong>私钥</strong>解密数据完成通信。</li></ol><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><ol><li>第一次握手：建立连接时，客户端发送<strong>syn 包</strong>（syn=j）到服务器，并进入<strong>SYN_SENT</strong>状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到 syn 包并确认客户的 SYN（ack=j+1），同时也发送一个自己的 SYN 包（syn=k），即<strong>SYN+ACK 包</strong>，此时服务器进入<strong>SYN_RECV</strong>状态。</li><li>第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送<strong>确认包 ACK</strong>(ack=k+1），此包发送完毕，客户端和服务器进入<strong>ESTABLISHED</strong>（TCP 连接成功）状态，完成三次握手。</li></ol><h2 id="TCP-IP-如何保证数据包传输的有序可靠"><a href="#TCP-IP-如何保证数据包传输的有序可靠" class="headerlink" title="TCP/IP 如何保证数据包传输的有序可靠"></a>TCP/IP 如何保证数据包传输的有序可靠</h2><p>对字节流分段并进行编号然后通过  <strong>ACK 回复</strong>和<strong>超时重发</strong>这两个机制来保证。</p><ol><li>为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区。</li><li>并为每个已发送的数据包启动一个超时定时器。</li><li>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区。</li><li>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</li><li>接收方收到数据包后，先进行 CRC 校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</li></ol><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><ol><li>TCP 是面向连接的，而 UDP 是面向无连接的。</li><li>TCP 仅支持单播传输，UDP 支持单播，多播，广播。</li><li>TCP 传输的可靠性，UDP 面向无连接，不可靠的传输协议。</li><li>UDP 传输速率比 TCP 快，实时性好。</li></ol><h2 id="HTTP-跨域请求问题"><a href="#HTTP-跨域请求问题" class="headerlink" title="HTTP 跨域请求问题"></a>HTTP 跨域请求问题</h2><ul><li><p>跨域原理<br>  跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。<br>  同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p></li><li><p>解决方案</p><ol><li>JSONP:前端构造 script 标签请求指定 URL(由 script 标签发出的 GET 请求不受同源策略限制)，服务器返 回一个函数执行语句，该函数名称通常由查询参 callback 的值决定，函数的参数为服务器返回的 json 数据。该函数在前端执行后即可获取数据。</li><li>代理服务器：请求同源服务器，通过该服务器转发请求至目标服务器，得到结果再转发给前端。前端开发中测试服务器的代理功能就是采用的该解决方案，但是最终发布上线时如果 web 应用和 接口服务器不在一起仍会跨域。</li><li>CORS（Cross Origin Resource Share） 跨域资源共享，后端方案</li></ol><ul><li><p>响应简单请求：<br>  简单请求：method 为 get/post/head,并且没有自定义请求头，且 Content-Type 为 application/x-www-form-urlencoded,multipart/form-data 或者 text/plain 之一,否则都是复杂请求。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://localhost:3000&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>响应复杂请求：预检 preflight 请求,需要响应浏览器发出的 options 请求</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端,定义了自定义请求头，属于复杂请求</span></span><br><span class="line">axios.post(<span class="string">&#x27;api/users&#x27;</span>, &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, &#123; <span class="attr">headers</span>: &#123; <span class="string">&#x27;x-token&#x27;</span>: <span class="string">&#x27;xxxxxx&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端响应,post请求的复杂请求还需要在&quot;Access-Control-Allow-Headers&quot; 允许 &quot;Content-Type&quot;</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Method&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;custom-header,Content-Type&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果要携带 cookie 信息，则请求变为 credential 请求：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端，为true时，服务端需要 &#x27;Access-Control-Allow-Credentials&#x27;:&#x27;true&#x27;</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// credential请求，预检options中和/users接口中均需添加</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置cookie</span></span><br><span class="line">res.setHeaders(<span class="string">&#x27;Set-Cookie&#x27;</span>, <span class="string">&#x27;cookie1=aaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应复杂请求</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Method&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;custom-header,Content-Type&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Cookie、sessionStorage、localStorage-区别"><a href="#Cookie、sessionStorage、localStorage-区别" class="headerlink" title="Cookie、sessionStorage、localStorage 区别"></a>Cookie、sessionStorage、localStorage 区别</h2><ul><li>相同点：<br>  存储在客户端</li><li>不同点：<ul><li>  cookie 数据大小不能超过 4k；sessionStorage 和 localStorage 的存储比 cookie 大得多，可以达到 5M+</li><li>  cookie 设置的过期时间之前一直有效；localStorage 永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除</li><li>  cookie 的数据会自动的传递到服务器；sessionStorage 和 localStorage 数据保存在本地</li></ul></li></ul><h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><p>TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><ul><li><p>粘包出现原因<br>  简单得说，在流传输中出现，UDP 不会出现粘包，因为它有消息边界粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。</p></li><li><p>为了避免粘包现象，可采取以下几种措施：</p><ol><li>对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP 提供了强制数据立即传送的操作指令 push，TCP 软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</li><li>对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</li><li>由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。分包多发。</li></ol></li><li><p>以上提到的三种措施，都有其不足之处。</p><ol><li>第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</li><li>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</li><li>第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
