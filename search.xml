<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ESLint, Prettier, Commitizen, Husky 规范代码</title>
      <link href="post/husky+lint-staged+commitlint/"/>
      <url>post/husky+lint-staged+commitlint/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Eslint</strong>, 一个根据方案识别并报告 ECMAScript/JavaScript 代码问题的工具，其目的是使代码风格更加一致并避免错误。</p><p><strong>Prettier</strong>, code formatting tool 风格格式化工具。</p><p><strong>husky</strong>，一个为 git 客户端增加 hook 的工具。比如 pre-commit 钩子就会在你执行 git commit 的触发。我们可以在 pre-commit 中实现一些比如 lint 检查、单元测试、代码美化等操作。</p><p><strong>lint-staged</strong>，一个仅仅过滤出 Git 代码暂存区文件(被 git add 的文件)的工具；这个很实用，因为我们如果对整个项目的代码做一个检查，可能耗时很长，如果是老项目，要对之前的代码做一个代码规范检查并修改的话，这可能就麻烦了，可能导致项目改动很大。所以这个 lint-staged，对团队项目和开源项目来说，是一个很好的工具，它是对个人要提交的代码的一个规范和约束。</p><p><strong>Commitizen</strong> , 提示和格式化 git commit 日志规范的工具,辅助生成标准规范化的 commitMsg,支持多种提交规范，可以安装和配置不同的适配器实现，本文以 conventional-change-log 适配器为例 。</p><p><strong>Commitlint</strong>，校验 commitMsg 规范的工具。</p><p><strong>cz-conventional-changelog</strong> , Commitizen 适配器。</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>创建package.json文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm init</span><br></pre></td></tr></table></figure><h2 id="配置-ESlint-和-Prettier"><a href="#配置-ESlint-和-Prettier" class="headerlink" title="配置 ESlint 和 Prettier"></a>配置 ESlint 和 Prettier</h2><p>安装相关依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add -D eslint prettier eslint-config-prettier</span><br></pre></td></tr></table></figure><p>生成 ESlint 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm init @eslint/config</span><br></pre></td></tr></table></figure><p><code>eslint-config-prettier</code> 用来关闭 ESlint 风格检查，避免和 Prettier风格规则冲突</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;env&quot;</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: [<span class="string">&quot;eslint:recommended&quot;</span>, <span class="string">&quot;prettier&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Prettier的配置文件 <strong>. prettierrc</strong> </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tabWidth&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Prettier忽略配置文件 .prettierignore</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">pnpm-lock.yaml</span></span><br><span class="line"><span class="string">build</span></span><br><span class="line"><span class="string">dist</span></span><br></pre></td></tr></table></figure><p>测试ESlint和Prettier</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ESlint检测所有文件</span></span><br><span class="line">npx eslint .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Prettier检测所有文件</span></span><br><span class="line">npx prettier --check .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用prettier检测并修复所有文件</span></span><br><span class="line">npx prettier --write .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改package.json ,添加scrit</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;prettier:check&quot;</span>: <span class="string">&quot;npx prettier . --check&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;prettier:fix&quot;</span>: <span class="string">&quot;npx prettier . --write&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint&quot;</span>: <span class="string">&quot;npx eslint .&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Husky"><a href="#Husky" class="headerlink" title="Husky"></a>Husky</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add -D husky</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Edit <code>package.json &gt; prepare</code> script and run it once:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm set-script prepare <span class="string">&quot;husky install&quot;</span></span><br><span class="line">npm run prepare</span><br></pre></td></tr></table></figure><p>Add a hook:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit <span class="string">&quot;npx lint-staged&quot;</span></span><br><span class="line">git add .husky/pre-commit</span><br></pre></td></tr></table></figure><blockquote><p>或者直接使用 <code>npx husky-init &amp;&amp; pnpm i -D</code>  创建以上文件</p></blockquote><h2 id="Lint-staged"><a href="#Lint-staged" class="headerlink" title="Lint-staged"></a>Lint-staged</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add -D lint-staged</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在根目录下创建 <code>lint-staged.config.js</code>，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">&#x27;*.&#123;js,jsx,ts,tsx,vue&#125;&#x27;</span>: [<span class="string">&#x27;eslint --fix&#x27;</span>, <span class="string">&#x27;prettier --write&#x27;</span>],</span><br><span class="line">  <span class="string">&#x27;*.&#123;css,scss,less,md,json,yaml&#125;&#x27;</span>: [<span class="string">&#x27;prettier --write&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 .husky/pre-commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line">. <span class="string">&quot;<span class="subst">$(dirname -- <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>/_/husky.sh&quot;</span></span><br><span class="line"></span><br><span class="line">npx lint-staged</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Commitizen"><a href="#Commitizen" class="headerlink" title="Commitizen"></a>Commitizen</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add commitizen cz-conventional-changelog -D </span><br></pre></td></tr></table></figure><p>修改package.json文件，也可以在根目录创建 <code>.czrc</code> 文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">   <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;cz-conventional-changelog&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建husky脚本"><a href="#创建husky脚本" class="headerlink" title="创建husky脚本"></a>创建husky脚本</h3><p>.husky/prepare-commit-msg，在执行 <code>git commit</code>时，使用commitizen 的交互式命令来书写commitMsg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/prepare-commit-msg <span class="string">&quot;exec &lt; /dev/tty &amp;&amp; git cz --hook || true&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Commitlint"><a href="#Commitlint" class="headerlink" title="Commitlint"></a>Commitlint</h2><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install commitlint cli and conventional config</span></span><br><span class="line">pnpm add -D @commitlint/&#123;config-conventional,cli&#125;</span><br><span class="line"><span class="comment"># For Windows:</span></span><br><span class="line">pnpm add -D @commitlint/config-conventional @commitlint/cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure commitlint to use conventional config</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot;</span> &gt; commitlint.config.js</span><br></pre></td></tr></table></figure><h3 id="创建-husky-脚本"><a href="#创建-husky-脚本" class="headerlink" title="创建 husky 脚本"></a>创建 husky 脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/commit-msg <span class="string">&quot;npx --no -- commitlint --edit <span class="variable">$1</span>&quot;</span></span><br></pre></td></tr></table></figure><p>so easy!</p>]]></content>
      
      
      <categories>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Husky </tag>
            
            <tag> ESLint </tag>
            
            <tag> Prettier </tag>
            
            <tag> Commitizen </tag>
            
            <tag> Commitlint </tag>
            
            <tag> cz-conventional-changelog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈二进制——位运算及其应用</title>
      <link href="post/%E4%BA%8C%E8%BF%9B%E5%88%B6-%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>post/%E4%BA%8C%E8%BF%9B%E5%88%B6-%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0-概要"><a href="#0-概要" class="headerlink" title="0. 概要"></a>0. 概要</h2><p>前两篇文章我们了解了二进制的基本原理（<a href="https://segmentfault.com/a/1190000023833719">谈谈二进制（一）</a>）以及二进制的四则运算（<a href="https://segmentfault.com/a/1190000023880414">谈谈二进制（二）</a>），本篇我们一起来看看二进制的位运算。</p><p>先来看一下有哪些位运算：</p><p><img src="https://segmentfault.com/img/remote/1460000023918717" alt="位运算符表格"></p><p>上表中列出了我们编程语言中的所有位运算符以及它们对应的规则。在前面的文章中我们讲过，二进制的<code>1</code>和<code>0</code>对应了电子元器件中的高低电平，或是开和关，而实际上，<code>1</code>和<code>0</code>也可以代表逻辑中的<code>真</code>与<code>假</code>。因此，上表中的前三个运算符其实也是逻辑运算符，而它们在逻辑运算中的规则，和二进制位运算基本一致，我们会在文中提及时做一些说明。</p><h2 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1. 位运算"></a>1. 位运算</h2><p>所谓位运算，指的是直接对二进制的位进行的运算，它只针对二进制的每一个位，所以它与前面我们讲的四则运算的最根本的区别是：<strong>位运算没有进位</strong>。</p><p>注意了，本篇文章所谈的位运算，都是针对二进制的运算，虽然我们可以将这些运算符直接作用在十进制数上（代码中），但它背后的计算过程却是针对该数对应的二进制数的。</p><p>我们一个一个来看。</p><h2 id="1-1-与"><a href="#1-1-与" class="headerlink" title="1.1 与"></a>1.1 与</h2><p>与运算，运算符号是<code>&amp;</code>。首先，与运算是一个二元运算，什么意思呢？就是像我们的加减乘除四则运算一样，与运算也需要两个数进行运算，然后生成第三个数，譬如：<code>A &amp; B = C</code>。</p><p>与运算的规则正如上面表格中所说，**参与运算的两个数的每个对应位上的数，如果都为<code>1</code>，则结果也为<code>1</code>，否则为<code>0</code>**。解释一下，假如我们有两个只有一位的最简单的二进制数，那么它们之间进行与运算的结果只有如下三种：<code>1 &amp; 1 = 1</code>，<code>1 &amp; 0 = 0</code>，<code>0 &amp; 0 = 0</code>。嗯，至少在这组运算中，看上去是不是很像乘法？实际上前面我们也说到了，位运算表格中的前三个运算符也是逻辑运算符，这里我们把<code>1</code>看做<code>真</code>，<code>0</code>看做<code>假</code>，则这三个运算结果就变成了逻辑运算的结果，<code>&amp;</code>所代表的<code>与</code>，其实就是<code>且</code>。<code>真且真</code>，其结果才能为真，否则都为假，也就是<code>0</code>了。</p><p>上面说的是一位二进制的运算情况，也顺带提了一下逻辑运算，那么多位的二进制数之间的与运算又是怎样的呢？其实就是把两个数的每一位都与对方做一个与运算，最后把结果按位排列起来就行了，竖式如下：</p><p><img src="https://segmentfault.com/img/remote/1460000023918716" alt="与运算"></p><p>上面两个数分别对应十进制的<code>5</code>和<code>7</code>，我们可以用代码去验证一下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">print</span>(<span class="number">5</span>&amp;<span class="number">7</span>)    # <span class="number">5</span></span><br></pre></td></tr></table></figure><p>这就是二进制的与运算，是不是非常简单？其实早在前面讲四则运算的时候我们就已经发现，二进制的运算真的非常简单，而今天我们看到的位运算，甚至连进位都省了，真的是……简单。</p><h2 id="1-2-或"><a href="#1-2-或" class="headerlink" title="1.2 或"></a>1.2 或</h2><p>紧接着，或运算，运算符为<code>|</code>，同样是二元运算。它和上面的与运算的运算方式一致，也是两个数的每一位与对方的对应为进行运算，运算规则唯一不同的地方就是，**或运算只需要其中一个数为<code>1</code>，结果就为<code>1</code>**。即两个一位二进制数之间的或运算的结果有如下三种：<code>1 | 1 = 1</code>，<code>1 | 0 = 1</code>，<code>0 | 0 = 0</code>。同样的，或运算也是一种逻辑运算，这里就不再展开了，我们直接来看例子，还是<code>5</code>和<code>7</code>：</p><p><img src="https://segmentfault.com/img/remote/1460000023918719" alt="或运算"></p><p>结果是<code>7</code>，我们同样用代码去验证一下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">print</span>(<span class="number">5</span>|<span class="number">7</span>)    # <span class="number">7</span></span><br></pre></td></tr></table></figure><p>非常简单。</p><h2 id="1-3-异或"><a href="#1-3-异或" class="headerlink" title="1.3 异或"></a>1.3 异或</h2><p>异或运算，运算符为<code>^</code>，也是一个二元运算，运算方式同前面两个运算一样，规则方面：**对应位的两个数<code>不同</code>时为<code>1</code>，否则为<code>0</code>**。它的运算规则一部分和或运算类似，只要两个数中有一个是<code>1</code>，结果就可以是<code>1</code>，但必须是相异的两个数。这大概就是它<code>异或</code>这个名字的来源。</p><p>依然是<code>5</code>和<code>7</code>，我们来看一下结果：</p><p><img src="https://segmentfault.com/img/remote/1460000023918718" alt="异或运算"></p><p>结果是<code>10</code>，也就是<code>2</code>，验证一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">5</span>^<span class="number">7</span>)    <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><p>记得，异或就是不相同时为<code>1</code>，相等为<code>0</code>，也就是判断两个对应数字是否<code>不相等</code>。同时，异或也是一个逻辑运算符，运算规则同理。</p><h2 id="1-4-取反"><a href="#1-4-取反" class="headerlink" title="1.4 取反"></a>1.4 取反</h2><p>取反运算，符号为<code>~</code>。这个运算就稍微有点特殊了，首先，它是一种一元运算，也就是它只对一个数进行位运算，然后形成结果；其次，取反运算还涉及到了补码、反码、原码之类的问题。</p><p>我们先来看它的规则：**二进制每一位数取反，即<code>0</code>变<code>1</code>，<code>1</code>变<code>0</code>**。看上去非常简单对吧？我们来按照我们初步理解的规则试一下：</p><p><img src="https://segmentfault.com/img/remote/1460000023918721" alt="取反运算"></p><p>*<strong>（注意，上面这个答案是错误的。）*</strong></p><p>我们对<code>101（5）</code>取反得到了<code>010</code>也就是<code>2</code>，然后用代码验证一下：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(~<span class="number">5</span>)    <span class="comment"># -6</span></span><br></pre></td></tr></table></figure><p>结果是<code>-6</code>！好奇怪，我们再用<code>C++</code>试一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    number = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; ~number;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -6</span></span><br></pre></td></tr></table></figure><p>结果依然是<code>-6</code>！</p><p>正如前面所说，按位取反运算涉及到了补码之类的骚操作，而这些内容不在本篇文章的涉及范围内，将会在下一篇二进制文章中讲解，因此这里不做详细展开，只大概解释一下：</p><p>上面我们用到的<code>int</code>型的整数都是有符号数，而计算机在存储有符号数时均使用<code>二进制补码</code>，而补码这个东西，简单说会在高位（数字自身的二进制范围以外）表示数字的正负，其中<code>0</code>表示正，<code>1</code>表示负，因此我们在做按位取反操作后，原数字不仅仅是自身按位取反，高位上的我们看不见的部分也取反了，所以<code>5</code>变成<code>-6</code>，就是从正数变成了负数。那为什么是<code>-6（-110）</code>呢？这个就涉及到负数补码的运算过程了，等我们下一篇讲到的时候再提。</p><p>总之我们记住，按位取反的结果就是<strong>原数取负值后再减一</strong>。譬如上面的<code>5</code>变成<code>-6</code>，就是<code>5 × (-1) - 1 = -6</code>，同样的，我们如果对<code>-6</code>取反，会得到<code>-6 × (-1) - 1 = 5</code>。</p><p>以上就是按位取反，细心的朋友可能注意到了，这里其实还有个小问题，上面提到的按位取反变成负数，是因为补码，而补码的高位会用<code>1</code>和<code>0</code>表示正负，那么如果对一个无符号整型做取反呢？我们来试验一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> five;</span><br><span class="line">    five = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; ~five;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4294967290</span></span><br></pre></td></tr></table></figure><p>对于一个无符号数<code>5</code>取反后得到了<code>4294967290</code>，看上去有点像溢出了，但实际上，<code>4294967290</code>这个数等于$2^{32}-6$，这两个数，用<code>32</code>位二进制数表示，分别是这样的：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0000</span>,<span class="number">0000</span>,<span class="number">0000</span>,<span class="number">0000</span>,<span class="number">0000</span>,<span class="number">0000</span>,<span class="number">0000</span>,<span class="number">0101</span>    // <span class="number">5</span></span><br><span class="line"><span class="attribute">1111</span>,<span class="number">1111</span>,<span class="number">1111</span>,<span class="number">1111</span>,<span class="number">1111</span>,<span class="number">1111</span>,<span class="number">1111</span>,<span class="number">1010</span>    // <span class="number">4294967290</span></span><br></pre></td></tr></table></figure><p>整个<code>32</code>位都对上了，这回是真·按位取反了。这是无符号数的特殊性，却更符合我们的直觉。而$2^{32}-6$中的这个<code>-6</code>很凑巧，正好是有符号数<code>5</code>的取反结果，实际上我们如果用更多的数去试，会发现这并不是凑巧，而是确确实实的规律。等到我们讲到补码的时候，就明白是怎么回事了。</p><h3 id="1-5-左移"><a href="#1-5-左移" class="headerlink" title="1.5 左移"></a>1.5 左移</h3><p>好了，最麻烦的一个运算讲完了，接下来是两个互为逆运算的运算，先来看看左移运算。</p><p>左移运算，符号为<code>&lt;&lt;</code>，是一个二元运算。运算规则是，**二进制所有位全部左移若干位，若高位溢出，则丢弃，低位补<code>0</code>**。很多人第一次看到这个运算的时候会很懵，不知道它到底要干嘛，什么叫左移若干位？其实它的运算规则也很简单，我们举一个例子来看，还是<code>101（5）</code>好了，我们来计算一下<code>101 &lt;&lt; 1</code>的结果，这个式子的意思是，<code>101</code>这个数左移<code>1</code>位。</p><p><img src="https://segmentfault.com/img/remote/1460000023918720" alt="左移运算"></p><p>我们注意观察<code>1010</code>这个结果，看上去是不是就像，在<code>101</code>的后面（右边）加了一个<code>0</code>？嗯，没错，这个直觉是对的，<code>101 &lt;&lt; 1</code>就是在<code>101</code>的后面加了一个<code>0</code>。那为什么叫左移呢？我们来把上面的竖式稍稍做一些改动：</p><p><img src="https://segmentfault.com/img/remote/1460000023918722" alt="左移运算过程"></p><p>我们在<code>101</code>的右边加了一个基准线，然后当我们做<code>101 &lt;&lt; 1</code>时，以这根线为准，整个<code>101</code><strong>向左</strong>移动了<code>1</code>位，最后在<code>101</code>和基准线之间添加一个<code>0</code>，得到了<code>1010</code>这个结果。这就是<strong>左移</strong>的原因了，虽然看起来像是在原数的右边加了<code>0</code>，其实是<strong>整个数字以一根看不见的线为基准，向左移动了<code>n</code>位</strong>。因为右边是低位，所以低位补<code>0</code>，而高位如果超过了表示范围，发生了溢出，就直接丢弃。</p><p>解释完了运算规则，我们再来看看<code>101 &lt;&lt; 1</code>的结果<code>1010</code>，这个数字的十进制是<code>10</code>，正好是<code>101（5）</code>的<code>2</code>倍，那如果我们继续左移呢？也就是<code>101 &lt;&lt; 2 = 1010 &lt;&lt; 1 = 10100</code>，这个<code>10100（20）</code>又是<code>10</code>的<code>2</code>倍，<code>5</code>的<code>4</code>倍。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">print</span>(<span class="number">5</span>&lt;&lt;<span class="number">1</span>)    # <span class="number">10</span></span><br><span class="line"><span class="attribute">print</span>(<span class="number">5</span>&lt;&lt;<span class="number">2</span>)    # <span class="number">20</span></span><br></pre></td></tr></table></figure><p>看来我们发现了一个规律：<strong>二进制每左移运算一位，则结果是原来的<code>2</code>倍</strong>。所以如果左移<code>n</code>位，得到的结果就是原来的$2^n$倍。</p><p>这是个很显而易见的规律，但许多人在刚接触左移，二进制的时候，不是很理解，为什么是<code>2</code>的倍数？因为……这是二进制，嗯，就么简单。好吧，我再举一个例子，相信不懂的朋友们看了这个例子就明白了。</p><p>我这里创造一个运算符<code>&lt;-</code>（我不知道实际上有没有这样的运算符），假设它的作用和<code>&lt;&lt;</code>一样，也是左移，但作用于<code>十进制</code>数字，运算规则和<code>&lt;&lt;</code>一模一样。接着我们来计算<code>5 &lt;- 1</code>，按照左移运算的规则，<code>5</code>向左移动一位，低位补<code>0</code>，结果就是<code>50</code>。看到了吗？这个结果是<code>5</code>的<code>10</code>倍！也就是我们平时常说的，在什么什么数字后面加个<code>0</code>。十进制，所以倍数是<code>10</code>，二进制，所以倍数是<code>2</code>，这一点相信看过我前面文章<strong>【<a href="https://link.segmentfault.com/?enc=CSFCYAN1h185/be1r4rx3g==.AYhn8DqvHp+1wCkTZVBe3+UpI+UicerrAnUK8dlMxTqyc3Z/qhlXVQIS/k/HEro/">谈谈二进制（一）</a>】</strong>的朋友们一定不会陌生。同理，如果在八进制数后面添一个<code>0</code>，结果会是原数的<code>8</code>倍，十六进制就是<code>16</code>倍。</p><p>左移运算其实帮我们又进一步地理解了进制。</p><h3 id="1-6-右移"><a href="#1-6-右移" class="headerlink" title="1.6 右移"></a>1.6 右移</h3><p>说完了左移，接着是右移。右移是左移的逆运算，也就是原数右边（和上面左移相同位置）以一根线为基准，整体<strong>向右</strong>移动<code>n</code>位，低位，也就是移动到基准线右边的数字则被丢弃。</p><p>譬如<code>101 &gt;&gt; 1 = 10</code>，所以<code>5 &gt;&gt; 1 = 2</code>。我们知道，整数的除法计算时会舍去小数部分，因此<code>5 / 2 = 2</code>，则右移是除以$2^n$这个规则也成立。</p><h2 id="2-位运算的应用"><a href="#2-位运算的应用" class="headerlink" title="2. 位运算的应用"></a>2. 位运算的应用</h2><h3 id="2-1-代码库中的应用"><a href="#2-1-代码库中的应用" class="headerlink" title="2.1 代码库中的应用"></a>2.1 代码库中的应用</h3><p>很多人觉得二进制位运算这个东西学了没用，因为平时写代码也用不到。但实际上，二进制位运算在一些代码库中非常常见，它常被用于设置一些标识（<code>flag</code>），做一些定制化的设置工作。举几个例子，最近在用做<code>Go</code>语言做项目，<code>Go</code>语言标准库中的<code>log</code>和文件打开操作都用到了二进制的位运算：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span> main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    f, _ := <span class="built_in">os</span>.OpenFile(<span class="string">&quot;filename&quot;</span>, <span class="built_in">os</span>.O_WRONLY|<span class="built_in">os</span>.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    defer f.Close()</span><br><span class="line">    <span class="built_in">log</span>.SetFlags(<span class="built_in">log</span>.Ldate|<span class="built_in">log</span>.Lshortfile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们的用法一致，都是用或运算来设置标志位。除标准库外，很多第三方库也用到了二进制的位运算，譬如<code>Go</code>语言的一个用来做定时任务的第三方库<code>cron</code>（<a href="https://link.segmentfault.com/?enc=AbgGTqQC2fFiUU1y1vNHvA==.INyePMeAGbACO3Gvmw7Sk610GfLf1ik4pe/33kHuyI8=">https://github.com/robfig/cron</a>）中用来解析<code>Crontab</code>表达式的部分，就用到了和上面标准库中类似的方法。具体细节就不展开讲了，大家有兴趣的可以去看一下它们的源码。</p><h3 id="2-2-算法应用"><a href="#2-2-算法应用" class="headerlink" title="2.2 算法应用"></a>2.2 算法应用</h3><p>上面说的几个都是在代码库中的应用，因为涉及源码细节比较多，限于篇幅没有展开。这里介绍一个实际的算法例子，来看一下二进制的位运算在解决实际问题时的具体细节。</p><p><code>leetcode</code>第<code>287</code>题<strong>Find the Duplicate Number（寻找重复数）</strong>，这题有很多种解法，其中就可以使用二进制的位运算来设置标志位，从而解决问题。我先把原问题的中文版题目贴上来：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含 n + <span class="number">1</span> 个整数的数组 nums，其数字都在 <span class="number">1</span> 到 n 之间（包括 <span class="number">1</span> 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>. 不能更改原数组（假设数组是只读的）。</span><br><span class="line"><span class="number">2</span>. 只能使用额外的 O(<span class="number">1</span>) 的空间。</span><br><span class="line"><span class="number">3</span>. 时间复杂度小于 O(n2) 。</span><br><span class="line"><span class="number">4</span>. 数组中只有一个重复的数字，但它可能不止重复出现一次。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">中文链接：https:<span class="regexp">//</span>leetcode-cn.com<span class="regexp">/problems/</span>find-the-duplicate-number</span><br><span class="line">英文链接：https:<span class="regexp">//</span>leetcode.com<span class="regexp">/problems/</span>find-the-duplicate-number/</span><br></pre></td></tr></table></figure><p>然后是代码：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution:</span><br><span class="line">    def findDuplicate(self, nums: List[int]) -&gt; int:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        base = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> base == base | (<span class="number">1</span> &lt;&lt; i):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            base |= (<span class="number">1</span> &lt;&lt; i)</span><br></pre></td></tr></table></figure><p>我直接把<code>leetcode</code>上提交的代码拿上来了，所以保留着<code>leetcode</code>上的格式。在解析这段代码之前，有些情况我要先说明一下，其实这段代码并没有完全符合题干中的要求，题干<code>说明2.</code>要求我们只能使用额外<code>O(1)</code>的空间，但上面的代码其实使用了<code>O(n)</code>的空间，因为<code>for</code>循环中每一次循环都计算产生了一个<code>1 &lt;&lt; i</code>。当然，这段代码可以通过<code>leetcode</code>，而且这个小问题并不影响我们今天的主题，二进制位运算，所以可以暂时忽略它。大家也可以想一想，有没有什么办法可以改造一下这段代码，让它只使用<code>O(1)</code>的空间呢？</p><p>我们来看代码，首先，我们设一个基准值<code>base = 0</code>，然后开始遍历传入的数字列表<code>nums</code>，接着是一个判断语句，它很重要，但我们先略过它，来看代码的最后一句<code>base |= (1 &lt;&lt; i)</code>。这句什么意思呢？我们拆解一下来看。</p><p><strong>它是让<code>base</code>与另一个数进行<code>或运算</code>得到一个新的<code>base</code><strong>，而<code>base</code>或运算的对象是<code>1 &lt;&lt; i</code>，我们知道，<code>i</code>是<code>num</code>中循环的元素，所以<code>1 &lt;&lt; i</code>得到的二进制结果会是一个<code>1</code>加上<code>i个0</code>，譬如<code>1 &lt;&lt; 3</code>，结果就是<code>1000（3个0）</code>。这种后面全<code>0</code>的二进制数，其实就是在告诉我们它的</strong>位置</strong>，<code>1000</code>就是说当前循环到的<code>3</code>这个值，它的位置在第三位（右边低位数起）。</p><p>我们将这个左移运算后的结果与<code>base</code>相或后，得到一个新的值，因为<code>base</code>一开始是<code>0</code>，按照或运算的规则，<code>0</code>与任何数相或，都是那个数自己。所以，结合上面解析的左移运算结果的意义，这个或运算的目的，是<code>nums</code>列表中的元素在<strong>占位</strong>，先来先到：<strong>如果我前面没有跟我一样的元素，则我就占到了属于我的位置上</strong>。那如果前面已经有了呢？那么<strong>它在位移运算后再与<code>base</code>相或，得到的值依然是<code>base</code>的原值</strong>，也就达到了刚才被我们略过的那句判断<code>if base == base | (1 &lt;&lt; i)</code>的触发条件，也就找到了那个重复的数。</p><p>为什么呢？这依然是或运算的规则导致的，<code>1 | 1 = 1</code>，刚才我们说到，<code>1 &lt;&lt; i</code>的意义是声明位置，属于我的位置就是<code>1</code>，如果前面有了一个和我相同的元素，则那个位置在我来之前就被占而置为<code>1</code>了。这时，我如果再和<code>base</code>进行或运算，那个属于我的位置在运算后还是<code>1</code>，<code>base</code>没有任何改变，因此<code>if</code>语句的条件就成立了。</p><p>譬如一个列表<code>[3, 1, 3]</code>，第一个数是<code>3（1 &lt;&lt; 3 = 1000）</code>，第一次<code>if</code>判断为<code>False</code>，<code>base</code>自或运算，得到<code>base = 1000</code>；</p><p>第二轮是<code>1（1 &lt;&lt; 1 = 0010）</code>，与<code>base</code>或运算后为<code>1010</code>，不等于<code>base</code>的当前值<code>1000</code>，判断为假，计算后赋值<code>base = 1010</code>；</p><p>第三轮是<code>3（1 &lt;&lt; 3 = 1000）</code>，与<code>base</code>或运算后得到<code>1010 | 1000 = 1010</code>，而<code>base</code>的原值也是<code>1010</code>，于是<code>if</code>语句被触发，我们找到了这个重复的值<code>3</code>。</p><p>这就是这一题二进制位运算解法的详尽算法思路，其实在我们理解了位运算后，这种思路很容易就能理解，它的核心就是一个<code>占位</code>。有了这种思维后，我们再去看<code>2.1</code>章节中提及的那些代码库的二进制算法，相信也会容易了很多。</p><p>结尾之前，这里要再提一个东西。上面这段代码，其实有一个看上去像<code>BUG</code>的地方：<strong>如果<code>base</code>的或运算对象是<code>0</code>呢？那不就也等于自身了吗？</strong>嗯，首先，题目中给的数字是<code>1到n之间</code>，所以一定是正整数，那么<code>1 &lt;&lt; i</code>的结果就不可能为<code>0</code>。实际上，即使<code>i</code>为<code>0</code>，这个结果也不可能为<code>0</code>，而是<code>1</code>。按照位移运算的规则，只有<code>1</code>右移运算后，结果才能为<code>0</code>。那如果左移<strong>负数</strong>个单位呢？很遗憾，左移不支持负值，会报错：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">print</span>(<span class="number">1</span> &lt;&lt; -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ValueError: negative shift count</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈二进制-原码、补码、反码、移码</title>
      <link href="post/%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E7%A7%BB%E7%A0%81/"/>
      <url>post/%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E7%A7%BB%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="0-概要"><a href="#0-概要" class="headerlink" title="0. 概要"></a>0. 概要</h2><p>老规矩，先回顾一下前面三篇文章我们都讲了什么。</p><p>首先，第一篇<a href="https://segmentfault.com/a/1190000023833719">【谈谈二进制（一）】</a>我们从进制本身的意义开始，认识了二进制和其他进制，然后完成了十进制和其他各种进制之间的转换。</p><p>接着，第二篇<a href="https://segmentfault.com/a/1190000023880414">【谈谈二进制（二）——四则运算】</a>中，我们则通过十进制的四则运算原理，推导出二进制的四则运算。</p><p>上一篇<a href="https://segmentfault.com/a/1190000023918713">【谈谈二进制（三）——位运算及其应用】</a>，我们将二进制从纯数学的世界中带到了计算机的世界里，并通过一个真实的算法题，了解了二进制位运算在实际编程中的使用。</p><p>今天这篇，我们来看看二进制在计算机中的特殊表示。</p><h2 id="1-有符号数和无符号数"><a href="#1-有符号数和无符号数" class="headerlink" title="1. 有符号数和无符号数"></a>1. 有符号数和无符号数</h2><p>在讲各种码之前，先来熟悉一下两个概念：<strong>有符号数</strong>和<strong>无符号数</strong>。这两个概念很好理解，就是字面的意思，一个数值是否有正负符号。</p><p>在上一篇文章中，按位取反的部分，我们在<code>C++</code>代码中用<code>unsigned</code>关键字定义了一个无符号数。无符号数的意思就是，这个数字存储在计算机中的时候是没有符号的，也就是正数；而有符号数则会把正负号也存入计算机中。但我们知道，计算机所有的数值都是由二进制组成的，那么正负号这种东西该怎么存储呢？</p><p>其实正和负这两个东西，就像布尔型的真和假一样，是两种截然相反的状态，因此正和负也可以使用<code>0</code>和<code>1</code>来表示，计算机里实际也是这么做的：<code>0</code>表示正，<code>1</code>表示负。并且正负号在原数有效数的最前面（左边），所占的这一位被称为<strong>符号位</strong>。譬如<code>+1001</code>，它的实际存储值就是<code>0,1001</code>，<code>-1001</code>就是<code>1,1001</code>，符号位在逗号的左边。这里的逗号，实际上是一种为了书写方便以及区别整数小数的约定俗成的写法，即整数的数值与符号位之间用逗号隔开，而小数的符号位和数值位之间则以小数点隔开，譬如<code>-0.1001</code>，会写成<code>1.1001</code>。</p><p>这种把正负号给<strong>数字化</strong>后的数值，被称为<strong>机器数</strong>，带正负号的原数被叫做<strong>真值</strong>。</p><p>讲各种码之前，这里还要提一句，原码、补码、反码、移码这些码，都只是机器数的不同表示形式，就像前面我们讲过的进制，无论二进制还是十进制，对于同一个数值来讲，也只是不同的表示方法而已。</p><h2 id="2-原码"><a href="#2-原码" class="headerlink" title="2. 原码"></a>2. 原码</h2><p>先来看原码，原码是众多码中最简单的一种机器数表示法，其实我们上面在说有符号位的符号的时候，就已经把原码的概念给讲完了，<strong>原码就是符号位和真值的绝对值组成的</strong>。它和真值之间仅仅是正负号被换成了<code>0</code>和<code>1</code>，然后根据整数或小数加上<code>,</code>，也就是上文中写到的那几个例子，这里简单罗列一下：</p><p>[+1001]_{原}=0, 1001[+1001]原=0,1001</p><p>[-1001]_{原}=1, 1001[−1001]原=1,1001</p><p>[+0.1001]_{原}=0. 1001[+0.1001]原=0.1001</p><p>[-0.1001]_{原}=1. 1001[−0.1001]原=1.1001</p><p>不过这里有几点我们要提一下，非常有意思。</p><p>第一个是整数负数的原码，上文中我们知道，就是把负号给换成<code>1</code>，然后写的时候加一个逗号，举个例子，<code>-1001（-9）</code>，原码表示为<code>1, 1001</code>。这里我们做一个大胆的试验：把逗号去掉，然后把剩余的<code>11001</code>看做一个完整的二进制正整数，也就是<code>25</code>，看看它跟<code>-1001（-9）</code>有什么联系。</p><p>从十进制上的数来看，乍看之下<code>25</code>和<code>（-9）</code>好像没什么联系，然后我们来看二进制<code>11001</code>和<code>-1001</code>，咦？似乎有点像，除了最高位的<code>1</code>和负号之外，余下的<code>4</code>位一模一样，我们把它俩相加：<code>11001 + (-1001) = 10000</code>。嘿，这就更有意思了，熟悉二进制运算的朋友们肯定一眼就看出来，<code>10000</code>实际上就是$2^4=16$。</p><p>我们是不是可以从这个试验中猜测一个结论：<strong>一个负整数的原码，等于<code>2</code>的<code>n</code>次方减去自己</strong>？没错，这是一个正确的结论。这里的关键是，<code>n</code>是多少？上面的试验中我们的<code>n</code>为<code>4</code>，这里的<code>4</code>，<strong>其实就是原数的位数</strong>。用数学表达式表达就是：当$0≥x&gt;-2^n$（x为原数真值）时，则$[x]_{原}=2^n-x$。</p><p>正整数就没啥好说的，直接在真值绝对值前面加个<code>0,</code>。</p><p>再来看看小数，因为小数的符号位和数值位用小数点隔开，因此当<code>0 ≤ x &lt; 1</code>时，也就是正小数时，它的原码就等于它自己。负小数呢？譬如<code>-0.1001</code>，原码写成<code>1. 1001</code>，也很简单，就是<code>1. 1001 = 1 - (-0.1001)</code>。</p><p>原码就是这样，后面的这些数学运算规律其实不管也无所谓，因为原码本身实在是太简单易懂了。</p><h2 id="3-补码"><a href="#3-补码" class="headerlink" title="3. 补码"></a>3. 补码</h2><p>补码就稍微复杂一点，它的基础原理涉及到了<code>补数</code>和<code>模</code>的概念，这里我参考了<strong>唐朔飞老师的《计算机组成原理》</strong>中的一些概念和例子来讲解。</p><h2 id="3-1-补数和模"><a href="#3-1-补数和模" class="headerlink" title="3.1 补数和模"></a>3.1 补数和模</h2><p>补数的概念初次接触会觉得陌生，但它实际上可能就存在于我们的日常生活中。譬如，某一时刻时钟的某个指针指向<code>6</code>，如果我们想让它指向<code>3</code>，我们可以让指针沿逆时针方向走<code>3</code>格，也可以让它沿顺时针方向能走<code>9</code>格，最终都会让这个指针指向<code>3</code>。假设顺时针方向为正，逆时针方向为负，则刚才的两个行为分别为：<code>6 + (-3) = 3</code>和<code>6 + 9 = 15</code>。</p><p>我们知道，虽然我们日常采用<code>24</code>小时制，但钟表上的刻度通常只有<code>12</code>个刻度，因此指针超过<code>12</code>时，就会回归<code>1</code>、<code>2</code>等等。因此上面我们得到的<code>15</code>，实际上是<code>15 - 12 = 3</code>，也就是我们一开始所要达到的指向<code>3</code>的目的地。所以这里<code>15</code>和<code>3</code>在时钟上指向的都是<code>3</code>，那么，在刚才的操作过程中，<code>-3</code>和<code>+9</code>对时钟而言，作用是一样的，都是让原本在<code>6</code>的指针，指向了<code>3</code>。</p><p>上面的例子里，在数学上，称时钟的<code>12</code>格刻度为<code>模</code>，写作<code>mod 12</code>，而<strong>称<code>+9</code>是<code>-3</code>以<code>12</code>为模的补数</strong>，记作</p><p>-3 ≡ +9 \qquad（\text{mod}\ 12）−3≡+9（mod 12）</p><p>或者说，对于<code>模12</code>而言，<code>-3</code>和<code>+9</code>是互为补数的。同理有</p><p>-4 ≡ +8 \qquad（\text{mod}\ 12）−4≡+8（mod 12）</p><p>-5 ≡ +7 \qquad（\text{mod}\ 12）−5≡+7（mod 12）</p><p>即对于<code>模12</code>而言，<code>+8</code>和<code>+7</code>分别是<code>-4</code>和<code>-5</code>的补数。可见，只要确定一个<code>模</code>，就可以找到一个与负数等价的正数来代替该负数，而这个得到的正数，即为负数的<code>补数</code>，同时，我们观察到，<strong>该负数的绝对值，和它的补数相加，就是模</strong>（结论一）。</p><p>那么当我们有一个负数，且已知模时，如何求它对应的正数补数呢？很简单，只需要<strong>让负数和模相加</strong>（结论二），譬如<code>-4 + 12 = 8 （mod 12）</code>，这个<code>+8</code>就是<code>-4</code>的补数了。</p><p>这就是模和补数的概念。这里大家可能会有疑问了：上面的几个式子和最后的结论，讲的都是负数的补数，那么正数有补数吗？</p><p>有的，但先别着急，我们先来看下，上面我们求得的负数的模到底有什么用。其实参考我们一开始讲的时钟的例子，我们隐隐约约可以感觉到，补数这个东西，<strong>可以让减法变成加法</strong>。依然来看一个例子，我们设<code>A = 9, B = 5</code>，求<code>A - B（mod 12）</code>。最通常的解法是减法：</p><p>A - B = 9 - 5 = 4<em>A</em>−<em>B</em>=9−5=4</p><p>这么解肯定没问题，但我们题目中给出了<code>mod 12</code>，那么对模<code>12</code>而言，<code>-5</code>可以用它的补数<code>+7</code>代替，他们是恒等的，于是这题的另一个解法如下：</p><p>A - B = 9 + 7 = 16<em>A</em>−<em>B</em>=9+7=16</p><p>这样我们得到了<code>16</code>，回想一下时钟，<code>16</code>这个数字是不存在的，当时钟拨到<code>16</code>时，其实是<code>4</code>，所以对于<code>mod 12</code>，<code>16</code>又等价于<code>4</code>，即<code>4 ≡ 16（mod 12）</code>。那么如果此时时钟再顺时针转一圈（<code>12</code>格），到了<code>28</code>呢？它依然是<code>4</code>，即</p><p>4 ≡ 16 ≡ 28 \qquad（\text{mod}\ 12）4≡16≡28（mod 12）</p><p>4 ≡ 4 + 12 ≡ 4 + 2\times12 ≡ 4 \qquad（\text{mod}\ 12）4≡4+12≡4+2×12≡4（mod 12）</p><p>这也就是说，<strong>正数的补数，就是正数本身</strong>（结论三）。</p><p>前面讲进制时我们反复讲过一点，不同的进制之间仅仅是进位方式不同，所以上面我们虽然用的是十进制来介绍模，实际上二进制依然可以用模，结合模和补数的概念，以及上面的三个结论，我们可以得到如下二进制数的补数：</p><p>-1011 ≡ +0101 \qquad（\text{mod}\ 2^4）−1011≡+0101（mod 24）</p><p>+0101 ≡ +0101 \qquad（\text{mod}\ 2^4）+0101≡+0101（mod 24）</p><p>-0.1001 ≡ +1.0111 \qquad（\text{mod}\ 2）−0.1001≡+1.0111（mod 2）</p><p>+0.1001 ≡ +0.1001 \qquad（\text{mod}\ 2）+0.1001≡+0.1001（mod 2）</p><p>用上面粗体的三个结论，很容易就能求得各种数字的补数，这里几个二进制我就不再计算验证了，大家可以自己试一下。</p><p>有了补数的概念后，人们看到了它可以将减法变成加法，便将其概念用到了计算机中，于是出现了补码这种机器数。</p><h3 id="3-2-补码的定义"><a href="#3-2-补码的定义" class="headerlink" title="3.2 补码的定义"></a>3.2 补码的定义</h3><p>补码和原码一样，需要用一位数字在高位作为符号位表正负，而低位的数值部分则采用了补数的概念，因此，结合上面补数的特征，我们可以想象到，**因为正数的补数是它自己，因此在补码中，正数的数值位是它自己，符号位则同原码一样，正数为<code>0</code>，负数为<code>1</code>**。譬如下面两个例子：</p><p>[+1001]_{补}=0, 1001[+1001]补=0,1001</p><p>[+0.1001]_{补}=0. 1001[+0.1001]补=0.1001</p><p>也就是说，正数的补码和原码一样。</p><p>负数就要麻烦一些。首先，通过上一小节我们知道，二进制的补数计算方式和十进制一样，譬如<code>-1101</code>，它的最高位为第<code>3</code>位，因此我们取比它高一位的最小值$2^4$作为模，求得它的补数为<code>10000 + (-1101) = 0011</code>。按理说，我们得到的负数的补数是正数，这里只需要再加一个符号位<code>0</code>即可，但注意了，补码中的实际情况并不是这样，<strong>尽管负数的补数为正数，但负数的补码前的符号位依然是负符号位<code>1</code>，即符号位与原数保持一致</strong>。</p><p>为什么会这样？明明求得的补数是正数，符号位却要用负符号<code>1</code>？</p><p>实际上，在前面讲补数的时候我们提到过，<strong>补数的出现，可以让原本作减法的式子变成加法</strong>，补码这种机器数也正是看准了这一点才被计算机引入的。对于计算机来说，<strong>让减法变成加法，相当于让计算机只需要在硬件层面上实现一个加法器，就可以解决加减法两种问题</strong>。那么这里补码的符号位的问题，自然也是为了计算而设定如此的，我们来看一个实际的例子就知道了。</p><p>设<code>A = 1110，B = 1101</code>，我们来求<code>A - B</code>的值。常规用减法，一眼可以看出来，结果是<code>1110 - 1101 = 0001</code>。我们将<code>A</code>和<code>-B（-1101）</code>两个数都换成补码，用加法计算，此时$A = 0,1110\quad（mod\ 2^4）$，$-B = 1,0011\quad（mod\ 2^4）$。注意了，<strong>在使用补码计算时，补码的符号位也参与计算</strong>，那么此时这两个补码相加后的结果为：</p><p>0,1110 + 1,0011 = 10,0001 \qquad（\text{mod}\ 2^4）0,1110+1,0011=10,0001（mod 24）</p><p>我们看到，结果的符号位产生了进位，变成了<code>10</code>。这里其实涉及到了另一个知识点：<strong>补码运算的符号位进位（溢出）</strong>。由于篇幅关系，本文不对该知识点展开讲解，大家有兴趣的可以去查找资料了解一下。总之，这里符号位虽然进位了，但并没有发生溢出，我们把符号位的最高位<code>1</code>拿掉，得到了最终的结果<code>0,0001</code>，也就是<code>+0001</code>，与之前的减法结果一致。</p><p>这就是负数求补码后让符号位也保持负值<code>1</code>的原因了。上面讲的都是负正数，实际上负小数同理，这里不再赘述，我们直接上两个数学公式来对负数求补码进行一个总结。首先是整数，正整数就不说了，和原码一样，负整数呢？除了上面用标准的补数算法外，我们可以直接用下面这个公式来计算：</p><p>[x]_{补}=2^{n+1}+x\qquad0&gt;x≥-2^n\quad（\text{mod}\ 2^{n+1}）[<em>x</em>]补=2<em>n</em>+1+<em>x</em>0&gt;<em>x</em>≥−2<em>n</em>（mod 2<em>n</em>+1）</p><p>这里的<code>n</code>就是整数<code>x</code>的位数。拿前面我们算过的<code>-1101</code>举例：</p><p>[-1101]_{补}=2^{4+1}+(-1101)=100000-1101=1,0011[−1101]补=24+1+(−1101)=100000−1101=1,0011</p><p>最高位<code>1</code>就是符号位，与后面的数值位部分用逗号隔开，就得到了最终的结果。其实这里我们可以观察到一个规律：**负整数的补码，就是原数字除符号位外，数值部分的每一位按位求反后再<code>+1</code>**。</p><p>接着是负小数：</p><p>[x]_{补}=2+x\qquad0&gt;x≥-1\quad（\text{mod}\ 2）[<em>x</em>]补=2+<em>x</em>0&gt;<em>x</em>≥−1（mod 2）</p><p>看上去更简单了，举个例子，我们求<code>-0.1001</code>的补码：</p><p>[-0.1001]=2+(-0.1001)=10.0000 - 0.1001=1.1010[−0.1001]=2+(−0.1001)=10.0000−0.1001=1.1010</p><p>其实这里求负小数的补码的方式，和上一节中我们求小数的补数的方式是一样的。还记得上一节的<strong>结论二</strong>吗？求一个负数的补数，就是<strong>让负数和模相加</strong>。然后我们再仔细观察一下，会发现上面负整数的求补规律在负小数也奏效，即<strong>负数的补码，就是原数字除符号位外，数值部分的每一位按位求反后再<code>+1</code>，然后符号位该怎么写怎么写</strong>。记住这个结论，它能让我们在求补码的时候避免加减法运算，更加容易。</p><p>补码的概念基本就讲完了，想要掌握的话，其实还是需要自己拿笔算一算，写一写。</p><h2 id="4-反码"><a href="#4-反码" class="headerlink" title="4. 反码"></a>4. 反码</h2><p>反码，这种机器数的主要场景用于原码和补码的相互转换，反码作为中间数过度使用。首先，正数的反码，老样子，依然和原码一样，符号位<code>0</code>和<code>1</code>表示正负，然后是数值位部分原封不动，这里直接拿前面原码里的两个正数例子：</p><p>[+1001]_{反}=0, 1001[+1001]反=0,1001</p><p>[+0.1001]_{反}=0. 1001[+0.1001]反=0.1001</p><p>有区别的依然是负数，但反码的负数就简单多了：<strong>除了符号位，数值位部分每一位都按位取反</strong>。因此：</p><p>[-1001]_{反}=1, 0110[−1001]反=1,0110</p><p>[-0.1001]_{反}=1. 0110[−0.1001]反=1.0110</p><p>非常简单对不对？那么为什么说反码是原码和补码之间相互转换的中间过渡呢？在上一节补码的最后，我们得到了一个求补码的简单规律：<strong>负数的补码，就是原数字除符号位外，数值部分的每一位按位求反后再<code>+1</code>，然后符号位该怎么写怎么写</strong>。其实这个过程，就是对<strong>原码</strong>先求<strong>反码</strong>再给末位<code>+1</code>。同理，<strong>如果我们知道了一个补码，想要求它的原码，只需要先将补码的末位<code>-1</code>后，再将数值位部分按位求反即可</strong>。</p><p>好了，明白了这一点后，我们来看一个上一篇文章中遗留的问题。</p><h3 id="4-1-按位取反运算"><a href="#4-1-按位取反运算" class="headerlink" title="4.1 按位取反运算"></a>4.1 按位取反运算</h3><p>在上一篇文章<a href="https://segmentfault.com/a/1190000023918713">【谈谈二进制（三）——位运算及其应用】</a>中的取反运算部分，我们对有符号数<code>5</code>进行取反，却得到了<code>-6</code>这个匪夷所思的答案，当时我在文章中说，这是因为计算机中存储数字的方式都是用补码存储，之所以会得到负值，则是由于补码的最高位表示符号位，按位取反时连符号位一起取反了。今天我们深入了解了补码和反码，也推出了补码和原码之间的转换方式，那么就用今天的知识，来彻底解决这个按位取反的问题吧。</p><p>首先，<code>5</code>的二进制为<code>101</code>，其补码为<code>0,101</code>。在进行按位取反操作，即<code>~5</code>时，实际上把符号位也取反了，于是我们得到了<code>1,010</code>这个结果，请注意，这个<code>1,010</code><strong>依然是补码</strong>。而从符号位的<code>1</code>我们看到，这是一个负数补码，我们通过补码不能直观地看出它的真值，因此需要先转换成原码。按照前文我们提到的补码转原码的方式，先将<code>1,010</code>末位<code>-1</code>，得到<code>1,001</code>，接着，我们将数值位按位取反，符号位不动，得到<code>1,110</code>。此时，<code>1,110</code>已经是<strong>原码</strong>了，可以直接将其求出：</p><p>1,110=-110_{原}=-6_{(10)}1,110=−110原=−6(10)</p><p>于是，我们得到了这个<code>-6</code>。</p><p>这个让我们之前摸不着头脑的答案，在我们学完了补码之后，变得清晰明了。</p><p>除了这个<code>-6</code>之外，按位取反的部分还有一个小问题，我们后来又使用了一个无符号数<code>5</code>来进行按位取反，发现得到了一个巨大的数字<code>4294967290</code>，并且这个数实际上是$2^{32}-6$：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0000</span>,<span class="number">0000</span>,<span class="number">0000</span>,<span class="number">0000</span>,<span class="number">0000</span>,<span class="number">0000</span>,<span class="number">0000</span>,<span class="number">0101</span>    // <span class="number">5</span></span><br><span class="line"><span class="attribute">1111</span>,<span class="number">1111</span>,<span class="number">1111</span>,<span class="number">1111</span>,<span class="number">1111</span>,<span class="number">1111</span>,<span class="number">1111</span>,<span class="number">1010</span>    // <span class="number">4294967290</span></span><br></pre></td></tr></table></figure><p>这个问题其实可以有两种角度去理解，一种是最直观的：因为无符号数不涉及符号位的问题，而<code>C</code>语言中（这个数字是用<code>C++</code>求得的）<code>unsigned int</code>的取值范围在<code>32</code>位机器上为<code>0 ~ 4294967295</code>，没错，最大值就是上面的两个数之和$2^{32}-1$，也就是<code>32</code>个<code>1</code>。所以将<code>5（101）</code>左侧不存在的<code>0</code>都取反为<code>1</code>后，就得到了这么大的一个数字。</p><p>第二种角度就是来解释<code>-6</code>这个巧合了。我们只需要把$2^{32}$看做一个<strong>模</strong>，按照前面计算补数的运算方式，来求<code>-6</code>的补数，即让模和<code>-6</code>相加，就得到了<code>4294967290</code>这个数字，同时，<code>4294967290</code>是无符号数<code>5</code>按位求反的结果，它们相加的和，则是<code>unsigned int</code>的最大值（<code>32</code>位，$2^{32}-1$），本身就比$2^{32}$小<code>1</code>，<code>1 + 5 = 6</code>，于是就很凑巧的变成了我们看到的规律。</p><h2 id="5-移码"><a href="#5-移码" class="headerlink" title="5. 移码"></a>5. 移码</h2><p>补码对计算机来说是个好东西，毕竟它让计算机对于数字的计算变得更加方便了。但对人类来说，补码可就不那么友好了，不说和真值，哪怕和原码相比，补码也存在着一个巨大的缺点：数字本身的被补码隐藏，使得数字的大小不直观。举个例子：</p><p>+15_{补}=[+1111]_{补}=0,1111+15补=[+1111]补=0,1111</p><p>-15_{补}=[-1111]_{补}=1,0001−15补=[−1111]补=1,0001</p><p>如果我们把符号位的<code>1</code>也看作是整个二进制数的一部分，那么显然<code>10001 &gt; 01111</code>。虽然在我们懂得了补码的原理和运算过程后，我们并不会直接这么去比较，但因为负数的补码将数值部分都给改写了，总体来说，补码依然给人以非常不直观的感受，一旦逗号忘记写，或者其他原因造成了误读，那么补码之间的比较将成为灾难。就上面的两个数来说，我们很难一眼就看出来这两个二进制数居然互为相反数，但如果是用原码表示，那么起码他们的数值位是相同的，我们能第一时间反应过来。</p><p>此时，如果我们将两个数字的<strong>真值</strong>都加上$2^n$，这里的<code>n</code>同前面我们讲过的那些<code>n</code>一样，是真值的位数，那么新得到的两个数字的大小就变得很直观了：</p><p>15 + 2^4 = 1111 + 10000 = 1111115+24=1111+10000=11111</p><p>-15 + 2^4 = 10000 - 1111 = 00001−15+24=10000−1111=00001</p><p>尽管还是无法直接看出它俩的真值互为相反数，但我们可以很直观地比较出这两个数字的实际大小了，不会因为符号位的问题造成误读。而这两个计算后得到的新数字，<strong>就是移码</strong>。</p><p>所以移码的数学定义非常简单：</p><p>[x]_{移}=2^n+x\qquad（2^n&gt;x≥-2^n）[<em>x</em>]移=2<em>n</em>+<em>x</em>（2<em>n</em>&gt;<em>x</em>≥−2<em>n</em>）</p><p>这里的<code>n</code>就是真值的位数，<code>x</code>则是真值。</p><p>我们仔细观察上面两个数字的补码和移码，会发现一个有趣的现象：**移码实际上就是改变了补码的符号位，从<code>0</code>变<code>1</code>，从<code>1</code>变<code>0</code>**。这样一来，当我们知道了一个数的补码后，只需要替换它的符号位，就可以得到移码，从而与其他数值进行直接比较了。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 补码 </tag>
            
            <tag> 原码 </tag>
            
            <tag> 反码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go格式化输出</title>
      <link href="post/go%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"/>
      <url>post/go%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>下面实例使用到的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Website <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义结构体变量</span></span><br><span class="line"><span class="keyword">var</span> site = Website&#123;Name:<span class="string">&quot;duoke360&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><p><strong>普通占位符</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">占位符说明举例输出</span><br><span class="line">%v相应值的默认格式。Printf(<span class="string">&quot;%v&quot;</span>, site)，Printf(<span class="string">&quot;%+v&quot;</span>, site)&#123;duoke360&#125;，&#123;Name:duoke360&#125;</span><br><span class="line">在打印结构体时，“加号”标记（%+v）会添加字段名</span><br><span class="line">%#v相应值的Go语法表示Printf(<span class="string">&quot;#v&quot;</span>, site)main.Website&#123;Name:<span class="string">&quot;duoke360&quot;</span>&#125;</span><br><span class="line">%T相应值的类型的Go语法表示Printf(<span class="string">&quot;%T&quot;</span>, site)main.Website</span><br><span class="line">%%字面上的百分号，并非值的占位符Printf(<span class="string">&quot;%%&quot;</span>)%</span><br></pre></td></tr></table></figure><p><strong>布尔占位符</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">占位符说明举例输出</span><br><span class="line">%t单词 <span class="literal">true</span> 或 <span class="literal">false</span>。Printf(<span class="string">&quot;%t&quot;</span>, <span class="literal">true</span>)<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>整数占位符</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">占位符说明举例输出</span><br><span class="line">%b二进制表示Printf(<span class="string">&quot;%b&quot;</span>, <span class="number">5</span>)<span class="number">101</span></span><br><span class="line">%c相应Unicode码点所表示的字符Printf(<span class="string">&quot;%c&quot;</span>, <span class="number">0x4E2D</span>)中</span><br><span class="line">%d十进制表示Printf(<span class="string">&quot;%d&quot;</span>, <span class="number">0x12</span>)<span class="number">18</span></span><br><span class="line">%o八进制表示Printf(<span class="string">&quot;%o&quot;</span>, <span class="number">10</span>)<span class="number">12</span></span><br><span class="line">%q单引号围绕的字符字面值，由Go语法安全地转义Printf(<span class="string">&quot;%q&quot;</span>, <span class="number">0x4E2D</span>)<span class="string">&#x27;中&#x27;</span></span><br><span class="line">%x十六进制表示，字母形式为小写 a-fPrintf(<span class="string">&quot;%x&quot;</span>, <span class="number">13</span>)d</span><br><span class="line">%X十六进制表示，字母形式为大写 A-FPrintf(<span class="string">&quot;%x&quot;</span>, <span class="number">13</span>)D</span><br><span class="line">%UUnicode格式：U+<span class="number">1234</span>，等同于 <span class="string">&quot;U+%04X&quot;</span>Printf(<span class="string">&quot;%U&quot;</span>, <span class="number">0x4E2D</span>)U+<span class="number">4E2</span>D</span><br></pre></td></tr></table></figure><p><strong>浮点数和复数的组成部分（实部和虚部）</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">占位符说明举例输出</span><br><span class="line">%b无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat</span><br><span class="line">的 <span class="string">&#x27;b&#x27;</span> 转换格式一致。例如 <span class="number">-123456</span>p<span class="number">-78</span></span><br><span class="line">%e科学计数法，例如 <span class="number">-1234.456e+78</span>Printf(<span class="string">&quot;%e&quot;</span>, <span class="number">10.2</span>)<span class="number">1.020000e+01</span></span><br><span class="line">%E科学计数法，例如 <span class="number">-1234.456E+78</span>Printf(<span class="string">&quot;%e&quot;</span>, <span class="number">10.2</span>)<span class="number">1.020000E+01</span></span><br><span class="line">%f有小数点而无指数，例如 <span class="number">123.456</span>Printf(<span class="string">&quot;%f&quot;</span>, <span class="number">10.2</span>)<span class="number">10.200000</span></span><br><span class="line">%g根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的<span class="number">0</span>）输出Printf(<span class="string">&quot;%g&quot;</span>, <span class="number">10.20</span>)<span class="number">10.2</span></span><br><span class="line">%G根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的<span class="number">0</span>）输出Printf(<span class="string">&quot;%G&quot;</span>, <span class="number">10.20</span>+<span class="number">2i</span>)(<span class="number">10.2</span>+<span class="number">2i</span>)</span><br></pre></td></tr></table></figure><p><strong>字符串与字节切片</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">占位符说明举例输出</span><br><span class="line">%s输出字符串表示（<span class="keyword">string</span>类型或[]<span class="keyword">byte</span>)Printf(<span class="string">&quot;%s&quot;</span>, []<span class="keyword">byte</span>(<span class="string">&quot;多课网&quot;</span>))多课网</span><br><span class="line">%q双引号围绕的字符串，由Go语法安全地转义Printf(<span class="string">&quot;%q&quot;</span>, <span class="string">&quot;多课网&quot;</span>)<span class="string">&quot;多课网&quot;</span></span><br><span class="line">%x十六进制，小写字母，每字节两个字符Printf(<span class="string">&quot;%x&quot;</span>, <span class="string">&quot;golang&quot;</span>)<span class="number">676</span>f6c616e67</span><br><span class="line">%X十六进制，大写字母，每字节两个字符Printf(<span class="string">&quot;%X&quot;</span>, <span class="string">&quot;golang&quot;</span>)<span class="number">676</span>F6C616E67</span><br></pre></td></tr></table></figure><p><strong>指针</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">占位符说明举例输出</span><br><span class="line">%p十六进制表示，前缀 <span class="number">0</span>xPrintf(<span class="string">&quot;%p&quot;</span>, &amp;site)<span class="number">0x4f57f0</span></span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := user&#123;<span class="string">&quot;guo&quot;</span>&#125;</span><br><span class="line"><span class="comment">//Printf 格式化输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;% + v\n&quot;</span>, u)     <span class="comment">//格式化输出结构</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, u)       <span class="comment">//输出值的 Go 语言表示方法</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, u)        <span class="comment">//输出值的类型的 Go 语言表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%t\n&quot;</span>, <span class="literal">true</span>)     <span class="comment">//输出值的 true 或 false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, <span class="number">1024</span>)     <span class="comment">//二进制表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, <span class="number">11111111</span>) <span class="comment">//数值对应的 Unicode 编码字符</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, <span class="number">10</span>)       <span class="comment">//十进制表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%o\n&quot;</span>, <span class="number">8</span>)        <span class="comment">//八进制表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, <span class="number">22</span>)       <span class="comment">//转化为十六进制并附上单引号</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, <span class="number">1223</span>)     <span class="comment">//十六进制表示，用a-f表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X\n&quot;</span>, <span class="number">1223</span>)     <span class="comment">//十六进制表示，用A-F表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%U\n&quot;</span>, <span class="number">1233</span>)     <span class="comment">//Unicode表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, <span class="number">12.34</span>)    <span class="comment">//无小数部分，两位指数的科学计数法6946802425218990p-49</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%e\n&quot;</span>, <span class="number">12.345</span>)   <span class="comment">//科学计数法，e表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%E\n&quot;</span>, <span class="number">12.34455</span>) <span class="comment">//科学计数法，E表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, <span class="number">12.3456</span>)  <span class="comment">//有小数部分，无指数部分</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%g\n&quot;</span>, <span class="number">12.3456</span>)  <span class="comment">//根据实际情况采用%e或%f输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%G\n&quot;</span>, <span class="number">12.3456</span>)  <span class="comment">//根据实际情况采用%E或%f输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;wqdew&quot;</span>)  <span class="comment">//直接输出字符串或者[]byte</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, <span class="string">&quot;dedede&quot;</span>) <span class="comment">//双引号括起来的字符串</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, <span class="string">&quot;abczxc&quot;</span>) <span class="comment">//每个字节用两字节十六进制表示，a-f表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X\n&quot;</span>, <span class="string">&quot;asdzxc&quot;</span>) <span class="comment">//每个字节用两字节十六进制表示，A-F表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, <span class="number">0x123</span>)    <span class="comment">//0x开头的十六进制数表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go运算符</title>
      <link href="post/go%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>post/go%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>Go 语言内置的运算符有：</p><ol><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li></ol><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">相加</td></tr><tr><td align="left">-</td><td align="left">相减</td></tr><tr><td align="left">*</td><td align="left">相乘</td></tr><tr><td align="left">/</td><td align="left">相除</td></tr><tr><td align="left">%</td><td align="left">求余</td></tr></tbody></table><p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">100</span></span><br><span class="line">b := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;(a + b): %v\n&quot;</span>, (a + b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a - b): %v\n&quot;</span>, (a - b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a * b): %v\n&quot;</span>, (a * b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a / b): %v\n&quot;</span>, (a / b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a %% b): %v\n&quot;</span>, (a % b))</span><br><span class="line"></span><br><span class="line">a++</span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v\n&quot;</span>, a)</span><br><span class="line">b--</span><br><span class="line">fmt.Printf(<span class="string">&quot;b: %v\n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td align="left">!=</td><td align="left">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td align="left">&gt;</td><td align="left">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="left">&gt;=</td><td align="left">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="left">&lt;=</td><td align="left">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">b := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;(a &gt; b): %v\n&quot;</span>, (a &gt; b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a &lt; b): %v\n&quot;</span>, (a &lt; b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a &gt;= b): %v\n&quot;</span>, (a &gt;= b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a &lt;= b): %v\n&quot;</span>, (a &lt;= b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a == b): %v\n&quot;</span>, (a == b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a != b): %v\n&quot;</span>, (a != b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td align="left">||</td><td align="left">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td align="left">!</td><td align="left">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="literal">true</span></span><br><span class="line">b := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;(a &amp;&amp; b): %v\n&quot;</span>, (a &amp;&amp; b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a || b): %v\n&quot;</span>, (a || b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(!a): %v\n&quot;</span>, (!a))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(!b): %v\n&quot;</span>, (!b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td></tr><tr><td align="left">|</td><td align="left">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td></tr><tr><td align="left">^</td><td align="left">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">4</span> <span class="comment">// 二进制 100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %b\n&quot;</span>, a)</span><br><span class="line">b := <span class="number">8</span> <span class="comment">// 二进制 1000</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;b: %b\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;(a &amp; b): %v, %b \n&quot;</span>, (a &amp; b), (a &amp; b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a | b): %v, %b\n&quot;</span>, (a | b), (a | b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a ^ b): %v, %b\n&quot;</span>, (a ^ b), (a ^ b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(a &lt;&lt; 2): %v, %b\n&quot;</span>, (a &lt;&lt; <span class="number">2</span>), (a &lt;&lt; <span class="number">2</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;(b &gt;&gt; 2): %v, %b\n&quot;</span>, (b &gt;&gt; <span class="number">2</span>), (b &gt;&gt; <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td align="left">+=</td><td align="left">相加后再赋值</td></tr><tr><td align="left">-=</td><td align="left">相减后再赋值</td></tr><tr><td align="left">*=</td><td align="left">相乘后再赋值</td></tr><tr><td align="left">/=</td><td align="left">相除后再赋值</td></tr><tr><td align="left">%=</td><td align="left">求余后再赋值</td></tr><tr><td align="left">&lt;&lt;=</td><td align="left">左移后赋值</td></tr><tr><td align="left">&gt;&gt;=</td><td align="left">右移后赋值</td></tr><tr><td align="left">&amp;=</td><td align="left">按位与后赋值</td></tr><tr><td align="left">|=</td><td align="left">按位或后赋值</td></tr><tr><td align="left">^=</td><td align="left">按位异或后赋值</td></tr></tbody></table><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v\n&quot;</span>, a)</span><br><span class="line">a += <span class="number">1</span> <span class="comment">// a = a + 1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v\n&quot;</span>, a)</span><br><span class="line">a -= <span class="number">1</span> <span class="comment">// a = a -1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v\n&quot;</span>, a)</span><br><span class="line">a *= <span class="number">2</span> <span class="comment">// a = a * 2</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v\n&quot;</span>, a)</span><br><span class="line">a /= <span class="number">2</span> <span class="comment">// a = a / 2</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go字符串类型</title>
      <link href="post/go%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/"/>
      <url>post/go%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>一个Go语言字符串是一个任意<strong>字节的常量序列</strong>。[] byte</p><h2 id="go语言字符串字面量"><a href="#go语言字符串字面量" class="headerlink" title="go语言字符串字面量"></a>go语言字符串字面量</h2><p>在Go语言中，字符串字面量使用双引号 <code>&quot;&quot;</code> 或者反引号 <code>&#39;</code> 来创建。双引号用来创建可解析的字符串，支持转义，但不能用来引用多行；反引号用来创建原生的字符串字面量，可能由多行组成，但不支持转义，并且可以包含除了反引号外其他所有字符。双引号创建可解析的字符串应用最广泛，反引号用来创建原生的字符串则多用于书写多行消息，HTML以及正则表达式。</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> str1 <span class="keyword">string</span> = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">var</span> html <span class="keyword">string</span> = </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;hello golang&lt;/title&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fmt.Printf(&quot;str1: %v\n&quot;, str1)</span></span><br><span class="line"><span class="string">fmt.Printf(&quot;html: %v\n&quot;, html)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1: hello world</span><br><span class="line">html: </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;hello golang&lt;/title&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="go语言字符串连接"><a href="#go语言字符串连接" class="headerlink" title="go语言字符串连接"></a>go语言字符串连接</h2><p><strong>使用加号</strong></p><p>虽然Go语言中的字符串是不可变的，但是字符串支持 <code>+</code> 级联操作和<code>+=</code>追加操作，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;tom&quot;</span></span><br><span class="line">age := <span class="string">&quot;20&quot;</span></span><br><span class="line">msg := name + <span class="string">&quot; &quot;</span> + age</span><br><span class="line">fmt.Printf(<span class="string">&quot;msg: %v\n&quot;</span>, msg)</span><br><span class="line">fmt.Println(<span class="string">&quot;-------------&quot;</span>)</span><br><span class="line">msg = <span class="string">&quot;&quot;</span></span><br><span class="line">msg += name</span><br><span class="line">msg += <span class="string">&quot; &quot;</span></span><br><span class="line">msg += age</span><br><span class="line">fmt.Printf(<span class="string">&quot;msg: %v\n&quot;</span>, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>golang 里面的字符串都是不可变的，每次运算都会产生一个新的字符串，所以会产生很多临时的无用的字符串，不仅没有用，还会给 gc 带来额外的负担，所以性能比较差</p></blockquote><p><strong>使用<code>fmt.Sprintf()</code>函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;tom&quot;</span></span><br><span class="line">age := <span class="string">&quot;20&quot;</span></span><br><span class="line">msg := fmt.Sprintf(<span class="string">&quot;%s,%s&quot;</span>, name, age)</span><br><span class="line">fmt.Printf(<span class="string">&quot;msg: %v\n&quot;</span>, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg: tom,<span class="number">20</span></span><br></pre></td></tr></table></figure><blockquote><p>内部使用 <code>[]byte</code> 实现，不像直接运算符这种会产生很多临时的字符串，但是内部的逻辑比较复杂，有很多额外的判断，还用到了 <code>interface</code>，所以性能也不是很好</p></blockquote><p><strong><code>strings.Join()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;tom&quot;</span></span><br><span class="line">age := <span class="string">&quot;20&quot;</span></span><br><span class="line">msg := strings.Join([]<span class="keyword">string</span>&#123;name, age&#125;, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;msg: %v\n&quot;</span>, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg: tom,20</span><br></pre></td></tr></table></figure><blockquote><p>join会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符串填入，在已有一个数组的情况下，这种效率会很高，但是本来没有，去构造这个数据的代价也不小</p></blockquote><p><strong><code>buffer.WriteString()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">buffer.WriteString(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">buffer.WriteString(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">buffer.WriteString(<span class="string">&quot;20&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;buffer.String(): %v\n&quot;</span>, buffer.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个比较理想，可以当成可变字符使用，对内存的增长也有优化，如果能预估字符串的长度，还可以用 <code>buffer.Grow()</code> 接口来设置 capacity</p></blockquote><h2 id="go语言字符串转义字符"><a href="#go语言字符串转义字符" class="headerlink" title="go语言字符串转义字符"></a>go语言字符串转义字符</h2><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th align="left">转义符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>\r</code></td><td align="left">回车符（返回行首）</td></tr><tr><td align="left"><code>\n</code></td><td align="left">换行符（直接跳到下一行的同列位置）</td></tr><tr><td align="left"><code>\t</code></td><td align="left">制表符</td></tr><tr><td align="left"><code>\&#39;</code></td><td align="left">单引号</td></tr><tr><td align="left"><code>\&quot;</code></td><td align="left">双引号</td></tr><tr><td align="left"><code>\\</code></td><td align="left">反斜杠</td></tr></tbody></table><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;hello\tworld\n&quot;</span>)</span><br><span class="line">fmt.Print(<span class="string">&quot;\&quot;c:\\test\\\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helloworld</span><br><span class="line">&quot;c:\test\&quot;</span><br></pre></td></tr></table></figure><h2 id="go语言字符串切片操作"><a href="#go语言字符串切片操作" class="headerlink" title="go语言字符串切片操作"></a>go语言字符串切片操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">n := <span class="number">3</span></span><br><span class="line">m := <span class="number">5</span></span><br><span class="line">fmt.Println(str[n])   <span class="comment">//获取字符串索引位置为n的原始字节</span></span><br><span class="line">fmt.Println(str[n:m]) <span class="comment">//截取得字符串索引位置为 n 到 m-1 的字符串</span></span><br><span class="line">fmt.Println(str[n:])  <span class="comment">//截取得字符串索引位置为 n 到 len(s)-1 的字符串</span></span><br><span class="line">fmt.Println(str[:m])  <span class="comment">//截取得字符串索引位置为 0 到 m-1 的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">108</span><br><span class="line">lo</span><br><span class="line">lo world</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h2 id="go语言字符串常用方法"><a href="#go语言字符串常用方法" class="headerlink" title="go语言字符串常用方法"></a>go语言字符串常用方法</h2><table><thead><tr><th align="left">方法</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">len(str)</td><td align="left">求长度</td></tr><tr><td align="left">+或fmt.Sprintf</td><td align="left">拼接字符串</td></tr><tr><td align="left">strings.Split</td><td align="left">分割</td></tr><tr><td align="left">strings.contains</td><td align="left">判断是否包含</td></tr><tr><td align="left">strings.HasPrefix,strings.HasSuffix</td><td align="left">前缀/后缀判断</td></tr><tr><td align="left">strings.Index(),strings.LastIndex()</td><td align="left">子串出现的位置</td></tr><tr><td align="left">strings.Join(a[]string, sep string)</td><td align="left">join操作</td></tr></tbody></table><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;hello world！&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;len(s): %v\n&quot;</span>, <span class="built_in">len</span>(s))</span><br><span class="line">fmt.Printf(<span class="string">&quot;strings.Split(s, \&quot;\&quot;): %v\n&quot;</span>, strings.Split(s, <span class="string">&quot; &quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;strings.Contains(s, \&quot;hello\&quot;): %v\n&quot;</span>, strings.Contains(s, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;strings.HasPrefix(s, \&quot;hello\&quot;): %v\n&quot;</span>, strings.HasPrefix(s, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;strings.HasSuffix(s, \&quot;world！\&quot;): %v\n&quot;</span>, strings.HasSuffix(s, <span class="string">&quot;world！&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;strings.Index(s, \&quot;l\&quot;): %v\n&quot;</span>, strings.Index(s, <span class="string">&quot;l&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;strings.LastIndex(s, \&quot;l\&quot;): %v\n&quot;</span>, strings.LastIndex(s, <span class="string">&quot;l&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">len(s): 14</span><br><span class="line">strings.Split(s, &quot;&quot;): [hello world！]</span><br><span class="line">strings.Contains(s, &quot;hello&quot;): true</span><br><span class="line">strings.HasPrefix(s, &quot;hello&quot;): true</span><br><span class="line">strings.HasSuffix(s, &quot;world！&quot;): true</span><br><span class="line">strings.Index(s, &quot;l&quot;): 2</span><br><span class="line">strings.LastIndex(s, &quot;l&quot;): 9</span><br></pre></td></tr></table></figure><h2 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h2><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;华&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v,%c\n&quot;</span>, a, a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b: %v,%c\n&quot;</span>, b, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a: 21326,华</span><br><span class="line">b: 97,a</span><br></pre></td></tr></table></figure><p>Go 语言的字符有以下两种：</p><ol><li><code>uint8</code>类型，或者叫 byte 型，代表了<code>ASCII码</code>的一个字符。</li><li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li></ol><p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p><p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p>]]></content>
      
      
      <categories>
          
          <category> go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go数字类型</title>
      <link href="post/go%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/"/>
      <url>post/go%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。</p><p>Go 也有基于架构的类型，例如：<code>int</code>、<code>uint</code> 和 <code>uintptr</code>。</p><p>这些类型的长度都是根据运行程序所在的操作系统类型所决定的：</p><ul><li><code>int</code> 和 <code>uint</code> 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。</li><li><code>uintptr</code> 的长度被设定为足够存放一个指针即可。</li></ul><p>Go 语言中没有 <code>float</code> 类型。（Go语言中只有 <code>float32</code> 和 <code>float64</code>）没有double类型。</p><p>与操作系统架构无关的类型都有固定的大小，并在类型的名称中就可以看出来：</p><p>整数：</p><ul><li>int8（-128 -&gt; 127）</li><li>int16（-32768 -&gt; 32767）</li><li>int32（-2,147,483,648 -&gt; 2,147,483,647）</li><li>int64（-9,223,372,036,854,775,808 -&gt; 9,223,372,036,854,775,807）</li></ul><p>无符号整数：</p><ul><li>uint8（0 -&gt; 255）</li><li>uint16（0 -&gt; 65,535）</li><li>uint32（0 -&gt; 4,294,967,295）</li><li>uint64（0 -&gt; 18,446,744,073,709,551,615）</li></ul><p>浮点型（IEEE-754 标准）：</p><ul><li>float32（+- 1e-45 -&gt; +- 3.4 * 1e38）</li><li>float64（+- 5 * 1e-324 -&gt; 107 * 1e308）</li></ul><p>int 型是计算最快的一种类型。</p><p>整型的零值为 0，浮点型的零值为 0.0。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面实例演示了，各个数字类型的长度和取值范围</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i8 <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">var</span> i16 <span class="keyword">int16</span></span><br><span class="line"><span class="keyword">var</span> i32 <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">var</span> i64 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> ui8 <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">var</span> ui16 <span class="keyword">uint16</span></span><br><span class="line"><span class="keyword">var</span> ui32 <span class="keyword">uint32</span></span><br><span class="line"><span class="keyword">var</span> ui64 <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, i8, unsafe.Sizeof(i8), math.MinInt8, math.MaxInt8)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, i16, unsafe.Sizeof(i16), math.MinInt16, math.MaxInt16)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, i32, unsafe.Sizeof(i32), math.MinInt32, math.MaxInt32)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, i64, unsafe.Sizeof(i64), math.MinInt64, math.MaxInt64)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, ui8, unsafe.Sizeof(ui8), <span class="number">0</span>, math.MaxUint8)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, ui16, unsafe.Sizeof(ui16), <span class="number">0</span>, math.MaxUint16)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, ui32, unsafe.Sizeof(ui32), <span class="number">0</span>, math.MaxUint32)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, ui64, unsafe.Sizeof(ui64), <span class="number">0</span>, <span class="keyword">uint64</span>(math.MaxUint64))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f32 <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> f64 <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, f32, unsafe.Sizeof(f32), -math.MaxFloat32, math.MaxFloat32)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, f64, unsafe.Sizeof(f64), -math.MaxFloat64, math.MaxFloat64)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ui <span class="keyword">uint</span></span><br><span class="line">ui = <span class="keyword">uint</span>(math.MaxUint64) <span class="comment">//再+1会导致overflows错误</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, ui, unsafe.Sizeof(ui), <span class="number">0</span>, ui)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imax, imin <span class="keyword">int</span></span><br><span class="line">imax = <span class="keyword">int</span>(math.MaxInt64) <span class="comment">//再+1会导致overflows错误</span></span><br><span class="line">imin = <span class="keyword">int</span>(math.MinInt64) <span class="comment">//再-1会导致overflows错误</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %dB %v~%v\n&quot;</span>, imax, unsafe.Sizeof(imax), imin, imax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int8 1B -128~127</span><br><span class="line">int16 2B -32768~32767</span><br><span class="line">int32 4B -2147483648~2147483647</span><br><span class="line">int64 8B -9223372036854775808~9223372036854775807</span><br><span class="line">uint8 1B 0~255</span><br><span class="line">uint16 2B 0~65535</span><br><span class="line">uint32 4B 0~4294967295</span><br><span class="line">uint64 8B 0~18446744073709551615</span><br><span class="line">float32 4B -3.4028234663852886e+38~3.4028234663852886e+38</span><br><span class="line">float64 8B -1.7976931348623157e+308~1.7976931348623157e+308</span><br><span class="line">uint 8B 0~18446744073709551615</span><br><span class="line">int 8B -9223372036854775808~9223372036854775807</span><br></pre></td></tr></table></figure><h2 id="以二进制、八进制或十六进制浮点数的格式定义数字"><a href="#以二进制、八进制或十六进制浮点数的格式定义数字" class="headerlink" title="以二进制、八进制或十六进制浮点数的格式定义数字"></a>以二进制、八进制或十六进制浮点数的格式定义数字</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d \n&quot;</span>, a) <span class="comment">// 10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b \n&quot;</span>, a) <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制  以0开头</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%o \n&quot;</span>, b) <span class="comment">// 77</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制  以0x开头</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x \n&quot;</span>, c) <span class="comment">// ff</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X \n&quot;</span>, c) <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 </span><br><span class="line">1010 </span><br><span class="line">77 </span><br><span class="line">ff </span><br><span class="line">FF </span><br></pre></td></tr></table></figure><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex64和complex128</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure><p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p>]]></content>
      
      
      <categories>
          
          <category> go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言数据类型</title>
      <link href="post/go%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>post/go%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="go语言数据类型"><a href="#go语言数据类型" class="headerlink" title="go语言数据类型"></a>go语言数据类型</h1><p>在 Go 编程语言中，数据类型用于声明函数和变量。</p><p>数据类型的出现是为了把数据分成所需<strong>内存大小</strong>不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p><p>Go 语言按类别有以下几种数据类型：</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td></tr><tr><td align="left">2</td><td align="left"><strong>数字类型</strong> 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td></tr><tr><td align="left">3</td><td align="left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td></tr><tr><td align="left">4</td><td align="left"><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型</td></tr></tbody></table><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td></tr><tr><td align="left">2</td><td align="left"><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td></tr><tr><td align="left">3</td><td align="left"><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td></tr><tr><td align="left">4</td><td align="left"><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td align="left">5</td><td align="left"><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td></tr><tr><td align="left">6</td><td align="left"><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td align="left">7</td><td align="left"><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="left">8</td><td align="left"><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>float32</strong> IEEE-754 32位浮点型数</td></tr><tr><td align="left">2</td><td align="left"><strong>float64</strong> IEEE-754 64位浮点型数</td></tr><tr><td align="left">3</td><td align="left"><strong>complex64</strong> 32 位实数和虚数</td></tr><tr><td align="left">4</td><td align="left"><strong>complex128</strong> 64 位实数和虚数</td></tr></tbody></table><h2 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h2><p>以下列出了其他更多的数字类型：</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>byte</strong> 类似 uint8</td></tr><tr><td align="left">2</td><td align="left"><strong>rune</strong> 类似 int32</td></tr><tr><td align="left">3</td><td align="left"><strong>uint</strong> 32 或 64 位</td></tr><tr><td align="left">4</td><td align="left"><strong>int</strong> 与 uint 一样大小</td></tr><tr><td align="left">5</td><td align="left"><strong>uintptr</strong> 无符号整型，用于存放一个指针</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go变量</title>
      <link href="post/go%E5%8F%98%E9%87%8F/"/>
      <url>post/go%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>变量是计算机语言中能<strong>储存</strong>计算结果或能表示值的抽象概念。不同的变量保存的<strong>数据类型</strong>可能会不一样。</p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后<strong>必须使用</strong>。</p><p><strong>声明变量的语法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p><code>var</code>：声明变量关键字</p><p><code>identifier</code>：变量名称</p><p><code>type</code>：变量类型</p><p><strong>例如</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>使用一个<code>var</code>关键字，把一些变量写在一个括号<code>()</code>里</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">ok   <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为空字符串<code>“”</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p><p><strong>变量初始化语法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure><p><strong>例如</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">&quot;老郭&quot;</span></span><br><span class="line"><span class="keyword">var</span> site <span class="keyword">string</span> = <span class="string">&quot;www.duoke360.com&quot;</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类型推导</strong></p><p>我们在声明变量时，可以根据初始化值进行类型推导，从而省略类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;老郭&quot;</span></span><br><span class="line"><span class="keyword">var</span> site = <span class="string">&quot;www.duoke360.com&quot;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化多个变量</strong></p><p>可以一次初始化多个变量，中间用逗号分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name, site, age = <span class="string">&quot;老郭&quot;</span>, <span class="string">&quot;www.duoke360.com&quot;</span>, <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h2><p>在<strong>函数内部</strong>，可以使用 <code>:=</code>运算符对变量进行声明和初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;老郭&quot;</span></span><br><span class="line">site := <span class="string">&quot;www.duoke360.com&quot;</span></span><br><span class="line">age := <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这种方法只适合在函数内部，函数外面不能使用。</p></blockquote><h2 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h2><p>如果我们接收到多个变量，有一些变量使用不到，可以使用下划线<code>_</code>表示变量名称，这种变量叫做匿名变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNameAndAge</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;老郭&quot;</span>, <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name, _ := getNameAndAge()</span><br><span class="line">fmt.Printf(<span class="string">&quot;name: %v\n&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go常量</title>
      <link href="post/go%E5%B8%B8%E9%87%8F/"/>
      <url>post/go%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>常量，就是在程序<strong>编译阶段</strong>就确定下来的值，而程序在<strong>运行时</strong>则无法改变该值。在Go程序中，常量可以是数值类型（包括整型、浮点型和复数类型）、布尔类型、字符串类型等。</p><h2 id="定义常量的语法"><a href="#定义常量的语法" class="headerlink" title="定义常量的语法"></a>定义常量的语法</h2><p>定义一个常量使用<code>const</code>关键字，语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> constantName [<span class="keyword">type</span>]= value</span><br></pre></td></tr></table></figure><p><code>const</code>：定义常量关键字</p><p><code>constantName</code>：常量名称</p><p><code>type</code>：常量类型</p><p><code>value</code>：常量的值</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> PI <span class="keyword">float64</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">const</span> PI2 = <span class="number">3.1415</span> <span class="comment">// 可以省略类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">width  = <span class="number">100</span></span><br><span class="line">height = <span class="number">200</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i, j = <span class="number">1</span>, <span class="number">2</span> <span class="comment">// 多重赋值</span></span><br><span class="line"><span class="keyword">const</span> a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;foo&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>const</code>同时声明多个常量时，如果省略了值则表示和上面一行的值相同</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a1 = <span class="number">100</span></span><br><span class="line">a2</span><br><span class="line">a3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;a1: %v\n&quot;</span>, a1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;a2: %v\n&quot;</span>, a2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;a3: %v\n&quot;</span>, a3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1: 100</span><br><span class="line">a2: 100</span><br><span class="line">a3: 100</span><br></pre></td></tr></table></figure><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a><code>iota</code></h2><p>iota 比较特殊，可以被认为是一个可被编译器修改的常量，它默认开始值是<code>0</code>，每调用一次加<code>1</code>。遇到 <code>const</code> 关键字时被重置为 <code>0</code>。</p><p><strong>实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a1 = <span class="literal">iota</span></span><br><span class="line">a2 = <span class="literal">iota</span></span><br><span class="line">a3 = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;a1: %v\n&quot;</span>, a1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;a2: %v\n&quot;</span>, a2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;a3: %v\n&quot;</span>, a3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1: 0</span><br><span class="line">a2: 1</span><br><span class="line">a3: 2</span><br></pre></td></tr></table></figure><p><strong>使用<code>_</code>跳过某些值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a1 = <span class="literal">iota</span></span><br><span class="line">_</span><br><span class="line">a2 = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;a1: %v\n&quot;</span>, a1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;a2: %v\n&quot;</span>, a2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1: 0</span><br><span class="line">a2: 2</span><br></pre></td></tr></table></figure><p><strong><code>iota</code>声明中间插队</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a1 = <span class="literal">iota</span></span><br><span class="line">a2 = <span class="number">100</span></span><br><span class="line">a3 = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;a1: %v\n&quot;</span>, a1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;a2: %v\n&quot;</span>, a2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;a3: %v\n&quot;</span>, a3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1: <span class="number">0</span></span><br><span class="line">a2: <span class="number">100</span></span><br><span class="line">a3: <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go布尔类型</title>
      <link href="post/go%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/"/>
      <url>post/go%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>go语言中的布尔类型有两个常量值：<code>true</code>和<code>false</code>。布尔类型经常用在<strong>条件判断</strong>语句，或者<strong>循环语句</strong>。也可以用在<strong>逻辑表达式</strong>中。</p><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b1 <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> b2 <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> b3 = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> b4 = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">b5 := <span class="literal">true</span></span><br><span class="line">b6 := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;b1: %v\n&quot;</span>, b1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b2: %v\n&quot;</span>, b2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b3: %v\n&quot;</span>, b3)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b4: %v\n&quot;</span>, b4)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b5: %v\n&quot;</span>, b5)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b6: %v\n&quot;</span>, b6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b1: true</span><br><span class="line">b2: false</span><br><span class="line">b3: true</span><br><span class="line">b4: false</span><br><span class="line">b5: true</span><br><span class="line">b6: false</span><br></pre></td></tr></table></figure><h2 id="用在条件判断中"><a href="#用在条件判断中" class="headerlink" title="用在条件判断中"></a>用在条件判断中</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">age := <span class="number">18</span></span><br><span class="line">ok := age &gt;= <span class="number">18</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你已经成年&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你还未成年&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你已经成年</span><br></pre></td></tr></table></figure><h2 id="用在循环语句中"><a href="#用在循环语句中" class="headerlink" title="用在循环语句中"></a>用在循环语句中</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">count := <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;i: %v\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用在逻辑表达式中"><a href="#用在逻辑表达式中" class="headerlink" title="用在逻辑表达式中"></a>用在逻辑表达式中</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">age := <span class="number">18</span></span><br><span class="line">gender := <span class="string">&quot;男&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span> &amp;&amp; gender == <span class="string">&quot;男&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;你是成年男子&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：不能使用<code>0</code>和非<code>0</code>表示真假</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i &#123;</span><br><span class="line"><span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go标识符、关键字、命名规则</title>
      <link href="post/go%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
      <url>post/go%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符的英文是<code>identifier</code>，通俗的讲，就是给变量、常量、函数、方法、结构体、数组、切片、接口起名字。</p><h3 id="标识符的组成"><a href="#标识符的组成" class="headerlink" title="标识符的组成"></a>标识符的组成</h3><ol><li>标识符由数字、字母和下划线(<code>_</code>)组成。123 abc _</li><li>只能以字母和下划线(<code>_</code>)<strong>开头</strong>。abc123 _sysVar 123abc</li><li>标识符区分大小写。 name Name NAME</li></ol><h3 id="举例说明标识符的命名"><a href="#举例说明标识符的命名" class="headerlink" title="举例说明标识符的命名"></a>举例说明标识符的命名</h3><p><strong>正确的命名</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> _sys <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误的标识符</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> <span class="number">1</span>name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> &amp;age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> !email</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="go语言关键字"><a href="#go语言关键字" class="headerlink" title="go语言关键字"></a>go语言关键字</h2><p>go语言提供了25个关键字，如下所示。</p><table><thead><tr><th align="left">break</th><th align="left">default</th><th align="left">func</th><th align="left">interface</th><th align="left">select</th></tr></thead><tbody><tr><td align="left">case</td><td align="left">defer</td><td align="left">go</td><td align="left">map</td><td align="left">struct</td></tr><tr><td align="left">chan</td><td align="left">else</td><td align="left">goto</td><td align="left">package</td><td align="left">switch</td></tr><tr><td align="left">const</td><td align="left">fallthrough</td><td align="left">if</td><td align="left">range</td><td align="left">type</td></tr><tr><td align="left">continue</td><td align="left">for</td><td align="left">import</td><td align="left">return</td><td align="left">var</td></tr></tbody></table><p>除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符，其中包含了基本类型的名称和一些基本的内置函数，见下表：</p><table><thead><tr><th align="left">append</th><th align="left">bool</th><th align="left">byte</th><th align="left">cap</th><th align="left">close</th><th align="left">complex</th><th align="left">complex64</th><th align="left">complex128</th><th align="left">uint16</th></tr></thead><tbody><tr><td align="left">copy</td><td align="left">false</td><td align="left">float32</td><td align="left">float64</td><td align="left">imag</td><td align="left">int</td><td align="left">int8</td><td align="left">int16</td><td align="left">uint32</td></tr><tr><td align="left">int32</td><td align="left">int64</td><td align="left">iota</td><td align="left">len</td><td align="left">make</td><td align="left">new</td><td align="left">nil</td><td align="left">panic</td><td align="left">uint64</td></tr><tr><td align="left">print</td><td align="left">println</td><td align="left">real</td><td align="left">recover</td><td align="left">string</td><td align="left">true</td><td align="left">uint</td><td align="left">uint8</td><td align="left">uintptr</td></tr></tbody></table><h2 id="go语言命名规范"><a href="#go语言命名规范" class="headerlink" title="go语言命名规范"></a>go语言命名规范</h2><h3 id="Go是一门区分大小写的语言"><a href="#Go是一门区分大小写的语言" class="headerlink" title="Go是一门区分大小写的语言"></a>Go是一门区分大小写的语言</h3><p>命名规则涉及变量、常量、全局函数、结构、接口、方法等的命名。 Go语言从语法层面进行了以下限定：任何需要对外暴露的名字必须以大写字母开头，不需要对外暴露的则应该以小写字母开头。</p><p>当命名（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：<code>GetUserName</code>，那么使用这种形式的标识符的对象就<strong>可以被外部包的代码所使用</strong>（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 <code>public</code>）； <strong>命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的</strong>（像面向对象语言中的 <code>private</code> ）</p><h3 id="包名称"><a href="#包名称" class="headerlink" title="包名称"></a>包名称</h3><p>保持<code>package</code>的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为<strong>小写</strong>单词，不要使用下划线或者混合大小写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dao</span><br><span class="line"><span class="keyword">package</span> service</span><br></pre></td></tr></table></figure><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>尽量采取有意义的文件名，简短，有意义，应该为<strong>小写</strong>单词，使用<strong>下划线</strong>分隔各个单词。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customer_dao.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><h3 id="结构体命名"><a href="#结构体命名" class="headerlink" title="结构体命名"></a>结构体命名</h3><p>采用<strong>驼峰命名法</strong>，首字母根据访问控制大写或者小写</p><p><code>struct</code> 申明和初始化格式采用多行，例如下面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomerOrder <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> </span><br><span class="line">    Address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">order := CustomerOrder&#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;北京海淀&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名"></a>接口命名</h3><p>命名规则基本和上面的结构体类型</p><p>单个函数的结构名以 <strong>“er”</strong> 作为后缀，例如 <code>Reader</code> , <code>Writer</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">     Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>和结构体类似，变量名称一般遵循<strong>驼峰法</strong>，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则：</p><p>如果变量为私有，且特有名词为首个单词，则使用小写，如 appService 若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isExist <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> hasConflict <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> canManage <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> allowGitHook <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><p>常量均需使用全部<strong>大写</strong>字母组成，并使用<strong>下划线分词</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> APP_URL = <span class="string">&quot;https://www.duoke360.com&quot;</span></span><br></pre></td></tr></table></figure><p>如果是枚举类型的常量，需要先创建相应类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    HTTP  Scheme = <span class="string">&quot;http&quot;</span></span><br><span class="line">    HTTPS Scheme = <span class="string">&quot;https&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>错误处理的原则就是不能丢弃任何有返回err的调用，不要使用 _ 丢弃，必须全部处理。接收到错误，要么返回err，或者使用log记录下来尽早return：一旦有错误发生，马上返回，尽量不要使用panic，除非你知道你在做什么，错误描述如果是英文必须为小写，不需要标点结尾，采用独立的错误流进行处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 正常代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 或者继续</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常代码</span></span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试文件名命名规范为 <code>example_test.go</code> 测试用例的函数名称必须以 <code>Test</code> 开头，例如：<code>TestExample</code> 每个重要的函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试 。</p>]]></content>
      
      
      <categories>
          
          <category> go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言开发环境搭建</title>
      <link href="post/go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>post/go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="windows平台"><a href="#windows平台" class="headerlink" title="windows平台"></a>windows平台</h2><h3 id="下载安装并配置环境变量"><a href="#下载安装并配置环境变量" class="headerlink" title="下载安装并配置环境变量"></a>下载安装并配置环境变量</h3><p>下载地址：<code>https://golang.google.cn/dl/</code>，这里提供了不同平台的go版本，根据自己的平台选择下载。</p><p>这里注意，安装路径选择一个比较好找的路径，例如：<code>c:/go</code>，其他安装都选择”下一步“即可。</p><p>安装完成后，把<code>C:\go\bin</code>目录添加到环境变量，这里就可以使用go了，在命令行输入 <code>go version</code>查看版本，输出结果如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version go1.16.6 windows/amd64</span><br></pre></td></tr></table></figure><h3 id="配置go环境"><a href="#配置go环境" class="headerlink" title="配置go环境"></a>配置go环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on </span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct</span><br></pre></td></tr></table></figure><blockquote><p>使用使用go mod 管理库，需要科学上网</p></blockquote><h3 id="安装配置git"><a href="#安装配置git" class="headerlink" title="安装配置git"></a>安装配置git</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.git-scm.com/download/</span><br></pre></td></tr></table></figure><p>配置环境变量，命令行输入git测试</p><h2 id="goroot和gopath"><a href="#goroot和gopath" class="headerlink" title="goroot和gopath"></a>goroot和gopath</h2><p>goroot就是go安装的根目录，gopath就是go项目所在的路径，高版本go项目已经不再依赖gopath来管理项目，使用go mod来管理项目。</p><h2 id="Linux平台"><a href="#Linux平台" class="headerlink" title="Linux平台"></a>Linux平台</h2><p>如果不是要在Linux平台敲go代码就不需要在Linux平台安装Go，我们开发机上写好的go代码只需要跨平台编译（详见文章末尾的跨平台编译）好之后就可以拷贝到Linux服务器上运行了，这也是go程序跨平台易部署的优势。</p><p>我们在版本选择页面选择并下载好<code>go1.14.1.linux-amd64.tar.gz</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>将下载好的文件解压到<code>/usr/local</code>目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf go1.14.1.linux-amd64.tar.gz -C /usr/<span class="built_in">local</span>  <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><p>如果提示没有权限，加上<code>sudo</code>以root用户的身份再运行。执行完就可以在<code>/usr/local/</code>下看到<code>go</code>目录了。</p><p>配置环境变量： Linux下有两个文件可以配置环境变量，其中<code>/etc/profile</code>是对所有用户生效的；<code>$HOME/.profile</code>是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin</span><br></pre></td></tr></table></figure><p>修改<code>/etc/profile</code>后要重启生效，修改<code>$HOME/.profile</code>后使用source命令加载<code>$HOME/.profile</code>文件即可生效。 检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ go version</span><br><span class="line">go version go1.16.6 linux/amd64</span><br></pre></td></tr></table></figure><h2 id="Mac平台"><a href="#Mac平台" class="headerlink" title="Mac平台"></a>Mac平台</h2><p>下载可执行文件版，直接点击<strong>下一步</strong>安装即可，默认会将go安装到<code>/usr/local/go</code>目录下。</p><p>上一步安装过程执行完毕后，可以打开终端窗口，输入<code>go version</code>命令，查看安装的Go版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version go1.16.6 darwin/amd64</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈二进制——定点数与浮点数</title>
      <link href="post/%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
      <url>post/%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="0-概要"><a href="#0-概要" class="headerlink" title="0. 概要"></a>0. 概要</h2><p>二进制系列文章已经写到第五篇了，不出意外的话，这应该会是二进制系列的最后一篇。我们先来罗列一下前四篇：</p><ul><li><a href="https://segmentfault.com/a/1190000023833719">谈谈二进制（一）</a></li><li><a href="https://segmentfault.com/a/1190000023880414">谈谈二进制（二）——四则运算</a></li><li><a href="https://segmentfault.com/a/1190000023918713">谈谈二进制（三）——位运算及其应用</a></li><li><a href="https://segmentfault.com/a/1190000024426172">谈谈二进制（四）——原码、补码、反码、移码</a></li></ul><p>其中，在上一篇里，我们认识了四种机器数，它们各司其职，但总的来说，有一个特点，就是在对计算机里的正负号做文章。今天介绍的定点数和浮点数，则是对小数点做文章。</p><p>上一篇文章的开头，我们说到，计算机中只能存储数字，因此需要用<code>0</code>和<code>1</code>来表示正负，同样的，计算机中的小数点，也要用特殊的形式来表示，共有两种，即本文所要讲的<strong>定点数</strong>和<strong>浮点数</strong>。</p><h2 id="1-定点数"><a href="#1-定点数" class="headerlink" title="1. 定点数"></a>1. 定点数</h2><p>所谓定点数，就是指<strong>小数点的位置是固定的，约定小数点在某一个位置上</strong>，因此，机器在处理定点数时，并不存储它的小数点。使用定点数的机器，被称为定点机。当然了，现代计算机一般只要有运算部件，都会提供对定点数运算的支持。</p><p>虽然理论上，定点数的小数点的位置可以任意规定，但通常只会用定点数表示<strong>纯小数</strong>或<strong>整数</strong>，当表示纯小数时，小数约定在上一篇文章里反复提及的<strong>符号位</strong>和数值部分之间，同理，表示整数时，则在数值部分的后面。下图展示了定点小数和定点整数的结构：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5365151ca99439d8acb18a2502dd6bc~tplv-k3u1fbpfcp-zoom-1.image" alt="定点数"></p><p>为什么通常只用定点数表示纯小数或整数呢？因为上面我们提到的，定点机在存储定点数时，并不存储小数点，因此我们的数字在定点机中是一串看上去像整数的东西，如果我们存入了非纯小数或整数，它们的计算结果就会很容易出现问题，譬如<code>1.23</code>和<code>12.3</code>，在定点机中它们没有小数点，都是<code>123</code>，那么它们在做加、减、除后的结果都是不对的，即便是乘法，其结果也需要我们自己再去算它的小数点位。</p><p>而纯小数或整数处理起来就方便多了，譬如整数，它的加、减、乘三种运算结果都是整数，而除法如果遇到除不尽的情况，一般也会取余处理。纯小数同理，但比整数稍微麻烦一点，主要是加法和除法，会有益处的风险，此时一些定点机可能会直接抛出异常。</p><p>定点机由于它的特性，在硬件层面设计会更简单。</p><h2 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2. 浮点数"></a>2. 浮点数</h2><p>浮点数是大家比较熟悉的一个词汇，也就是我们平时编程语言中的<code>float</code>和<code>double</code>。前面定点数由于本身性质的限制，难以处理复杂的非纯小数和整数，此时就需要浮点数来处理了。</p><p>所谓浮点，与定点相对，就是小数点是浮动的，不固定的，它的形式有点像我们熟悉的科学计数法，譬如<code>12.34</code>这个数，可以写成下面几种形式：</p><p>12.34 = 1.234\times10^1 = 0.1234\times10^2 = 1234\times10^{-2}12.34=1.234×101=0.1234×102=1234×10−2</p><p>后面这三种形式都能表示<code>12.34</code>这个数字，尽管它们的小数点位置各不相同，但因为后面乘了不同的<code>10</code>的幂次方，因此最终结果一致。</p><p>浮点数的标准形式如下：</p><p>N = M \times B^E<em>N</em>=<em>M</em>×<em>B**E</em></p><p>其中，<code>M</code>为尾数，<code>B</code>为基数，<code>E</code>为阶码，这个式子和各个字母的含义已经非常清晰了，直接对照上面<code>12.34</code>这个例子看就好。当然了，<code>12.34</code>这个例子举的是我们最熟悉的十进制，我们计算机中使用的当然是二进制，而根据前面几篇（应该是第一篇）二进制系列文章我们知道，二进制各个位数之间相差<code>2</code>倍，因此，如果要用浮点式表示一个二进制数时，这里的基数<code>B</code>就是<code>2</code>了，譬如：</p><p>101.11 = 10.111\times2^1 = 1.0111\times2^2 = 10111\times2^{-2} = 0.10111\times2^3 = 0.010111\times2^4101.11=10.111×21=1.0111×22=10111×2−2=0.10111×23=0.010111×24</p><p>非常好理解。有些地方会把阶码<code>E</code>也表示成二进制的形式，譬如<code>2</code>次幂使用<code>10</code>次幂来表示，这个大家根据实际情况辨别即可，核心都是不变的。</p><p>通常来说，计算机为了提高数据精度和便于浮点数之间的比较，规定浮点数的尾数<code>M</code>用纯小数表示，即上面二进制<code>101.11</code>的最后两种表示形式。同时，将尾数最高位为<code>1</code>的浮点数称为规格化数，对于<code>101.11</code>来说，倒数第二种形式$0.10111\times2^3$就是它的规格化表示。</p><h2 id="2-1-计算机中的浮点数"><a href="#2-1-计算机中的浮点数" class="headerlink" title="2.1 计算机中的浮点数"></a>2.1 计算机中的浮点数</h2><p>上面介绍的是浮点数的基本定义，但这是给人类看的，计算机中肯定有其特殊的存储形式，我们直接来看现代计算机的通用国际标准<code>IEEE 754</code>，我们现在在用的计算机基本上都是基于这个标准来存储浮点数的，包括我们熟悉的<strong>短浮点数（<code>float</code>）</strong>、<strong>长浮点数（<code>double</code>）</strong>，它们俩的表示方法相同，区别仅仅是阶码<code>E</code>和位数<code>M</code>的位数不同：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a46e087a5cb4b3894021df267dc2f20~tplv-k3u1fbpfcp-zoom-1.image" alt="IEEE754标准"></p><p>上图就是浮点数<code>IEEE 754</code>的标准形式了，我们逐个来看：</p><ul><li>第一个位置是数符，就是表整个数字正负的符号，即<code>0</code>和<code>1</code>；</li><li>接着是阶码<code>E</code>，这里的阶码也有正负，并且不用真值来表示，通常会用阶码的真值加上一个偏移量，作为实际存储的偏移值。如在短浮点数<code>float</code>中，这个偏移量为<code>127</code>，即$2^7-1=1111111_{(2)}$。这样做的目的和上一篇文章中我们讲到的移码类似 ，主要是为了比较时更方便。加上偏移量之后，使得原本带符号的阶码<code>E</code>变成了一个无符号数，或者直接理解为去除了符号位对阶码大小的影响，等会儿的例子中我们再来看它的具体表示；</li><li>最后是尾数，这个部分为了提高精度，规定将原数尾数转化为<code>1.xxxx</code>的形式，以<code>1</code>为默认最高位，然后储存的时候并不储存最高位<code>1</code>，视其为隐藏的，只存储小数点后面的部分，这样可以使尾数表示的精度达到最高，即存储位数最多，比实际位数多一位。</li></ul><p>在讲例子之前，我们再来看一下<strong>短浮点数（<code>float</code>）</strong>和<strong>长浮点数（<code>double</code>）</strong>在<code>IEEE 754</code>中各个部分的位数：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35284e2ea7b340dea13f4b48a372caf5~tplv-k3u1fbpfcp-zoom-1.image" alt="IEEE754中float和double的位数"></p><p>这就是我们在初学编程语言时，教科书上告诉我们的<code>float</code>是<code>32</code>位，精度没有<code>64</code>位的<code>double</code>高的原因了。尾数代表了精度，而阶码代表了表示范围。</p><p>然后我们来看一个例子，以<code>float</code>为例，我们取一个十进制数<code>13.625</code>，它对应的二进制是<code>1101.101</code>，我们来看一下它按照<code>IEEE 754</code>标准转换成<code>float</code>的过程和结果。</p><p>首先，将原数写成标准规定的格式，以<code>1</code>为最高整数位：$1101.101 = 1.101101\times2^3$。</p><p>然后把整数位<code>1</code>舍弃（隐藏），得到一个纯小数尾数<code>101101</code>。因为<code>float</code>的尾数全长为<code>23</code>位，同时这个尾数是纯小数，因此在当前尾数的后面用<code>0</code>补全，得到真正的尾数<code>1011 0100 0000 0000 0000 000</code>共<code>23</code>位。</p><p>接下来是阶码<code>3</code>，先转成二进制<code>11</code>，这是它的真值，再用真值加上$2^7-1$，即<code>0111 1111 + 0000 0011 = 1000 0010</code>，得到的就是一个<code>8</code>位阶码实际存储值。上面我们说过，这里与偏移量相加，是为了便于比较，而相加后的结果可以看做是一个无符号的二进制数，因此它最高位的<code>1</code>并不指代它的正负。如果我们用一个负数的阶码与偏移量相加，就会得到一个最高位<code>0</code>的结果，这样就能直接比较出阶码的大小了。</p><p>得到阶码和尾数后，只需要在最高位上添加数符就好了。因为原数是正数，因此数符<code>S</code>为<code>0</code>，最终得到的<code>IEEE 754</code>标准的<code>float</code>浮点数为：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67fd319e5fdb4b6ba8ed40a162d98930~tplv-k3u1fbpfcp-zoom-1.image" alt="float数"></p><p><code>double</code>太长就不写了，原理是一样的，大家如果有兴趣可以自己试着算一算。</p><blockquote><p>转载自：<a href="https://segmentfault.com/a/1190000024485146">https://segmentfault.com/a/1190000024485146</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 浮点数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浮点数 </tag>
            
            <tag> float </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言常用命令</title>
      <link href="post/go%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>post/go%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="查看可用命令"><a href="#查看可用命令" class="headerlink" title="查看可用命令"></a>查看可用命令</h2><p>直接在终端中输入 <code>go help</code> 即可显示所有的 go 命令以及相应命令功能简介，主要有下面这些:</p><ul><li>build: 编译包和依赖</li><li>clean: 移除对象文件</li><li>doc: 显示包或者符号的文档</li><li>env: 打印go的环境信息</li><li>bug: 启动错误报告</li><li>fix: 运行go tool fix</li><li>fmt: 运行gofmt进行格式化</li><li>generate: 从processing source生成go文件</li><li>get: 下载并安装包和依赖</li><li>install: 编译并安装包和依赖</li><li>list: 列出包</li><li>run: 编译并运行go程序</li><li>test: 运行测试</li><li>tool: 运行go提供的工具</li><li>version: 显示go的版本</li><li>vet: 运行go tool vet</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://golang.org/doc/cmd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unicode与UTF-8</title>
      <link href="post/Unicode%E4%B8%8EUTF-8/"/>
      <url>post/Unicode%E4%B8%8EUTF-8/</url>
      
        <content type="html"><![CDATA[<p>想必做过爬虫的同学肯定被编码问题困扰过，有 UTF-8、GBK、<a href="https://so.csdn.net/so/search?q=Unicode&spm=1001.2101.3001.7020">Unicode</a> 等等编码方式，但你真的了解其中的原理吗？下面我们就来了解一下 Unicode 和 UTF-8 编码到底有什么关系。</p><p>要弄清 Unicode 与 UTF-8 的关系，我们还得从他们的来源说起，下来我们从刚开始的编码说起，直到 Unicode 的出现，我们就会感觉到他们之间的关系 </p><p><strong>ASCII码</strong></p><p>我们都知道，在计算机的世界里，信息的表示方式只有 0 和 1,但是我们人类信息表示的方式却与之大不相同，很多时候是用语言文字、图像、声音等传递信息的。</p><p>那么我们怎样将其转化为二进制存储到计算机中，这个过程我们称之为编码。更广义地讲就是把信息从一种形式转化为另一种形式的过程。 </p><p>我们知道一个二进制有两种状态：”0” 状态 和 “1”状态，那么它就可以代表两种不同的东西，我们想赋予它什么含义，就赋予什么含义，比如说我规定，“0” 代表 “吃过了”, “1”代表 “还没吃”。</p><p>这样，我们就相当于把现实生活中的信息编码成二进制数字了，并且这个例子中是一位二进制数字，那么 2 位二进制数可以代表多少种情况能？对，是四种，2^2,分别是 00、01、10、11，那 7 种呢？答案是 2^7=128。</p><p>我们知道，在计算机中每八个二进制位组成了一个字节（Byte），计算机存储的最小单位就是字节，字节如下图所示 ：</p><p><img src="https://img-blog.csdnimg.cn/20181119221138910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll,size_16,color_FFFFFF,t_70" alt="img"></p><p>所以早期人们用 8 位二进制来编码英文字母(最前面的一位是 0)，也就是说，将英文字母和一些常用的字符和这 128 中二进制 0、1 串一一对应起来，比如说 大写字母“A”所对应的二进制位“01000001”，转换为十六进制为 41。</p><p>在美国，这 128 是够了，但是其他国家不答应啊，他们的字符和英文是有出入的，比如在法语中在字母上有注音符号，如 é ,这个怎么表示成二进制？</p><p>所以各个国家就决定把字节中最前面未使用的那一个位拿来使用，原来的 128 种状态就变成了 256 种状态，比如 é 就被编码成 130（二进制的 10000010）。</p><p>为了保持与 ASCII 码的兼容性，一般最高为为 0 时和原来的 ASCII 码相同，最高位为 1 的时候，各个国家自己给后面的位 (1xxx xxxx) 赋予他们国家的字符意义。</p><p>但是这样一来又有问题出现了，不同国家对新增的 128 个数字赋予了不同的含义，比如说 130 在法语中代表了 é,但是在希伯来语中却代表了字母 Gimel（这不是希伯来字母，只是读音翻译成英文的形式）具体的希伯来字母 Gimel 看下图 </p><p><img src="https://img-blog.csdnimg.cn/20181119221154343.png" alt="img"></p><p>所以这就成了不同国家有不同国家的编码方式，所以如果给你一串二进制数，你想要解码，就必须知道它的编码方式，不然就会出现我们有时候看到的乱码 。</p><p><strong>Unicode的出现</strong></p><p>Unicode 为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF (十六进制)，有 110 多万，每个字符都有一个唯一的 Unicode 编号，这个编号一般写成 16 进制，在前面加上 U+。例如：“马”的 Unicode 是U+9A6C。</p><p>Unicode 就相当于一张表，建立了字符与编号之间的联系</p><p><img src="https://img-blog.csdnimg.cn/20181119221209689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll,size_16,color_FFFFFF,t_70" alt="img"></p><p>它是一种规定，Unicode 本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。</p><p>有的人会说了，那我可以直接把 Unicode 编号直接转换成二进制进行存储，是的，你可以，但是这个就需要人为的规定了，而 Unicode 并没有说这样弄，因为除了你这种直接转换成二进制的方案外，还有其他方案，接下来我们会逐一看到。 </p><p>编号怎么对应到二进制表示呢？有多种方案：主要有 UTF-8，UTF-16，UTF-32。</p><p><strong>1、UTF-32</strong> </p><p>先来看简单的 UTF-32 </p><p>这个就是字符所对应编号的整数二进制形式，四个字节。这个就是直接转换。 比如马的 Unicode 为：U+9A6C，那么直接转化为二进制，它的表示就为：1001 1010 0110 1100。</p><p>这里需要说明的是，转换成二进制后计算机存储的问题，我们知道，计算机在存储器中排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如 0x1234, 计算机用两个字节存储，一个是高位字节 0x12,一个是低位字节 0x34，它的存储方式为下：</p><p><img src="https://img-blog.csdnimg.cn/20181119221224541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll,size_16,color_FFFFFF,t_70" alt="img"></p><p>UTF-32 用四个字节表示，处理单元为四个字节（一次拿到四个字节进行处理），如果不分大小端的话，那么就会出现解读错误，比如我们一次要处理四个字节 12 34 56 78，这四个字节是表示 0x12 34 56 78 还是表示 0x78 56 34 12？不同的解释最终表示的值不一样。</p><p>我们可以根据他们高低字节的存储位置来判断他们所代表的含义，所以在编码方式中有 UTF-32BE 和 UTF-32LE，分别对应大端和小端，来正确地解释多个字节（这里是四个字节）的含义。</p><p><strong>2、UTF-16</strong> </p><p>UTF-16 使用变长字节表示 </p><p>① 对于编号在 U+0000 到 U+FFFF 的字符（常用字符集），直接用两个字节表示。<br>② 编号在 U+10000 到 U+10FFFF 之间的字符，需要用四个字节表示。</p><p>同样，UTF-16 也有字节的顺序问题（大小端），所以就有 UTF-16BE 表示大端，UTF-16LE 表示小端。</p><p><strong>3、UTF-8</strong> </p><p>UTF-8 就是使用变长字节表示,顾名思义，就是使用的字节数可变，这个变化是根据 Unicode 编号的大小有关，编号小的使用的字节就少，编号大的使用的字节就多。使用的字节个数从 1 到 4 个不等。</p><p>UTF-8 的编码规则是：</p><p><strong>①</strong> 对于单字节的符号，字节的第一位设为 0，后面的7位为这个符号的 Unicode 码，因此对于英文字母，UTF-8 编码和 ASCII 码是相同的。 </p><p><strong>②</strong> 对于n字节的符号（n&gt;1）,第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10，剩下的没有提及的二进制位，全部为这个符号的 Unicode 码 。</p><p>举个例子：比如说一个字符的 Unicode 编码是 130，显然按照 UTF-8 的规则一个字节是表示不了它（因为如果是一个字节的话前面的一位必须是 0），所以需要两个字节(n = 2)。</p><p>根据规则，第一个字节的前 2 位都设为 1，第 3(2+1) 位设为 0，则第一个字节为：110X XXXX，后面字节的前两位一律设为 10，后面只剩下一个字节，所以后面的字节为：10XX XXXX。</p><p>所以它的格式为 110XXXXX 10XXXXXX 。</p><p>下面我们来具体看看具体的 Unicode 编号范围与对应的 UTF-8 二进制格式 </p><p><img src="https://img-blog.csdnimg.cn/20181119221259676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll,size_16,color_FFFFFF,t_70" alt="img"></p><p>那么对于一个具体的 Unicode 编号，具体怎么进行 UTF-8 的编码呢？</p><p>首先找到该 Unicode 编号所在的编号范围，进而可以找到与之对应的二进制格式，然后将该 Unicode 编号转化为二进制数（去掉高位的 0），最后将该二进制数从右向左依次填入二进制格式的 X 中，如果还有 X 未填，则设为 0 。</p><p>比如：“马”的 Unicode 编号是：0x9A6C，整数编号是 39532，对应第三个范围（2048 - 65535），其格式为：1110XXXX 10XXXXXX 10XXXXXX，39532 对应的二进制是 1001 1010 0110 1100，将二进制填入进入就为： </p><p>11101001 10101001 10101100 。</p><p><img src="https://img-blog.csdnimg.cn/20181119221313116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20181119221327766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXNvbmd6aXll,size_16,color_FFFFFF,t_70" alt="img"></p><p>由于 UTF-8 的处理单元为一个字节（也就是一次处理一个字节），所以处理器在处理的时候就不需要考虑这一个字节的存储是在高位还是在低位，直接拿到这个字节进行处理就行了，因为大小端是针对大于一个字节的数的存储问题而言的。</p><p>综上所述，UTF-8、UTF-16、UTF-32 都是 Unicode 的一种实现。</p><blockquote><p>转载自：<a href="https://blog.csdn.net/zhusongziye/article/details/84261211">https://blog.csdn.net/zhusongziye/article/details/84261211</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unicdoe </tag>
            
            <tag> utf-8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git HEAD 详解</title>
      <link href="post/Git%20HEAD%E8%AF%A6%E8%A7%A3/"/>
      <url>post/Git%20HEAD%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章中，我们提到了一个概念，那就是HEAD，但是我们并没有详细的去解释HEAD是个什么东西？这篇文章我们就来聊聊什么是HEAD</p><p>为了方便，我仍然使用之前的测试仓库进行测试，你也可以随意的创建一个用于测试的git仓库，然后创建几条分支，以便测试时使用。</p><p>我们先来回顾一下前文中测试仓库的状态，如下：</p><p>注：下图中使用了前文中创建的allbranch视图</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD1.png" alt="img"></p><p>如上图所示，我们现在有两个分支，master分支和test分支，从上图可以看出，目前我们处于黄色的提交，也就是test分支的”add D to m2″，如果我们想要切换回master分支，则可以使用前文中总结的如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 (master)</span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>如上述信息所示，我们已经从test分支切换到了master分支。</p><p>假设，我们现在关闭git bash和工作目录，当我们下次再次进入工作目录并且打开git bash时，仍然会显示为当前处于master分支，因为我们上次关闭工作目录之前，已经切换到了master分支，当然，如果你之前处于test分支，那么当你再次打开工作空间，仍然会显示你处于test分支。</p><p>那么问题来了，git是怎么知道我们当前该处于哪个分支呢？</p><p>git其实就是靠HEAD知道我们该处于哪个分支的，你可以把HEAD理解成一个指针，HEAD指针通常会指向一个分支（或者说指向一个分支指针），分支和分支指针的概念我们在前文中已经说明过，此处不再赘述，你可以把HEAD也理解成一个指针，这个指针通常指向一个分支指针，这样说不太直观，不如看下图（仍然在前文的图片的基础上进行修改）：</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD2.png" alt="img"></p><p>如上图所示，由于我们当前处于master分支，所以，HEAD这个指针指向了master分支指针，如果我们现在检出test分支，那么HEAD指针就会指向test指针，也就是说，当我们从master分支检出到test分支时，HEAD指针会由上图中的状态变成下图中的状态：</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD3.png" alt="img"></p><p>所以说，git只要找到HEAD，就能找到我们当前所处的分支（因为我们在切换分支时，会将HEAD指向所在的分支）。</p><p>我们可以直观的查看当前仓库的.git目录中的HEAD文件的内容，你会发现，其实.git/HEAD文件的内容就是HEAD指针所指向的分支，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 (master)</span><br><span class="line"></span><br><span class="line">$ cat .git/HEAD</span><br><span class="line"></span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>从上述返回信息可以看出，当前HEAD指针指向了另一个文件，这个文件就是.git/refs/heads/master，那么我们顺藤摸瓜，看看.git/refs/heads/master这个文件的文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 (master)</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/master</span><br><span class="line"></span><br><span class="line">7406a10efcc169bbab17827aeda189aa20376f7f</span><br></pre></td></tr></table></figure><p>可以看到，这个文件的内容是一串哈希码，而这个哈希码正是master分支上最新的提交所对应的哈希码。</p><p>聪明如你，肯定已经看出来了，.git/HEAD文件和.git/refs/heads/master文件不正是上图中的HEAD指针和master分支指针么，没错，就是这样的，只不过，在Git中，这些代表了上图中”指针”的文件还有另外一个名字，它们被称之为”引用” （references 或者 refs），其实都是一样的东西，不用纠结于它们的名字。</p><p>为了证明我们的想法，我们切换几次分支， 看看.git/HEAD文件内容的变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 (master)</span><br><span class="line"></span><br><span class="line">$ git checkout test</span><br><span class="line"></span><br><span class="line">Switched to branch &#x27;test&#x27;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ cat .git/HEAD</span><br><span class="line"></span><br><span class="line">ref: refs/heads/test</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 (master)</span><br><span class="line"></span><br><span class="line">$ cat .git/HEAD</span><br><span class="line"></span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>嗯嗯，看来是没错了，跟我们想的一样，HEAD指针通常指向我们所在的分支（的分支指针）。</p><p>前文中说过，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交。</p><p>而刚才又说过，HEAD指针通常会指向当前所在分支的分支指针。</p><p>那么，结合上述两点，我们可以得出如下结论：</p><p>HEAD指针 ——–&gt; 分支指针 ——–&gt; 最新提交</p><p>也就是说，通常情况下，HEAD指针总是通过分支指针，间接的指向了当前分支的最新提交。</p><p>单纯的靠上述文字描述可能不够直观，不如通过实际的操作来验证一下，操作如下：</p><p>首先，我们切换回test分支，看看当前HEAD指针和分支指针的指向，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 (master)</span><br><span class="line"></span><br><span class="line">$ git checkout test</span><br><span class="line"></span><br><span class="line">Switched to branch &#x27;test&#x27;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ cat .git/HEAD</span><br><span class="line"></span><br><span class="line">ref: refs/heads/test</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/test</span><br><span class="line"></span><br><span class="line">30d80b030d1a960bd90f020be2a3efb657c978e9</span><br></pre></td></tr></table></figure><p>从上述命令可以看出，切换到test分支以后，HEAD指针指向了test分支指针，而test分支指针指向了30d80b0这个提交，如下图所示</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD3.png" alt="img"></p><p>那么现在，我们来尝试在test分支上创建一个新的提交，看看HEAD指针和test分支指针会有哪些变化，操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ echo E &gt;&gt; m2</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ git add m2</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add E to m2&quot;</span><br><span class="line"></span><br><span class="line">[test 35cff8c] add E to m2</span><br><span class="line"></span><br><span class="line">1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ cat .git/HEAD</span><br><span class="line"></span><br><span class="line">ref: refs/heads/test</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/heads/test</span><br><span class="line"></span><br><span class="line">35cff8cabb71d553ab1abceaf33fa5a046a17bdb</span><br></pre></td></tr></table></figure><p>如上所示，我们在test分支上创建了一个新的提交35cff8c，然后查看了.git/HEAD，发现HEAD指针仍然指向了test分支指针，而test分支指针已经指向了最新创建的提交，也就是35cff8c，如下图所示：</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD4.png" alt="img"></p><p>所以说，通常情况下，HEAD指针总是指向了当前分支的最新提交（通过分支指针间接的指向）。</p><h2 id="什么是分离头"><a href="#什么是分离头" class="headerlink" title="什么是分离头"></a>什么是分离头</h2><p>刚才一直在说，”通常情况下”，HEAD总是指向当前所在的分支（即指向当前分支的分支指针）。</p><p>既然有”通常情况下”，肯定还有”不是那么通常的情况”，这种所谓的”不是那么通常的情况”，就是我们现在要描述的情况，这种情况被称之为”分离头”（detached HEAD），那么” 分离头”是什么意思呢？其实很简单，分离头的状态其实就是HEAD指针没有指向分支指针，而是直接指向了某个提交，比如下图中的情况</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD5.png" alt="img"></p><p>如上图所示HEAD指针没有指向任何一个分支，而是直接指向了上图中的C3这个提交，这种情况就是”分离头”（detached HEAD）的情况，从字面上理解，” 分离头”或者称之为” 头分离”的这种情况就是HEAD指针（头指针）和分支指针分开了，HEAD指针和分支指针分开后，指向了某个提交。</p><p>上图的HEAD指针直接指向了C3这个提交，上图只是为了示例，所以随意的指向了一个提交，HEAD指针直接指向任何一个提交的情况都属于分离头，所以，不要纠结于上图的HEAD指针指向了哪个提交。</p><p>那么我们进行什么操作时才会进入到分离头的状态呢？很简单，当我们直接检出一个提交（而不是检出某个分支），就可以进出分离头状态，在之前的操作中，我们使用git checkout命令都是检出某个分支，那么现在，我们直接在git checkout命令后面指定某个提交的哈希码，即可进入到分离头的状态。下面我们来动手操作一下，不过在开始之前，我们先来看看各个分支以及HEAD指针的状态，使用”git log –oneline –all –graph”命令可以在命令行中以字符的形式尽量接近图形化的方式展示分支，如下：</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD6.png" alt="img"></p><p>当然，使用上述方式和使用gitk图形化的方式都能查看分支，但是我个人还是习惯使用gitk图形化工具查看分支，毕竟图形化工具相对美观一些，在后文中还是会尽可能的使用图形化的，不过从上图可以更加直观的看出，当前我们处于test分支，HEAD指针指向了test分支。此时，运行gitk命令，看到的分支图如下（下图中使用了前文中创建的allbranch视图）：</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD7.png" alt="img"></p><p>在上图中，你可以直观的看到test分支指针和master分支指针，但是你看不到HEAD指针，其实，上图中的黄色提交就是HEAD指针所在的位置（或者你也可以把HEAD指针理解成一个黄色的圆球），也就是说，从上图可以看出，HEAD指针现在指向了test分支。</p><p>现在，我们想要做的是造成所谓的” 分离头”状态，也就是说，我们想让HEAD指针指向某个提交，而不是指向某个分支指针。</p><p>我们随便检出到某个提交，都可以进入分离头状态，操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ git checkout cbd3348</span><br><span class="line"></span><br><span class="line">Note: checking out &#x27;cbd3348&#x27;.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental</span><br><span class="line"></span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line"></span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line"></span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">HEAD is now at cbd3348 add 2 in m1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 ((cbd3348...))</span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>从上述信息可以看出，我检出了哈希码为cbd3348的提交，也就是”add 2 in m1″对应的提交，当我执行上述命令后，git的返回信息也在提示我们，You are in ‘detached HEAD’ state.（你现在处于’分离头’状态），我们检出了’cbd3348’这个提交，现在，当前目录就处于‘cbd3348’这个提交对应的状态，也就是说，目录中所有文件的内容都与’cbd3348’这个状态对应，执行上述命令后，命令提示符中也显示了当前提交的哈希码。</p><p>那么现在，我们再次执行 “git log –oneline –all –graph”命令，看看现在HEAD指针所处的位置，如下：</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD8.png" alt="img"></p><p>从上图可以看出，HEAD指针目前没有指向任何一个分支指针，而是直接指向了’cbd3348’这个提交，这就是所谓的分离头状态。</p><p>如果此时你使用gitk图形化界面，会发现’cbd3348’这个提交变成了黄色，如下：</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD9.png" alt="img"></p><p>也就是说，HEAD指针目前处于’cbd3348’这个提交，并没有指向任何分支。</p><p>如果此时在命令行中执行’git status’命令，同样会提示你，你当前处于分离头状态，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 ((cbd3348...))</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">HEAD detached at cbd3348</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h2 id="分离头状态的使用场景"><a href="#分离头状态的使用场景" class="headerlink" title="分离头状态的使用场景"></a>分离头状态的使用场景</h2><p>那么分离头状态有什么用呢？该怎么用呢？</p><p>其实，从上文的返回信息中就能找到答案。在我们执行’ git checkout cbd3348’这条命令时，git就返回了很长一段信息，返回信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Note: checking out &#x27;cbd3348&#x27;.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental</span><br><span class="line"></span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line"></span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line"></span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">HEAD is now at cbd3348 add 2 in m1</span><br></pre></td></tr></table></figure><p>注：我先大概的描述一下上述返回信息，后面会有实际的示例，所以，不明白上述返回信息的意思也不用纠结，看到最后自然就会明白。</p><p>从上述返回信息我们可以得知，我们当前检出了’cbd3348’这个提交，现在我们处于分离头的状态，git建议我们，在分离头的状态下，我们可以随便看看，可以按照我们的想法，对当前目录中的文件进行一些实验性的修改，并且将这些实验性的修改创建成一些提交（其实这些提交会组成一条匿名分支），如果你最后后悔了，觉得实验不成功，修改后的结果并不是你想要的，那么我们可以在不影响任何其他分支和提交的情况下，丢弃这些实验性的提交（丢弃这条匿名分支），如果你觉得这些实验性的提交让你很满意，那么你就可以创建一个新的分支（其实是给这个匿名分支一个固定的名字），来永久性的保存这些提交。</p><p>只是通过语言描述的方式，可能并不是特别容易理解分离头状态的用处，不如，我们就在分离头的状态下随便做些修改，然后创建一些提交，通过实际操作来认识分离头状态的使用方法吧，操作如下：</p><p>首先，看看当前目录中各个文件的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 ((cbd3348...))</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">HEAD detached at cbd3348</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 ((cbd3348...))</span><br><span class="line"></span><br><span class="line">$ cat m1</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 ((cbd3348...))</span><br><span class="line"></span><br><span class="line">$ cat m2</span><br><span class="line"></span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>由于刚才我们直接检出了’cbd3348’这个提交，所以，我们处于分离头状态，而且当前仓库中各个文件的内容也回到了’cbd3348’这个提交对应的状态，假设，此时我想对m1这个文件进行一些修改，于是，我进行了如下一系列的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 ((cbd3348...))</span><br><span class="line"></span><br><span class="line">$ echo 3test &gt;&gt; m1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 ((cbd3348...))</span><br><span class="line"></span><br><span class="line">$ git add m1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 ((cbd3348...))</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add 3test in m1&quot;</span><br><span class="line"></span><br><span class="line">[detached HEAD c22af40] add 3test in m1</span><br><span class="line"></span><br><span class="line">1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 ((c22af40...))</span><br><span class="line"></span><br><span class="line">$ echo 4test &gt;&gt; m1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 ((c22af40...))</span><br><span class="line"></span><br><span class="line">$ git add m1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 ((c22af40...))</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add 4test in m1&quot;</span><br><span class="line"></span><br><span class="line">[detached HEAD dca15df] add 4test in m1</span><br><span class="line"></span><br><span class="line">1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 ((dca15df...))</span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>从上述命令可以看出，我先在m1文件中加了一行”3test”，并且为这次修改创建了一个新的提交，新提交的哈希码是c22af40，当新提交c22af40被创建以后，命令提示符中的哈希码就变成了c22af40，然后，我又在m1文件中加了一行”4test”，并且为这次修改也创建了一个新提交，新提交的哈希码为dca15df，同样，这个提交被创建以后，命令提示符中的哈希码就变成了最新提交的哈希码，好了，现在我们已经在分离头的状态下创建了两个新提交，那么此时，我们来看看各个分支的状态以及HEAD指针的位置，打开gitk图形化界面，如下：</p><p>注：此处使用”gitk –all”命令打开gitk图形化界面，”–all”参数表示显示所有分支，你也可以打开gitk以后，选择前文中保存过的视图来查看所有分支。</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD10.png" alt="img"></p><p>从上图可以看出，HEAD指针已经指向了最新的提交，这个提交就是我们刚才创建的”add 4test in m1″，而且从上图可以看出，从”add 2 in m1″分出了一条分支，”add 2 in m1″是一个分叉点，这个分叉点就是上文中的‘cbd3348’提交，我们直接检出了’cbd3348’这个提交，进入到了分离头的状态，然后在分离头的状态下，创建了两个新提交，这两个新提交就是”add 3test in m1″和”add 4test in m1″，这两个新提交与分叉点之前的提交组成了一条匿名分支，没有任何一个分支标签指向这个匿名分支。</p><p>我们现在有两个选择，如下：</p><p>选择一：丢弃这个匿名分支</p><p>选择二：保留这个匿名分支</p><p>上述两种选择分别对应了不同的操作，我们后续再进行实际的示例。</p><p>看到这里，我似乎明白了分离头的使用场景，说白了，分离头的状态不就是让我们可以随意的检出某个提交，然后基于这个提交创建一些新提交么，这些新创建的提交是偏实验性质的，为什么这么说呢？因为我们可能会保存这些提交，也有可能放弃这些提交，你可以根据最终的结果判断是否保存这些提交，这些新创建的提交可以理解成一条匿名分支。</p><p>好了，刚才说过，我们可以选择放弃这个匿名分支，也可以选择保留它，那么具体该怎么操作呢？一个一个聊</p><p>先说说怎样放弃这些提交，如果你对这些实验性的提交不满意，你可以直接检出到任何一个别的分支，就相当于放弃了这些提交，就是这么简单。比如，我们当前处于分离头状态，现在我们直接检出到test分支，示例操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 ((dca15df...))</span><br><span class="line"></span><br><span class="line">$ git checkout test</span><br><span class="line"></span><br><span class="line">Warning: you are leaving 2 commits behind, not connected to</span><br><span class="line"></span><br><span class="line">any of your branches:</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">dca15df add 4test in m1</span><br><span class="line"></span><br><span class="line">c22af40 add 3test in m1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">If you want to keep them by creating a new branch, this may be a good time</span><br><span class="line"></span><br><span class="line">to do so with:</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">git branch &lt;new-branch-name&gt; dca15df</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Switched to branch &#x27;test&#x27;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 (test)</span><br></pre></td></tr></table></figure><p>如上例所示，当我们直接从分离头状态检出到其他分支时，git会提示我们，你落下了2个提交在后面，这两个提交没有关联到任何分支，这两个提交是……（你创建的提交信息），如果你想要保存它们，那么你可以……(git在这时其实就已经给出了保留这个匿名分支的命令，不过这个命令我们放到后面再聊)，如上例所示，我们从分离头状态已经检出到了别的分支（test分支），这就相当于放弃了那些实验性的提交（匿名分支），此时运行” gitk –all”命令，查看HEAD以及分支的状况，如下图所示</p><p><img src="https://www.zsythink.net/wp-content/uploads/2019/09/090119_1124_Git8HEAD7.png" alt="img"></p><p>你会发现，那条匿名分支已经不见了，因为没有任何一个指针指向那些提交，所以，那些实验性的提交会在过一段时间后被git的垃圾回收机制清除，因为我们不想要它们了，所以不用理会它们，它们就好像不存在一样，也不会对其他分支和提交造成影响。上述操作就是丢弃这些实验性提交的方法，是不是很简单？</p><p>如果我们想要永久的保存那些在分离头状态下创建的提交该怎么办呢？</p><p>其实也很简单，我们只需要将这些提交创建成一条新的分支就行了（或者也可以理解成为匿名分支命名），为了方便演示，我再次检出到dca15df这个提交（这个提交是之前在演示分离头状态时创建的最新的提交），检出dca15df提交是为了回到之前的分离头状态，以便演示怎样在分离头的状态下保存那些实验性的提交，检出dca15df提交的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/d/workspace/git/test_repo1 (test)</span><br><span class="line"></span><br><span class="line">$ git checkout dca15df</span><br><span class="line"></span><br><span class="line">Note: checking out &#x27;dca15df&#x27;.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental</span><br><span class="line"></span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line"></span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line"></span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">HEAD is now at dca15df add 4test in m1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/d/workspace/git/test_repo1 ((dca15df...))</span><br></pre></td></tr></table></figure><p>从上述命令可以看出，当我们从test分支检出到’dca15df’提交以后，git又从”通常状态”进入到了”分离头状态”，并且git再次提示我们，你可以通过” git checkout -b <new-branch-name>”命令创建一个新的分支以便来保存这些在分离头状态下创建的提交，假设，我们想要创建一个名为newtest的分支来保存这些提交，那么可以直接执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b newtest</span><br></pre></td></tr></table></figure><p>执行上述命令后，新创建的newtest分支指针就会指向我们当前所在的提交（即dca15df提交），这样，我们就能永久的保存这些提交了。<br>当然，除了” git checkout -b newtest”命令，你也可以使用如下类似的命令来创建一个分支来保存分离头状态下创建的提交，比如如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch newtest dca15df</span><br></pre></td></tr></table></figure><p>上述命令的意思是在dca15df提交的位置创建一个名为newtest的分支（此命令不会自动检出到新创建的分支，会停留在原位置，但是新的分支指针会在指定的提交处创建），细心如你肯定已经发现了，在之前的示例过程中，当我们从dca15df提交的分离头状态检出到test分支时，git同样会提示你使用”git branch <new-branch-name> dca15df”命令来保存分离头状态下创建的那些提交，其实，命令虽然不同，但是本质上的目标都是创建一个分支来保存分离头状态下的提交（换一种说法就是给分离头状态下产生的匿名分支命名）。</p><p>说了这么多，你肯定明白了分离头指针的使用场景，当你想要基于某个提交进行一些实验或者测试，可以直接检出这个提交，立马在上面开始实验/测试工作，如果结果满意，就保留，如果结果不满意，就丢弃。你可能会说，我直接基于指定的提交创建一个新的分支，然后在新的分支上进行实验不是也可以吗？是的，完全可以，没有任何问题，只是，如果实验结果不满意，你可能还想要删除这条用于实验的分支，而使用分离头，就可以先实验，再判断是否保留这些提交，避免了在不满意的情况下创建分支或者删除分支的操作。</p><blockquote><p>本文转载自：<a href="https://www.zsythink.net/archives/3412/">https://www.zsythink.net/archives/3412/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 一篇就够了</title>
      <link href="post/Git%20%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
      <url>post/Git%20%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e71a44952962454383ff57a72b2bf2d4~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp" alt="学习 Git，看这一篇就够了！"></p><hr><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a10f8fbb523497b8015d5b1e3264eb6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h1 id="一、Git基本概念"><a href="#一、Git基本概念" class="headerlink" title="一、Git基本概念"></a>一、Git基本概念</h1><h3 id="1-Git-历史"><a href="#1-Git-历史" class="headerlink" title="1. Git 历史"></a>1. Git 历史</h3><p>Git 是最流行的分布式版本控制系统（Distributed Version Control System，简称 DVCS）。它由 Linus Torvalds 创建，当时非常需要一个快速、高效和大规模分布式的源代码管理系统，用于管理 Linux 源代码。</p><p>由于 Linus 对几乎所有现有的源代码管理系统抱有强烈的反感，因此他决定编写自己的源代码管理系列。2005 年 4 月，Git 就诞生了。到了 2005 年 7 月，维护工作就交给了 Junio Hamano，自此他就一直在维护这个项目。</p><p>虽然最初只用于 Linux 内核，但 Git 项目迅速传播，并很快被用于管理许多其他 Linux 项目。现在，几乎所有的软件开发，尤其是在开源世界中，都是通过 Git 进行的。</p><h3 id="2-版本控制系统"><a href="#2-版本控制系统" class="headerlink" title="2. 版本控制系统"></a>2. 版本控制系统</h3><p>版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。版本控制技术是团队协作开发的桥梁，助力于多人协作同步进行大型项目开发。软件版本控制系统的核心任务就是查阅项目历史操作记录、实现协同开发。</p><p>常见版本控制主要有两种：<strong>集中式版本控制</strong>和<strong>分布式版本控制</strong>。</p><h4 id="（1）集中式版本控制系统"><a href="#（1）集中式版本控制系统" class="headerlink" title="（1）集中式版本控制系统"></a>（1）集中式版本控制系统</h4><p>集中式版本控制系统，版本库是集中存放在中央服务器的。工作时，每个人都要先从中央服务器获取最新的版本。完成之后，再把自己添加/修改的内容提交到中央服务器。所有文件和历史数据都存储在中央服务器上。SVN 是最流行的集中式版本控制系统之一。</p><p>集中式版本控制系统的缺点就是必须联网才能使用，如果使用局域网还好，速度会比较快。而如果是使用互联网，网速慢的话，就可能需要等待很长时间。除此之外，如果中央服务器出现故障，那么版本控制将不可用。如果中心数据库损坏，若数据未备份，数据就会丢失。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35f1bae8099a4416a94eea9d71fa91f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="（2）分布式版本控制系统"><a href="#（2）分布式版本控制系统" class="headerlink" title="（2）分布式版本控制系统"></a>（2）分布式版本控制系统</h4><p>分布式版本控制系统，每台终端都可以保存版本库，版本库可以不同，可以对每个版本库进行修改，修改完成后可以集中进行更新。虽然它没有中心服务器，但可以有一个备份服务器，它的功能有点类似于 SVN 的中央服务器，但它的作用仅是方便交换修改，而不像 SVN 那样还要负责源代码的管理。Git 是最流行的分布式版本控制系统之一。</p><p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑损坏不会影响到协作的其他人。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de496c692a8b42f197485eb2f222f085~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="（3）SVN-vs-Git"><a href="#（3）SVN-vs-Git" class="headerlink" title="（3）SVN vs Git"></a>（3）SVN vs Git</h4><p>Git 相较于 SVN：</p><ul><li><strong>提交速度更快：</strong> 因为在 SVN 中需要更频繁地提交到中央存储库，所以网络流量会减慢每个人的速度。而使用 Git，主要在本地存储库上工作，只需每隔一段时间才提交到中央存储库。</li><li><strong>没有单点故障：</strong> 使用 SVN，如果中央存储库出现故障，则在修复存储库之前，其他开发人员无法提交他们的代码。使用 Git，每个开发人员都有自己的存储库，因此中央存储库是否损坏并不重要。开发人员可以继续在本地提交代码，直到中央存储库被修复，然后就可以推送他们的更改；</li><li><strong>可以离线使用：</strong> 与 SVN 不同，Git 可以离线工作，即使网络失去连接，也可以继续工作而不会丢失功能。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bae15963b57d4af4ae4896714f61ac60~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h3 id="3-Git-安装"><a href="#3-Git-安装" class="headerlink" title="3. Git 安装"></a>3. Git 安装</h3><p>在Git官网下载、安装即可：<a href="https://link.juejin.cn/?target=https://git-scm.com/download">git-scm.com/download</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66f0c2ab087041059c209011158dc7cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>安装完成之后，可以使用以下命令来查看 Git 是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果安装成功，终端会打印安装的 Git 的版本：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a70b2b9b6aa4c2990522a64e3908c52~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h3 id="4-Git-初始化"><a href="#4-Git-初始化" class="headerlink" title="4. Git 初始化"></a>4. Git 初始化</h3><p>要给项目初始化一个Git仓库，可以在终端中打开项目目录，执行以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>初始化之后，就会创建一个名为<code>.git</code>的新子文件夹，其中包含 Git 将用于跟踪项目更改的多个文件和更多子目录：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67be66dfebe5452e938c6177591ff653~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>在使用 Git 进行代码管理时，不希望一些文件出现在跟踪列表中，比如<code>node_modules</code>文件。这种情况下，可以在项目的根目录中创建一个名为.gitignore的文件，在该文件中列出要忽略的文件和文件夹，来看一个示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有以.md结尾的文件</span></span><br><span class="line">*.md  </span><br><span class="line"></span><br><span class="line"><span class="comment"># lib.a不能被忽略</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># node_modules和.vscode文件被忽略</span></span><br><span class="line">node_modules</span><br><span class="line">.vscode</span><br><span class="line"></span><br><span class="line"><span class="comment"># build目录下的文件被忽略</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># doc目录下的.txt文件被忽略</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># doc目录下多层目录的所有以.pdf结尾的文件被忽略</span></span><br><span class="line">doc/**/*.pdf</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：以 # 符号开头的行是注释。</p><p>我们可以在本地克隆Git存储库上的代码，首先要找到Git存储库上的HTTPS或SSH的地址，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2f9df1dc4894165abde2018fbb3b779~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>然后使用以下命令将远程仓库克隆到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/facebook/react.git</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="5-Git-结构和状态"><a href="#5-Git-结构和状态" class="headerlink" title="5. Git 结构和状态"></a>5. Git 结构和状态</h3><p>从Git的角度来看，可以在三个区域进行文件更改：工作区，暂存区和存储库。</p><ul><li><strong>工作区：</strong> 本地看到的工作目录；</li><li><strong>暂存区：</strong> 一般存放在 <code>.git</code> 目录下的 index 文件（.git/index）中，所以暂存区有时也叫作索引（index）。暂存区是一个临时保存修改文件的地方；</li><li><strong>版本库：</strong> 工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 Git 的版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c88f4aef734e5a8d0dbb319e44d38c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>Git 工作目录下的文件存在两种状态：</p><ul><li>untracked：未跟踪，未被纳入版本控制，即该文件没有被Git版本管理；</li><li>tracked：已跟踪，被纳入版本控制，即该文件已被Git版本管理。</li></ul><p>其中<strong>已跟踪状态</strong>可以细分为以下三种状态：</p><ul><li>Unmodified：未修改状态</li><li>Modified：已修改状态</li><li>Staged：已暂存状态</li></ul><p>可以通过运行以下命令来检查当前分支的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>显示结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09fbd280c6be4e1c95af04fb94307ee9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>此命令不会更改或更新任何内容。它会打印出哪些文件被修改、暂存或未跟踪。未跟踪的文件是尚未添加到 git 索引的文件，而自上次提交以来已更改的文件将被视为已被 git 修改。</p><h2 id="二、Git-入门"><a href="#二、Git-入门" class="headerlink" title="二、Git 入门"></a>二、Git 入门</h2><h3 id="1-全局配置"><a href="#1-全局配置" class="headerlink" title="1. 全局配置"></a>1. 全局配置</h3><p>当安装Git后首先要做的就是配置所有本地存储库中使用的用户信息。每次Git提交都会使用该用户信息。</p><p>config 命令适用于不同的级别：</p><ul><li><strong>本地级别：</strong> 所有配置都仅限于项目目录。默认情况下， 如果未通过任何配置, 则git config将在本地级别写入；</li><li><strong>全局级别：</strong> 此配置特定于操作系统上的用户，配置值位于用户的主目录中；</li><li><strong>系统级别：</strong> 这些配置放在系统的根路径下，它跟踪操作系统上的所有用户和所有存储库。</li></ul><p>下面的配置均为写入系统级别：</p><h4 id="（1）设置用户名"><a href="#（1）设置用户名" class="headerlink" title="（1）设置用户名"></a>（1）设置用户名</h4><p>可以使用以下命令设置使用 Git 时的用户名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;name&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以使用以下命令查看设置的<code>user.name</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（2）设置邮箱"><a href="#（2）设置邮箱" class="headerlink" title="（2）设置邮箱"></a>（2）设置邮箱</h4><p>可以使用以下命令设置使用 Git 时的邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;email&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以使用以下命令查看设置的 email：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.email</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（3）设置命令颜色"><a href="#（3）设置命令颜色" class="headerlink" title="（3）设置命令颜色"></a>（3）设置命令颜色</h4><p>除了上述两个基本的设置之外，还可以设置命令的颜色，以使输出具有更高的可读性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> git config --global color.ui auto</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（4）查看所有配置"><a href="#（4）查看所有配置" class="headerlink" title="（4）查看所有配置"></a>（4）查看所有配置</h4><p>通过上面的命令设置的信息会保存在本地的<code>.gitconfig</code>文件中。可以使用以下命令查看所有配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果在全局输入这个命令，就会显示全局的配置：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86cb98f4a4b74bc28700018cf8f43342~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>如果在使用 Git 的项目中输入该命令，除了会显示全局的配置之外，还会显式本地仓库的一些配置信息，如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c289ca28b5b4944bcdcc31ba10dd020~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><h4 id="（5）设置别名"><a href="#（5）设置别名" class="headerlink" title="（5）设置别名"></a>（5）设置别名</h4><p>git config 命令为我们提供了一种创建别名的方法，这种别名通常用于缩短现有的命令或者创建自定义命令。来看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.cm <span class="string">&quot;commit -m&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里为<code>commit -m</code>创建一个别名 <code>cm</code>，这样在提交暂存区文件时，只需要输入以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cm &lt;message&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-分支操作"><a href="#2-分支操作" class="headerlink" title="2. 分支操作"></a>2. 分支操作</h3><p>分支是源代码控制的核心概念，它允许将工作分离到不同的分支中，这样就可以自由地处理源代码，而不会影响其他任何人的工作或主分支中的代码。下面来看一些常见的分支操作。</p><h4 id="（1）查看分支"><a href="#（1）查看分支" class="headerlink" title="（1）查看分支"></a>（1）查看分支</h4><p>可以使用以下命令来查看当然所在的分支以及该项目所有的分支情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>该命令可以列出项目所有的<strong>本地分支</strong>，显示绿色的分支就是当前分支：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fad456dfdb24e25b27b78ce8ac9cd7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>可以使用以下命令来列出所有的远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/377a399ab61d4153ab61c0adb602c01a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>可以使用以下命令来查看所有的本地分支和远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4070a7c5af9049228f2411ae37343650~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><h4 id="（2）创建分支"><a href="#（2）创建分支" class="headerlink" title="（2）创建分支"></a>（2）创建分支</h4><p>我们在计算机上只能访问本地分支，在将分支推送到远程仓库之前，需要先创建一个本地分支。</p><p>可以使用以下命令来创建分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>加上<code>-b</code>就可以在创建新的分支之后，直接切换到新创建的分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果想将新建的本地分支推送到远程仓库，以在远程仓库添加这个分支。可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin &lt;branch&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（3）删除分支"><a href="#（3）删除分支" class="headerlink" title="（3）删除分支"></a>（3）删除分支</h4><p>可以使用以下命令来<strong>删除本地分支</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>需要注意，在删除分支之前，要先切换到其他分支，否则就会报错：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c646683a4a540efa11fecc13c6b69b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>切换到其他分支再删除即可：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/864f5fbac63b4648a07275e44d6c73e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>有时 Git 会拒绝删除本地分支，因为要删的分支可能有未提交的代码。这是为了保护代码以避免意外丢失数据。可以使用以下命令来<strong>强制删除本地分支</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就删除成功了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/317c0759f61c4eb1949ef408e7eae5c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>当然，我们也可以<strong>删除远程仓库分支</strong>，执行以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;name&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（4）合并分支"><a href="#（4）合并分支" class="headerlink" title="（4）合并分支"></a>（4）合并分支</h4><p>可以使用以下命令将其他分支的代码合并到当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果想将A分支合并到B分支，就要先切换到B分支，然后执行命令：<code>git merge A</code>。</p><h4 id="（5）重命名分支"><a href="#（5）重命名分支" class="headerlink" title="（5）重命名分支"></a>（5）重命名分支</h4><p>可以使用以下命令来将分支重命名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;oldname&gt; &lt;newname&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果<code>newname</code>名字分支已经存在，则需要使用<code>-M</code>来强制重命名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -M &lt;oldname&gt; &lt;newname&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="3-基础操作"><a href="#3-基础操作" class="headerlink" title="3. 基础操作"></a>3. 基础操作</h3><p>Git 数据工作流程如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d36c5cd6eaf843a3a53377753c78e2a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><h4 id="（1）暂存文件"><a href="#（1）暂存文件" class="headerlink" title="（1）暂存文件"></a>（1）暂存文件</h4><p>可以使用以下命令来暂存已修改的文件，命令最后需要指定要暂存的文件名称：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果想要将所有未跟踪和修改的文件添加到暂存区，可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此时分支的状态如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fac5f0610fe84af8b61983837be1a8ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><h4 id="（2）提交暂存"><a href="#（2）提交暂存" class="headerlink" title="（2）提交暂存"></a>（2）提交暂存</h4><p>可以使用以下命令将暂存区的文件修改提交到本地仓库，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;meaasge&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中<code>-m</code>参数表示<code>message</code>日志信息，参数后面要加一个日志信息，用双引号括起来。</p><p>此时分支的状态如下： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bcf8d55444f49609df0ab618a64400d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"> 如果上次提交暂存的<code>messge</code>写错了怎么办呢？可以使用使用以下命令来更新提交，而不需要撤销并重新提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m &lt;message&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果有一个新的文件修改，也想提交到上一个commit中，可以使用以下命令来保持相同的提交信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit --amend --no-edit</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（3）存储更改"><a href="#（3）存储更改" class="headerlink" title="（3）存储更改"></a>（3）存储更改</h4><p>假如我们正在开发迭代功能，但是还没开发完。这时有一个紧急的bug需要修复上线。可能就需要切换到一个hotfix分支去修复bug。这时对于开发了一部分的功能创建提交是没有逻辑意义的。可以使用以下任一命令来存储修改的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash push</span><br><span class="line">git stash push -m <span class="string">&quot;&lt;stash message&gt;&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>该命令回保存所有未提交的更改并恢复到上次提交时存储库的状态。</p><p>当想再次继续开发此功能时，就可以使用以下命令检查所有存储：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这时终端中就会显示带有时间戳的所有已经暂存的列表。可以使用以下任一命令来取回所有的更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br><span class="line">git stash pop</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>apply 和 pop 之间的区别在于，pop 应用了 stash 中的更改并将其也从 stash 中删除，但 apply 即使在应用后仍将更改保留在 stash 中。</p><p>可以使用以下任一命令应用存储列表中的第 N 个存储：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;N&#125;</span><br><span class="line">git stash apply &lt;n&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>整个过程的输出如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5dce784f14b494189ec74ec14a36b4e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><h4 id="（4）合并指定提交"><a href="#（4）合并指定提交" class="headerlink" title="（4）合并指定提交"></a>（4）合并指定提交</h4><p>在不同分支之间进行代码合并时，通常会有两种情况：一种情况是需要另一个分支的所有代码变动，那么就可以直接合并（git merge），另一种情况是只需要部分代码的变动（某几次提交），这时就可以使用以下命令来合并指定的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit <span class="built_in">hash</span>&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>建议添加 <code>-x</code> 标志，因为它会生成标准化的提交消息，通知用户它是从哪里pick出来的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick -x &lt;commit <span class="built_in">hash</span>&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>那么这个<code>commit hash</code>是从哪里来的呢？可以在需要被合并的分支上执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这时终端就会显示出所有的提交信息：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5af0e48387e24ef5843da2394c5c9163~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>这里黄色文字中<code>commit</code>后面的部分就是<code>commit hash</code>，复制即可。</p><h4 id="（5）检查提交"><a href="#（5）检查提交" class="headerlink" title="（5）检查提交"></a>（5）检查提交</h4><p>Git允许我们在本地检查特定的提交。输入以下命令就可以查看有关当前提交的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git show</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出的结构如下，可以看到，它显示出了上次提交的commit id、作者信息（邮箱和姓名）、提交日期、commit message、代码diff等：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/939d9db4d91140d1b6eb7e1dd45e6476~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>还可以使用<code>HEAD~n</code>语法或提交哈希来检查过去的提交。使用以下命令就可以获取往前数的第三次提交的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git show HEAD~3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>除此之外，还可以添加一个<code>--oneline</code>标志，以简化输出信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git show --oneline</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样提交信息就简洁了很多：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9447a1fada5542859855606e6eeba6b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><h4 id="（6）查看贡献者"><a href="#（6）查看贡献者" class="headerlink" title="（6）查看贡献者"></a>（6）查看贡献者</h4><p>可以使用以下命令来返回每个贡献者的commit次数以及每次commit的commit message：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git shortlog</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其可以添加两个参数：</p><ul><li>s：省略每次 commit 的注释，仅仅返回一个简单的统计。</li><li>n：按照 commit 数量从多到少的顺利对用户进行排序。</li></ul><p>加上这两个参数之后就可以看到每个用户中的提交次数以及排名情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git shortlog -sn</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就会显示出该项目所有贡献者的commit次数，从上到下依次减小：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f72c942ecf6841808bafea9b535301e7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>除此之外，还可以添加一个<code>--no-merges</code>标志，以忽略合并提交的次数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> git shortlog -sn --no-merges</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-远程操作"><a href="#4-远程操作" class="headerlink" title="4. 远程操作"></a>4. 远程操作</h3><h4 id="（1）查看远程仓库"><a href="#（1）查看远程仓库" class="headerlink" title="（1）查看远程仓库"></a>（1）查看远程仓库</h4><p>可以使用以下命令来查看远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>该命令会列出指定的每一个远程服务器的简写。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4221bca2640943a59363d1a2fbcf3c73~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>可以执行以下命令来获取远程仓库的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中<code>fetch</code>是获取，<code>push</code>是推送：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb0213147d02414db4d697f62f54dfab~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>可以使用以下命令来查看更加详细的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99795be2e4a64a8499d2fde9e2a3adff~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><h4 id="（2）添加远程仓库"><a href="#（2）添加远程仓库" class="headerlink" title="（2）添加远程仓库"></a>（2）添加远程仓库</h4><p>可以使用以下命令来将本地项目链接到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;remote_name&gt; &lt;remote_url&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>remote_name</code>：仓库名称（默认是origin）</li><li><code>remote_url</code>：远程仓库地址</li></ul><p>该命令允许 Git 跟踪远程存储库并将本地存储库连接到远程仓库。</p><h4 id="（3）移除远程仓库"><a href="#（3）移除远程仓库" class="headerlink" title="（3）移除远程仓库"></a>（3）移除远程仓库</h4><p>可以使用命令来移除远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>需要注意，该命令只是从本地移除远程仓库的记录（也就是解除本地仓库和远程仓库的关系），并不会真正影响到远程仓库。</p><h4 id="（4）从远程仓库抓取与拉取"><a href="#（4）从远程仓库抓取与拉取" class="headerlink" title="（4）从远程仓库抓取与拉取"></a>（4）从远程仓库抓取与拉取</h4><p>可以使用以下命令来从远程仓库获取最新版本到本地仓库，不会自动merge（合并数据）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由于该命令不会自定合并数据，所以该命令执行完后需要手动执行 git merge 远程分支到所在的分支。</p><p>可以使用以下命令来将<strong>远程指定分支</strong>拉取到<strong>本地指定分支上</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用以下命令来将<strong>远程指定分支</strong>拉取到<strong>本地当前分支上</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;远程分支名&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用以下命令开将<strong>与本地当前分支同名的远程分支</strong>拉取到<strong>本地当前分支上：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（<code>fatal: refusing to merge unrelated histories</code> ），解决此问题可以在<code>git pull</code>命令后加入参数<code>--allow-unrelated-histories</code>，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --allow-unrelated-histories</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（5）推送到远程仓库"><a href="#（5）推送到远程仓库" class="headerlink" title="（5）推送到远程仓库"></a>（5）推送到远程仓库</h4><p>可以使用以下命令将<strong>本地指定分支</strong>推送到<strong>远程指定分支上</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以使用以下命令将<strong>本地指定分支</strong>推送到<strong>与本地当前分支同名的远程分支上：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;本地分支名&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用以下命令将<strong>本地当前分支</strong>推送到<strong>与本地当前分支同名的远程分支上</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以使用以下命令来将本地分支与远程同名分支相关联：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin &lt;本地分支名&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由于远程库是空的，第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令为git push。</p><h2 id="三、Git-进阶"><a href="#三、Git-进阶" class="headerlink" title="三、Git 进阶"></a>三、Git 进阶</h2><h3 id="1-修改操作"><a href="#1-修改操作" class="headerlink" title="1. 修改操作"></a>1. 修改操作</h3><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 Changes not staged for commit 的提示</p><h4 id="（1）删除文件"><a href="#（1）删除文件" class="headerlink" title="（1）删除文件"></a>（1）删除文件</h4><p>可以使用以下命令将文件从暂存区和工作区中删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;filename&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm -f &lt;filename&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <code>--cached</code> 选项即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;filename&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以使用以下命令进行递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm –r * </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>进入某个目录中，执行此语句，就会删除该目录下的所有文件和子目录。</p><h4 id="（2）取消修改"><a href="#（2）取消修改" class="headerlink" title="（2）取消修改"></a>（2）取消修改</h4><p>取消修改有三种情况：</p><p><strong>1）未使用 git add 将修改文件添加到暂存区</strong> 这种情况下，可以使用以下命令来撤销所有还没有加入到缓存区的修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>需要注意，此文件不会删除新建的文件，因为新建的文件还没加入到Git管理系统重，所以对Git来说事未知的，需要手动删除。</p><p><strong>2）已使用 git add 将修改文件添加到暂存区，未使用 git commit 提交缓存</strong> 这种情况下，相当于撤销了 git add 命令对于文件修改的缓存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;filename&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的命令可以撤销指定文件的缓存，要想放弃所有文件的缓存，可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>需要注意，在使用此命令后，本地的修改并不会消失，而会回到第一种情况。要想撤销本地的修改，执行第一种情况中的命令即可。</p><p>除此之外，还可以指定返回到N次提交之前的阶段，执行以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~N</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就能退回到n个版本之前，同样不会修改本地文件的内容，这些新的内容会变成未更新到缓存区的状态。</p><p><strong>3）已使用 git commit 提交缓存</strong> 这种情况下，可以使用以下命令来回退到上一次 commit 的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>也可以使用以下命令来回退到任意版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit_id&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意，使用 git log 命令来查看 git 提交历史和 commit id。</p><h4 id="（3）恢复删除内容"><a href="#（3）恢复删除内容" class="headerlink" title="（3）恢复删除内容"></a>（3）恢复删除内容</h4><p>这是一个很重要的命令，假如你回退到某个旧版本，现在想恢复到新版本，又找不到新版本的commit id怎么办？<strong>Git</strong>提供了下面的命令用来记录每一次命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reflog show HEAD</span><br><span class="line">git reflog</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>执行之后输出如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55f3fc350b1c4b78b0785bf7da13c926~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>可以看到，最左侧黄色字体就是修改的commit id，根据这个id就可以将代码恢复到对应节点位置。HEAD@{n}表示HEAD更改历史记录，最近的操作在上面。</p><p>假如需要把代码回退到<code>HEAD@&#123;5&#125;</code>处，可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD@&#123;5&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>或者执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 8a0fd74</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>需要注意，如果有任何本地修改，该命令也会将其销毁，因此在<code>reset</code>之前建议使用<code>stash</code>将本地修改储存。</p><h3 id="2-标签操作"><a href="#2-标签操作" class="headerlink" title="2. 标签操作"></a>2. 标签操作</h3><p>标签指的是<strong>某个分支某个特定时间点的状态</strong>，通过标签可以很方便的了解到标记时的状态。</p><p>标签有两种类型 ：</p><ul><li><strong>轻量标签 ：</strong> 只是某个commit 的引用，可以理解为是一个commit的别名；</li><li><strong>附注标签 ：</strong> 存储在Git仓库中的一个完整对象，包含打标签者的名字、电子邮件地址、日期时间 以及其他的标签信息。它是可以被校验的，可以使用 GNU Privacy Guard (GPG) 签名并验证。</li></ul><h4 id="（1）展示标签"><a href="#（1）展示标签" class="headerlink" title="（1）展示标签"></a>（1）展示标签</h4><p>可以使用以下命令来获取所有标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>它会列出所有标签的名称：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c4ab437eb984639aed433d57dc3ebf8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>可以使用以下命令来查看某一个标签的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;tag_name&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04d39644c4b5441ab019b82c02be8789~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>还可以根据条件来显示标签，比如列出以<code>v1.</code>开头的所有tag：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -l <span class="string">&quot;v1.&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（2）创建标签"><a href="#（2）创建标签" class="headerlink" title="（2）创建标签"></a>（2）创建标签</h4><p>可以使用以下命令在本地创建新标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tag_name&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通常遵循的命名模式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>major（主版本号）：重大变化</li><li>minor（次要版本号）：版本与先前版本兼容</li><li>patch（补丁号）：bug修复</li></ul><p>除此之外，我们还可以为特定的commit创建标签，其命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tagname&gt; &lt;commit_sha&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上面的的形式创建的标签都属于轻量标签，下面来看看如何创建一个附注标签。</p><p>在创建标签时，可以添加一个<code>-a</code>标志以创建一个带备注的标签，备注信息使用<code>-m message</code>来指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m <span class="string">&quot;&lt;message&gt;&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（3）推送标签"><a href="#（3）推送标签" class="headerlink" title="（3）推送标签"></a>（3）推送标签</h4><p>标签创建完成之后就可以使用以下命令将其推送到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上命令会将本地所有tag都推送到远程仓库。如果想推送指定标签，可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;tagname&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（4）切换标签"><a href="#（4）切换标签" class="headerlink" title="（4）切换标签"></a>（4）切换标签</h4><p>可以使用以下命令来切换标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;tagname&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（5）删除标签"><a href="#（5）删除标签" class="headerlink" title="（5）删除标签"></a>（5）删除标签</h4><p>可以使用以下命令来删除本地仓库指定标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以使用以下命令来删除远程仓库指定标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/&lt;tagname&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>也可以使用以下命令来删除远程仓库的指定标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;tagname&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（6）拉取标签"><a href="#（6）拉取标签" class="headerlink" title="（6）拉取标签"></a>（6）拉取标签</h4><p>可以使用以下命令来将远程仓库的标签拉取（同步）到当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch --tags</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（7）检出标签"><a href="#（7）检出标签" class="headerlink" title="（7）检出标签"></a>（7）检出标签</h4><p>检出标签实际上就是在标签的基础上进行其他开发或操作。需要以标签指定的版本为基础版本，新建一个分支，继续其他的操作。执行以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt; &lt;tagname&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="3-日志记录"><a href="#3-日志记录" class="headerlink" title="3. 日志记录"></a>3. 日志记录</h3><h4 id="（1）基础日志"><a href="#（1）基础日志" class="headerlink" title="（1）基础日志"></a>（1）基础日志</h4><p>可以使用以下命令来查看分支的历史提交信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这是其最基础的用法，输出如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d9c2b544c2e4782821c9ec970b203a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>可以看到，终端上输出了该分支近期的提交记录，它包含了所有贡献者的提交。</p><h4 id="（2）按作者查看"><a href="#（2）按作者查看" class="headerlink" title="（2）按作者查看"></a>（2）按作者查看</h4><p>如果想只看某个人的提交，可以添加过滤条件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;username&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当然也可以搜索多个作者的提交信息，只需要在用|分隔用户名即可，注意需要使用\来对|进行转义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;username1\|usernmae2&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里列出的是每次提交的详细信息，如果指向看到每个提交的概要，可以在命令中添加<code>--oneline</code>标志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;username&quot;</span> --oneline</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（3）按时间查看"><a href="#（3）按时间查看" class="headerlink" title="（3）按时间查看"></a>（3）按时间查看</h4><p>除了可以按照作者来查看日志之外，还可以按照时间查看日志。可以查看某个时间之前的日志，也可以查看某个日期之后的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//某个日期之后</span><br><span class="line">git <span class="built_in">log</span> --since=&lt;date&gt;</span><br><span class="line">git <span class="built_in">log</span> --after=&lt;date&gt;</span><br><span class="line"></span><br><span class="line">//某个日期之前</span><br><span class="line">git <span class="built_in">log</span> --until=&lt;date&gt;</span><br><span class="line">git <span class="built_in">log</span> --before=&lt;date&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果想查看某个具体时间区间之间的日志，可以组合以上参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;2022.05.15&quot;</span> --until=<span class="string">&quot;2022.05.20&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（4）按文件查看"><a href="#（4）按文件查看" class="headerlink" title="（4）按文件查看"></a>（4）按文件查看</h4><p>如果我们想查看某个文件都在哪些提交中修改了内容，也是可以的。使用以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -- &lt;path&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>比如查看<code>README.md</code>文件的修改记录：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da9b0dc5d2ff4ce58ae06e0daa9bdfbc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><h4 id="（5）按合并查看"><a href="#（5）按合并查看" class="headerlink" title="（5）按合并查看"></a>（5）按合并查看</h4><p>在历史提交中可能会有很多次合并的提交记录，想要只查看代码合并的记录，可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --merges</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果想查看非合并操作的操作记录，可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --no-merges</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（6）按分支查看"><a href="#（6）按分支查看" class="headerlink" title="（6）按分支查看"></a>（6）按分支查看</h4><p>可以按照分支查看日志，如果想查看<code>test</code>分支比<code>master</code>分支多提交了哪些内容，就可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> master..test</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>相反，如果想看<code>master</code>分支比<code>test</code>分支多提交了哪些内容，就可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> test..master</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（7）美化日志"><a href="#（7）美化日志" class="headerlink" title="（7）美化日志"></a>（7）美化日志</h4><p>git log命令可以用来查看提交历史，此命令的问题在于，随着项目复杂性的增加，输出变得越来越难阅读。可以使用以下命令来美化日志的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --oneline --decorate</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>输出结果如下，这样就能看到更简洁的细分以及不同分支如何连接在一起：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81238a8420044812baf788a3b96b25e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><h4 id="（8）其他标志"><a href="#（8）其他标志" class="headerlink" title="（8）其他标志"></a>（8）其他标志</h4><p>上面我们提到了，可以使用<code>--oneline</code>标志来简化日志的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以使用<code>--stat</code>标志来简要显示文件增改行数统计，每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以添加<code>-N</code>标志来仅显示最近N次的提交，其中<code>N</code>是一个正整数，例如查看最近三次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以使用<code>-p</code>标志来展开显示每次提交的内容差异对比：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意，以上这些命令标识符都可以组合使用。</p><h3 id="4-差异对比"><a href="#4-差异对比" class="headerlink" title="4. 差异对比"></a>4. 差异对比</h3><p>git diff 命令可以用来比较文件的不同，即比较文件在<strong>暂存区</strong>和<strong>工作区</strong>的差异。</p><h4 id="（1）未缓存改动"><a href="#（1）未缓存改动" class="headerlink" title="（1）未缓存改动"></a>（1）未缓存改动</h4><p>当工作区有改动，暂存区为空时， diff对比的是工作区与最后一次commit提交的共同文件； 当工作区有改动，暂存区不为空时，diff对比的是工作区与暂存区的共同文件。</p><h4 id="（2）已缓存改动"><a href="#（2）已缓存改动" class="headerlink" title="（2）已缓存改动"></a>（2）已缓存改动</h4><p>当已缓存改动时，可以使用以下任一命令来显示暂存区（已add但未commit文件）和最后一次commit(HEAD)之间的所有不相同文件的差异对比：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br><span class="line">git diff --staged</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（3）已缓存和未缓存改动"><a href="#（3）已缓存和未缓存改动" class="headerlink" title="（3）已缓存和未缓存改动"></a>（3）已缓存和未缓存改动</h4><p>可以使用以下命令来显示工作目录(已修改但未add文件)和暂存区(已add但未commit文件)与最后一次commit之间的的所有不相同文件的差异对比：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（4）不同分支差异"><a href="#（4）不同分支差异" class="headerlink" title="（4）不同分支差异"></a>（4）不同分支差异</h4><p>可以使用以下命令来比较两个分支上最后 commit 的内容的差别：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;分支名1&gt; &lt;分支名2&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就可以显示出两个分支的详细差异，如果只是想看有哪些文件存在差异，可以在命令中添加<code>--stat</code>标志，这样就不会显示每个文件的内容的详细对比：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;分支名1&gt; &lt;分支名2&gt; --<span class="built_in">stat</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="5-定位问题"><a href="#5-定位问题" class="headerlink" title="5. 定位问题"></a>5. 定位问题</h3><p>git bisect 可以用来查找哪一次代码提交引入了错误。它的原理很简单就是将代码提交的历史使用二分法来缩小出问题的代替提交范围，确定问题出在前半部分还是后半部分，不断执行这个过程，直到找到引入问题的那一次提交。</p><p>其命令合适如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git bisect start &lt;end&gt; &lt;start&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中end就是最近的提交，start就是最开始的提交。假如第一次的提交的 commit id为685f868，总共有21次提交。那么执行以下命令，从第一次提交到最近一次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git bisect start HEAD 685f868</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>执行完之后，验证那个问题是否存在，如果发现问题不存在了，就执行以下命令来标识第11次提交是没问题的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git bisect good</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就说明前半段是没有问题的，问题出在后半段，也就是第11-21次提交中。这时再去刷新浏览器，如果问题出现了，使用以下命令来标记：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git bisect bad</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就说明第11-16次提交是有问题的。继续重复上面的步骤，直到成功找出那一次提交位为止，这时Git就会给出如下的提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c8ad045 is the first bad commit</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这时就确认了是这一次提交导致的问题，可以去查看时那些修改导致的问题。</p><p>之后就可以使用以下命令退出错误查找过程，回到最近一次代码提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git bisect reset</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="四、实用-Git-工具"><a href="#四、实用-Git-工具" class="headerlink" title="四、实用 Git 工具"></a>四、实用 Git 工具</h2><h3 id="1-GitLens"><a href="#1-GitLens" class="headerlink" title="1. GitLens"></a>1. <strong>GitLens</strong></h3><p>GitLens  是一个VS Code插件，可以用来查看项目的提交记录、文件修改记录、显示每行代码的提交记录等。通过丰富的可视化和强大的比较命令<strong>获得有价值的见解</strong>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9feb1a513be4540b26b8a2a6e36a05f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h3 id="2-Git-History"><a href="#2-Git-History" class="headerlink" title="2. Git History"></a>2. Git History</h3><p>Git History 是一个VS Code插件，增强了Git 的功能，它可以用来查看日志信息，查看和搜索历史，进行分支对比、提交对比，跨提交对比文件等。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e4db3b5036745e09f575faf3ca54b1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h3 id="3-Git-Automator"><a href="#3-Git-Automator" class="headerlink" title="3. Git Automator"></a>3. Git Automator</h3><p>Git Automator 是一个VS Code插件，主要用来自动化Git提交消息和 Git 工作流程。它允许用一个快捷方式添加和提交文件。它还为提交信息提供了自动填充功能。当动作很明显时，例如你删除了一个文件，Git Automator 会猜测该动作并将其添加到预填充的提交消息中。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cadf2e3ad99348efa9487ab64e9fc8f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h3 id="4-LearnGitBranching"><a href="#4-LearnGitBranching" class="headerlink" title="4. LearnGitBranching"></a>4. LearnGitBranching</h3><p>LearnGitBranching 是一个 git 存储库可视化工具、沙箱和一系列教程和挑战。它的主要目的是帮助开发人员通过可视化的力量来理解 git。这是通过不同级别的游戏来熟悉不同的git命令来实现的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8afa402fc74c4ea3b1f93169f06e929d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><strong>Github：</strong><a href="https://link.juejin.cn/?target=https://github.com/pcottle/learnGitBranching">github.com/pcottle/lea…</a></p><blockquote><p>本文转载自 <a href="https://juejin.cn/post/7111132724185792542">https://juejin.cn/post/7111132724185792542</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之深度优先遍历(DFS)和广度优先遍历(BFS)</title>
      <link href="post/%E7%AE%97%E6%B3%95_%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>post/%E7%AE%97%E6%B3%95_%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="JS-算法之深度优先遍历-DFS-和广度优先遍历-BFS"><a href="#JS-算法之深度优先遍历-DFS-和广度优先遍历-BFS" class="headerlink" title="JS 算法之深度优先遍历(DFS)和广度优先遍历(BFS)"></a>JS 算法之深度优先遍历(DFS)和广度优先遍历(BFS)</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>该方法是以纵向的维度对 dom 树进行遍历，从一个 dom 节点开始，一直遍历其子节点，直到它的所有子节点都被遍历完毕之后在遍历它的兄弟节点。</p><p><img src="https://segmentfault.com/img/bVbqEoQ?w=432&h=391" alt="clipboard.png"></p><p>递归实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先遍历（递归实现）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>data Array|Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">depthFirstTraverse</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> list = data <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? data : [data];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = list[i];</span><br><span class="line">    <span class="built_in">console</span>.log(node.id);</span><br><span class="line">    node.child &amp;&amp; depthFirstTraverse(node.child);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stack 实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先遍历（stack实现）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>data Array|Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">depthFirstTraverseStack</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = data <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? data : [data];</span><br><span class="line">  <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = stack.shift();</span><br><span class="line">    <span class="built_in">console</span>.log(node.id);</span><br><span class="line">    node.child &amp;&amp; stack.unshift(...node.child);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>该方法是以横向的维度对 dom 树进行遍历，从该节点的第一个子节点开始，遍历其所有的兄弟节点，再遍历第一个节点的子节点，完成该遍历之后，暂时不深入，开始遍历其兄弟节点的子节点。</p><p><img src="https://segmentfault.com/img/bVbqEv0?w=407&h=392" alt="clipboard.png"></p><p>递归实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先遍历 （递归实现）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>data Array|Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">breadthFirstTraverse</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">const</span> list = data <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? data : [data];</span><br><span class="line">  <span class="keyword">let</span> nextSibling = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> nodes = [];</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = arr[i];</span><br><span class="line">      nodes.push(node);</span><br><span class="line">      <span class="built_in">console</span>.log(node.id);</span><br><span class="line">    &#125;</span><br><span class="line">    nextSibling = nodes[index++];</span><br><span class="line">    nextSibling.child &amp;&amp; traverse(nextSibling.child);</span><br><span class="line">  &#125;</span><br><span class="line">  traverse(list);</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`广度优先遍历 （递归实现）耗时：<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - time&#125;</span>ms`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Queue 实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先遍历 （队列实现）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  </span>data Array|Object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">breadthFirstTraverseQueue</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">const</span> queue = data <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? data : [data];</span><br><span class="line">  <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">      <span class="built_in">console</span>.log(node.id);</span><br><span class="line">      node.child &amp;&amp; queue.push(...node.child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`广度优先遍历 （队列实现）耗时：<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - time&#125;</span>ms`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 深度优先遍历 </tag>
            
            <tag> 广度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript声明文件正确使用姿势</title>
      <link href="post/typescript%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
      <url>post/typescript%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="ts类型声明文件的正确使用姿势"><a href="#ts类型声明文件的正确使用姿势" class="headerlink" title="ts类型声明文件的正确使用姿势"></a>ts类型声明文件的正确使用姿势</h2><h3 id="ts声明文件类型"><a href="#ts声明文件类型" class="headerlink" title="ts声明文件类型"></a>ts声明文件类型</h3><h4 id="1-DefinitelyTyped社区已定义"><a href="#1-DefinitelyTyped社区已定义" class="headerlink" title="1. DefinitelyTyped社区已定义"></a>1. <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types">DefinitelyTyped社区</a>已定义</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure><h4 id="2-与npm一同发布"><a href="#2-与npm一同发布" class="headerlink" title="2. 与npm一同发布"></a>2. 与npm一同发布</h4><p>​      解释： package.json 中有 types 字段，或者有一个 index.d.ts 声明文件</p><h4 id="3-自给自足型"><a href="#3-自给自足型" class="headerlink" title="3. 自给自足型"></a>3. 自给自足型</h4><p>创建一个 node_modules/@types/foo/index.d.ts 文件，存放 foo 模块的声明文件。不太建议用这种方案，一般只用作临时测试。<br>创建一个 types 目录，专门用来管理自己写的声明文件，将 foo 的声明文件放到 types/foo/index.d.ts 中。这种方式需要配置下 tsconfig.json 中的 paths 和 baseUrl 字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/path/to/project</span><br><span class="line">  ├── src</span><br><span class="line">  |  └── index.ts</span><br><span class="line">  ├── types</span><br><span class="line">  |  └── foo</span><br><span class="line">  |     └── index.d.ts</span><br><span class="line">  └── tsconfig.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;paths&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;*&quot;</span>: [<span class="string">&quot;types/*&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ts声明文件书写姿势"><a href="#ts声明文件书写姿势" class="headerlink" title="ts声明文件书写姿势"></a>ts声明文件书写姿势</h3><h4 id="1-全局型"><a href="#1-全局型" class="headerlink" title="1. 全局型"></a>1. 全局型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">let</span> </span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> jQuery: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"># <span class="function"><span class="keyword">function</span> </span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="title">any</span></span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#<span class="title">class</span> </span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="built_in">enum</span></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">namespace</span> </span><br><span class="line">declare <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">    <span class="keyword">namespace</span> fn &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params"><span class="built_in">object</span>: <span class="built_in">any</span></span>): <span class="title">void</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-npm包型-export"><a href="#2-npm包型-export" class="headerlink" title="2. npm包型 - export"></a>2. npm包型 - export</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Options &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">namespace</span> bar &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-npm包型-export-default"><a href="#3-npm包型-export-default" class="headerlink" title="3. npm包型 - export default"></a>3. npm包型 - export default</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"># <span class="function"><span class="keyword">function</span>、<span class="title">class</span> 和 <span class="title">interface</span> 可以直接默认导出，其他的变量需要先定义出来，再默认导出</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">string</span></span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">default</span> <span class="title">Directions</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-npm包型-先声明，在export"><a href="#4-npm包型-先声明，在export" class="headerlink" title="4. npm包型 - 先声明，在export"></a>4. npm包型 - 先声明，在export</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> name: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    sayHi(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line">#<span class="keyword">interface</span> 前是不需要 declare</span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, getName, Animal, Directions, Options &#125;;</span><br></pre></td></tr></table></figure><h4 id="5-module-拓展"><a href="#5-module-拓展" class="headerlink" title="5. module 拓展"></a>5. module 拓展</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo-bar.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">module</span> <span class="string">&#x27;foo&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> Foo &#123;</span><br><span class="line">        <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">module</span> <span class="string">&#x27;bar&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>): <span class="title">string</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Foo &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f: Foo;</span><br><span class="line">bar.bar();</span><br></pre></td></tr></table></figure><h4 id="6-三斜线指令"><a href="#6-三斜线指令" class="headerlink" title="6. 三斜线指令"></a>6. 三斜线指令</h4><ul><li>书写一个全局变量的声明文件</li><li>依赖一个全局变量的声明文件</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/jquery-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;jquery&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">options: JQuery.AjaxSettings</span>): <span class="title">string</span></span>;</span><br></pre></td></tr></table></figure><h4 id="7-ts文件tsc自动生成声明文件"><a href="#7-ts文件tsc自动生成声明文件" class="headerlink" title="7. ts文件tsc自动生成声明文件"></a>7. ts文件tsc自动生成声明文件</h4><ul><li>命令行参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--declaration（简写 -d）</span><br></pre></td></tr></table></figure><h4 id="8-ts发布"><a href="#8-ts发布" class="headerlink" title="8. ts发布"></a>8. ts发布</h4><ul><li>发布到社区</li></ul><blockquote><p>@types 是统一由 DefinitelyTyped 管理的。要将声明文件发布到 @types 下，就需要给 DefinitelyTyped 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 tsconfig.json 等。</p></blockquote><ul><li><p>与源码一起（依次查找*.d.ts）</p><ol><li><p>给 package.json 中的 types 或 typings 字段指定一个类型声明文件地址</p></li><li><p>在项目根目录下，编写一个 index.d.ts 文件</p></li><li><p>针对入口文件（package.json 中的 main 字段指定的入口文件），编写一个同名不同后缀的 .d.ts 文件</p></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> typescirpt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3+typescript+eslint+prettier 规范代码</title>
      <link href="post/vue3+ts+eslint+prettier/"/>
      <url>post/vue3+ts+eslint+prettier/</url>
      
        <content type="html"><![CDATA[<h2 id="Vite项目初始化"><a href="#Vite项目初始化" class="headerlink" title="Vite项目初始化"></a>Vite项目初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm create vite</span><br></pre></td></tr></table></figure><p>选择vue3+ts</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><ul><li>安装typescript及其插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add -D typescript  @typescript-eslint/eslint-plugin @typescript-eslint/parser</span><br></pre></td></tr></table></figure><blockquote><p>typescript : typescript 核心库</p><p>@typescript-eslint/eslint-plugin: 这是一个ESLint插件，包含了各类定义好的检测Typescript代码的规范</p><p>@typescript-eslint/parser：ESLint的解析器，用于解析typescript，从而检查和规范Typescript代码</p></blockquote><ul><li>安装eslint及其插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add -D eslint eslint-plugin-vue eslint-plugin-prettier eslint-config-prettier eslint-define-config vue-eslint-parser</span><br></pre></td></tr></table></figure><blockquote><p>eslint: elint核心库</p><p>eslint-plugin-vue: This plugin allows us to check the <code>&lt;template&gt;</code> and <code>&lt;script&gt;</code> of <code>.vue</code> files with ESLint, as well as Vue code in <code>.js</code> files.</p><p>eslint-config-prettier: 解决ESlint中的样式规范和prettier中样式规范的冲突，以prettier的样式规范为准，使    用ESlint中的样式规范自动失效</p><p>eslint-plugin-prettier: 将prettier做为ESlint rules来使用</p><p>eslint-define-config:  编写.eslint.js文件时，用其暴露的defineConfig()，有提示。（此插件可有可无）</p><p>vue-eslint-parser：This parser allows us to lint the <code>&lt;template&gt;</code> of <code>.vue</code> files. （<a href="https://www.npmjs.com/package/vue-eslint-parser%EF%BC%89">https://www.npmjs.com/package/vue-eslint-parser）</a></p></blockquote><h2 id="创建-eslintrc-js文件"><a href="#创建-eslintrc-js文件" class="headerlink" title="创建.eslintrc.js文件"></a>创建.eslintrc.js文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eslint-disable-next-line @typescript-eslint/no-var-requires</span></span><br><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;eslint-define-config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">es2021</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">parser</span>: <span class="string">&#x27;vue-eslint-parser&#x27;</span>,<span class="comment">// 用来编译 &lt;template&gt; 标签里的代码</span></span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">parser</span>: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>, <span class="comment">// 用来编译 &lt;script&gt; 标签里的ts代码</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">globals</span>: &#123;</span><br><span class="line">    <span class="comment">// script setup</span></span><br><span class="line">    <span class="attr">defineProps</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">    <span class="attr">defineEmits</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">    <span class="attr">defineExpose</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">    <span class="attr">withDefaults</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;plugin:vue/base&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:vue/vue3-recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:@typescript-eslint/recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:prettier/recommended&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;prettier&#x27;</span>],</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">// 自定义你的规则</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建-prettierrc-js"><a href="#创建-prettierrc-js" class="headerlink" title="创建 .prettierrc.js"></a>创建 .prettierrc.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .prettierrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 一行最多 120 字符</span></span><br><span class="line">  <span class="attr">printWidth</span>: <span class="number">120</span>,</span><br><span class="line">  <span class="comment">// 使用 2 个空格缩进</span></span><br><span class="line">  <span class="attr">tabWidth</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 不使用缩进符，而使用空格</span></span><br><span class="line">  <span class="attr">useTabs</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 行尾需要有分号</span></span><br><span class="line">  <span class="attr">semi</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 使用单引号</span></span><br><span class="line">  <span class="attr">singleQuote</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 对象的 key 仅在必要时用引号</span></span><br><span class="line">  <span class="attr">quoteProps</span>: <span class="string">&#x27;as-needed&#x27;</span>,</span><br><span class="line">  <span class="comment">// jsx 不使用单引号，而使用双引号</span></span><br><span class="line">  <span class="attr">jsxSingleQuote</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 末尾需要有逗号</span></span><br><span class="line">  <span class="attr">trailingComma</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">  <span class="comment">// 大括号内的首尾需要空格</span></span><br><span class="line">  <span class="attr">bracketSpacing</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// jsx 标签的反尖括号需要换行</span></span><br><span class="line">  <span class="attr">bracketSameLine</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 箭头函数，只有一个参数的时候，也需要括号</span></span><br><span class="line">  <span class="attr">arrowParens</span>: <span class="string">&#x27;always&#x27;</span>,</span><br><span class="line">  <span class="comment">// 每个文件格式化的范围是文件的全部内容</span></span><br><span class="line">  <span class="attr">rangeStart</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">rangeEnd</span>: <span class="literal">Infinity</span>,</span><br><span class="line">  <span class="comment">// 不需要写文件开头的 @prettier</span></span><br><span class="line">  <span class="attr">requirePragma</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 不需要自动在文件开头插入 @prettier</span></span><br><span class="line">  <span class="attr">insertPragma</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 使用默认的折行标准</span></span><br><span class="line">  <span class="attr">proseWrap</span>: <span class="string">&#x27;preserve&#x27;</span>,</span><br><span class="line">  <span class="comment">// 根据显示样式决定 html 要不要折行</span></span><br><span class="line">  <span class="attr">htmlWhitespaceSensitivity</span>: <span class="string">&#x27;css&#x27;</span>,</span><br><span class="line">  <span class="comment">// vue 文件中的 script 和 style 内不用缩进</span></span><br><span class="line">  <span class="attr">vueIndentScriptAndStyle</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 换行符使用 lf</span></span><br><span class="line">  <span class="attr">endOfLine</span>: <span class="string">&#x27;lf&#x27;</span>,</span><br><span class="line">  <span class="comment">// 格式化内嵌代码</span></span><br><span class="line">  <span class="attr">embeddedLanguageFormatting</span>: <span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> eslint </tag>
            
            <tag> prettier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript_泛型</title>
      <link href="post/typescript-%E6%B3%9B%E5%9E%8B/"/>
      <url>post/typescript-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="一、泛型是什么"><a href="#一、泛型是什么" class="headerlink" title="一、泛型是什么"></a>一、泛型是什么</h3><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p><strong>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</strong></p><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p><p>为了便于大家更好地理解上述的内容，我们来举个例子，在这个例子中，我们将一步步揭示泛型的作用。首先我们来定义一个通用的 <code>identity</code> 函数，该函数接收一个参数并直接返回它：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity(<span class="number">1</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>现在，我们将 <code>identity</code> 函数做适当的调整，以支持 TypeScript 的 Number 类型的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> (<span class="params">value: <span class="built_in">Number</span></span>) : <span class="title">Number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity(<span class="number">1</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这里 <code>identity</code> 的问题是我们将 <code>Number</code> 类型分配给参数和返回类型，使该函数仅可用于该原始类型。但该函数并不是可扩展或通用的，很明显这并不是我们所希望的。</p><p>我们确实可以把 <code>Number</code> 换成 <code>any</code>，我们失去了定义应该返回哪种类型的能力，并且在这个过程中使编译器失去了类型保护的作用。我们的目标是让 <code>identity</code> 函数可以适用于任何特定的类型，为了实现这个目标，我们可以使用泛型来解决这个问题，具体实现方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity&lt;<span class="built_in">Number</span>&gt;(<span class="number">1</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>对于刚接触 TypeScript 泛型的读者来说，首次看到 <code>&lt;T&gt;</code> 语法会感到陌生。但这没什么可担心的，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/10/1729b3d9774a21ac~tplv-t2oaga2asx-watermark.awebp" alt="generic-type-filled"></p><p>参考上面的图片，当我们调用 <code>identity&lt;Number&gt;(1)</code> ，<code>Number</code> 类型就像参数 <code>1</code> 一样，它将在出现 <code>T</code> 的任何位置填充该类型。图中 <code>&lt;T&gt;</code> 内部的 <code>T</code> 被称为类型变量，它是我们希望传递给 identity 函数的类型占位符，同时它被分配给 <code>value</code> 参数用来代替它的类型：此时 <code>T</code> 充当的是类型，而不是特定的 Number 类型。</p><p>其中 <code>T</code> 代表 <strong>Type</strong>，在定义泛型时通常用作第一个类型变量名称。但实际上 <code>T</code> 可以用任何有效名称代替。除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p><ul><li>K（Key）：表示对象中的键类型；</li><li>V（Value）：表示对象中的值类型；</li><li>E（Element）：表示元素类型。</li></ul><p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity&lt;<span class="built_in">Number</span>, <span class="built_in">string</span>&gt;(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/10/1729b3dbccc38ea7~tplv-t2oaga2asx-watermark.awebp" alt="generic-multi-type-filled"></p><p>除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对于上述代码，编译器足够聪明，能够知道我们的参数类型，并将它们赋值给 T 和 U，而不需要开发人员显式指定它们。下面我们来看张动图，直观地感受一下类型传递的过程：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/10/1729b3d9773f34ad~tplv-t2oaga2asx-watermark.awebp" alt="generic-type-filled"></p><p>如你所见，该函数接收你传递给它的任何类型，使得我们可以为不同类型创建可重用的组件。现在我们再来看一下 <code>identity</code> 函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相比之前定义的 <code>identity</code> 函数，新的 <code>identity</code> 函数增加了一个类型变量 <code>U</code>，但该函数的返回类型我们仍然使用 <code>T</code>。如果我们想要返回两种类型的对象该怎么办呢？针对这个问题，我们有多种方案，其中一种就是使用元组，即为元组设置通用的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : [<span class="title">T</span>, <span class="title">U</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [value, message];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然使用元组解决了上述的问题，但有没有其它更好的方案呢？答案是有的，你可以使用泛型接口。</p><h3 id="二、泛型接口"><a href="#二、泛型接口" class="headerlink" title="二、泛型接口"></a>二、泛型接口</h3><p>为了解决上面提到的问题，首先让我们创建一个用于的 <code>identity</code> 函数通用 <code>Identities</code> 接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Identities&lt;V, M&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: V,</span><br><span class="line">  <span class="attr">message</span>: M</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述的 <code>Identities</code> 接口中，我们引入了类型变量 <code>V</code> 和 <code>M</code>，来进一步说明有效的字母都可以用于表示类型变量，之后我们就可以将 <code>Identities</code> 接口作为 <code>identity</code> 函数的返回类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; (<span class="params">value: T, message: U</span>): <span class="title">Identities</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value + <span class="string">&quot;: &quot;</span> + <span class="keyword">typeof</span> (value));</span><br><span class="line">  <span class="built_in">console</span>.log(message + <span class="string">&quot;: &quot;</span> + <span class="keyword">typeof</span> (message));</span><br><span class="line">  <span class="keyword">let</span> identities: Identities&lt;T, U&gt; = &#123;</span><br><span class="line">    value,</span><br><span class="line">    message</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> identities;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br></pre></td></tr></table></figure><p>以上代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">68</span>: <span class="built_in">number</span></span><br><span class="line"><span class="attr">Semlinker</span>: <span class="built_in">string</span></span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">68</span>, <span class="attr">message</span>: <span class="string">&quot;Semlinker&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>泛型除了可以应用在函数和接口之外，它也可以应用在类中，下面我们就来看一下在类中如何使用泛型。</p><h3 id="三、泛型类"><a href="#三、泛型类" class="headerlink" title="三、泛型类"></a>三、泛型类</h3><p>在类中使用泛型也很简单，我们只需要在类名后面，使用 <code>&lt;T, ...&gt;</code> 的语法定义任意多个类型变量，具体示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericInterface&lt;U&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: U</span><br><span class="line">  <span class="attr">getIdentity</span>: <span class="function">() =&gt;</span> U</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdentityClass</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="attr">value</span>: T</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value: T</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getIdentity(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myNumberClass = <span class="keyword">new</span> IdentityClass&lt;<span class="built_in">Number</span>&gt;(<span class="number">68</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myNumberClass.getIdentity()); <span class="comment">// 68</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myStringClass = <span class="keyword">new</span> IdentityClass&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Semlinker!&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myStringClass.getIdentity()); <span class="comment">// Semlinker!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们以实例化 <code>myNumberClass</code> 为例，来分析一下其调用过程：</p><ul><li>在实例化 <code>IdentityClass</code> 对象时，我们传入 <code>Number</code> 类型和构造函数参数值 <code>68</code>；</li><li>之后在 <code>IdentityClass</code> 类中，类型变量 <code>T</code> 的值变成 <code>Number</code> 类型；</li><li><code>IdentityClass</code> 类实现了 <code>GenericInterface&lt;T&gt;</code>，而此时 <code>T</code> 表示 <code>Number</code> 类型，因此等价于该类实现了 <code>GenericInterface&lt;Number&gt;</code> 接口；</li><li>而对于 <code>GenericInterface&lt;U&gt;</code> 接口来说，类型变量 <code>U</code> 也变成了 <code>Number</code>。这里我有意使用不同的变量名，以表明类型值沿链向上传播，且与变量名无关。</li></ul><p>泛型类可确保在整个类中一致地使用指定的数据类型。比如，你可能已经注意到在使用 Typescript 的 React 项目中使用了以下约定：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  className?: <span class="built_in">string</span></span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> State = &#123;</span><br><span class="line">  submitted?: bool</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">Props</span>, <span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在以上代码中，我们将泛型与 React 组件一起使用，以确保组件的 props 和 state 是类型安全的。</p><p>相信看到这里一些读者会有疑问，我们在什么时候需要使用泛型呢？通常在决定是否使用泛型时，我们有以下两个参考标准：</p><ul><li>当你的函数、接口或类将处理多种数据类型时；</li><li>当函数、接口或类在多个地方使用该数据类型时。</li></ul><p>很有可能你没有办法保证在项目早期就使用泛型的组件，但是随着项目的发展，组件的功能通常会被扩展。这种增加的可扩展性最终很可能会满足上述两个条件，在这种情况下，引入泛型将比复制组件来满足一系列数据类型更干净。</p><p>我们将在本文的后面探讨更多满足这两个条件的用例。不过在这样做之前，让我们先介绍一下 Typescript 泛型提供的其他功能。</p><h3 id="四、泛型约束"><a href="#四、泛型约束" class="headerlink" title="四、泛型约束"></a>四、泛型约束</h3><p>有时我们可能希望限制每个类型变量接受的类型数量，这就是泛型约束的作用。下面我们来举几个例子，介绍一下如何使用泛型约束。</p><h4 id="4-1-确保属性存在"><a href="#4-1-确保属性存在" class="headerlink" title="4.1 确保属性存在"></a>4.1 确保属性存在</h4><p>有时候，我们希望类型变量对应的类型上存在某些属性。这时，除非我们显式地将特定属性定义为类型变量，否则编译器不会知道它们的存在。</p><p>一个很好的例子是在处理字符串或数组时，我们会假设 <code>length</code> 属性是可用的。让我们再次使用 <code>identity</code> 函数并尝试输出参数的长度：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length); <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这种情况下，编译器将不会知道 <code>T</code> 确实含有 <code>length</code> 属性，尤其是在可以将任何类型赋给类型变量 <code>T</code> 的情况下。我们需要做的就是让类型变量 <code>extends</code> 一个含有我们所需属性的接口，比如这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Length &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Length</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length); <span class="comment">// 可以获取length属性</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>T extends Length</code> 用于告诉编译器，我们支持已经实现 <code>Length</code> 接口的任何类型。之后，当我们使用不含有 <code>length</code> 属性的对象作为参数调用  <code>identity</code> 函数时，TypeScript 会提示相关的错误信息：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">identity(<span class="number">68</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// Argument of type &#x27;68&#x27; is not assignable to parameter of type &#x27;Length&#x27;.(2345)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外，我们还可以使用 <code>,</code> 号来分隔多种约束类型，比如：<code>&lt;T extends Length, Type2, Type3&gt;</code>。而对于上述的 <code>length</code> 属性问题来说，如果我们显式地将变量设置为数组类型，也可以解决该问题，具体方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(arg.length);  </span><br><span class="line">   <span class="keyword">return</span> arg; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;      </span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-检查对象上的键是否存在"><a href="#4-2-检查对象上的键是否存在" class="headerlink" title="4.2 检查对象上的键是否存在"></a>4.2 检查对象上的键是否存在</h4><p>泛型约束的另一个常见的使用场景就是检查对象上的键是否存在。不过在看具体示例之前，我们得来了解一下 <code>keyof</code> 操作符，**<code>keyof</code> 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。** “耳听为虚，眼见为实”，我们来举个 <code>keyof</code> 的使用示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  location: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> K1 = keyof Person; <span class="comment">// &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span></span><br><span class="line"><span class="keyword">type</span> K2 = keyof Person[];  <span class="comment">// number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...</span></span><br><span class="line"><span class="keyword">type</span> K3 = keyof &#123; [x: <span class="built_in">string</span>]: Person &#125;;  <span class="comment">// string | number</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 <code>keyof</code> 操作符，我们就可以获取指定类型的所有键，之后我们就可以结合前面介绍的 <code>extends</code> 约束，即限制输入的属性名包含在 <code>keyof</code> 返回的联合类型中。具体的使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在以上的 <code>getProperty</code> 函数中，我们通过 <code>K extends keyof T</code> 确保参数 key 一定是对象中含有的键，这样就不会发生运行时错误。这是一个类型安全的解决方案，与简单调用 <code>let value = obj[key];</code> 不同。</p><p>下面我们来看一下如何使用 <code>getProperty</code> 函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Difficulty &#123;</span><br><span class="line">  Easy,</span><br><span class="line">  Intermediate,</span><br><span class="line">  Hard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tsInfo = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;Typescript&quot;</span>,</span><br><span class="line">   <span class="attr">supersetOf</span>: <span class="string">&quot;Javascript&quot;</span>,</span><br><span class="line">   <span class="attr">difficulty</span>: Difficulty.Intermediate</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> difficulty: Difficulty = </span><br><span class="line">  getProperty(tsInfo, <span class="string">&#x27;difficulty&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> supersetOf: <span class="built_in">string</span> = </span><br><span class="line">  getProperty(tsInfo, <span class="string">&#x27;superset_of&#x27;</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>在以上示例中，对于 <code>getProperty(tsInfo, &#39;superset_of&#39;)</code> 这个表达式，TypeScript 编译器会提示以下错误信息：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Argument <span class="keyword">of</span> <span class="keyword">type</span> <span class="string">&#x27;&quot;superset_of&quot;&#x27;</span> is not assignable to parameter <span class="keyword">of</span> <span class="keyword">type</span> </span><br><span class="line"><span class="string">&#x27;&quot;difficulty&quot; | &quot;name&quot; | &quot;supersetOf&quot;&#x27;</span>.(<span class="number">2345</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很明显通过使用泛型约束，在编译阶段我们就可以提前发现错误，大大提高了程序的健壮性和稳定性。接下来，我们来介绍一下泛型参数默认类型。</p><h3 id="五、泛型参数默认类型"><a href="#五、泛型参数默认类型" class="headerlink" title="五、泛型参数默认类型"></a>五、泛型参数默认类型</h3><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推断出类型时，这个默认类型就会起作用。</p><p>泛型参数默认类型与普通函数默认值类似，对应的语法很简单，即 <code>&lt;T=Default Type&gt;</code>，对应的使用示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A&lt;T=string&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strA: A = &#123; <span class="attr">name</span>: <span class="string">&quot;Semlinker&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> numB: A&lt;<span class="built_in">number</span>&gt; = &#123; <span class="attr">name</span>: <span class="number">101</span> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>泛型参数的默认类型遵循以下规则：</p><ul><li>有默认类型的类型参数被认为是可选的。</li><li>必选的类型参数不能在可选的类型参数后。</li><li>如果类型参数有约束，类型参数的默认类型必须满足这个约束。</li><li>当指定类型实参时，你只需要指定必选类型参数的类型实参。 未指定的类型参数会被解析为它们的默认类型。</li><li>如果指定了默认类型，且类型推断无法选择一个候选类型，那么将使用默认类型作为推断结果。</li><li>一个被现有类或接口合并的类或者接口的声明可以为现有类型参数引入默认类型。</li><li>一个被现有类或接口合并的类或者接口的声明可以引入新的类型参数，只要它指定了默认类型。</li></ul><p>转载自：<a href="https://juejin.cn/post/6844904184894980104">https://juejin.cn/post/6844904184894980104</a></p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前端工程化</title>
      <link href="post/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
      <url>post/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>狭义上的理解：</strong>将开发阶段的代码发布到生产环境，包含：构建，分支管理，自动化测试，部署</p><p><strong>广义上理解：</strong>前端工程化应该包含从编码开始到发布，运行和维护阶段</p><p>也有人把 <strong>前端工程化</strong> 等同于 <strong>效率工程</strong></p><p>认为一切能提升前端开发效率、提高前端应用质量的方法和工具都是前端工程化，我觉得这么理解也是没有问题的，提升开发效率、提升产品质量、降低开发难度、降低企业成本应该是工程化的意义所在。</p><p><img src="https://pic1.zhimg.com/80/v2-6d8a4d2618cd852c780d35847b0b27ab_1440w.jpg?source=1940ef5c"></p><p>另外一个就是前端工程化不是具体的某项技术和方法，公司的组织架构、产品形态、所处的阶段不同可能工程化具体的方法和实践完全不一样，那么从我的角度，简单把工程化划分了5部分：开发、构建、部署、性能、规范化， 对于分类和具体包含的项或许你不一定认同，但是如果所有的知识点你都很熟悉和掌握，那么你的前端工程化水平绝对是中高级的。</p><p><img src="https://pic2.zhimg.com/80/v2-e1ac6afa6b0b11ae344728fa451472b0_1440w.jpg?source=1940ef5c" alt="img"></p><p><img src="https://pica.zhimg.com/80/v2-c4050cd0668ae0e487557ade3e338ca5_1440w.jpg?source=1940ef5c" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-58400269d9247f458b55edfc17eb5b01_1440w.jpg?source=1940ef5c" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nuxt集成axios</title>
      <link href="post/nuxt%E8%87%B3axios%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/"/>
      <url>post/nuxt%E8%87%B3axios%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="nuxt集成axios"><a href="#nuxt集成axios" class="headerlink" title="nuxt集成axios"></a>nuxt集成axios</h2><ol><li><p>添加@nuxt/axios模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nuxt.config.js</span></span><br><span class="line"><span class="attr">modules</span>: [</span><br><span class="line">    <span class="comment">// https://go.nuxtjs.dev/axios</span></span><br><span class="line">    <span class="string">&#x27;@nuxtjs/axios&#x27;</span>,</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li><li><p>创建 plugins/axios.js 文件,并且添加到nuxt.config.js   plugins 部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/axios.js</span></span><br><span class="line"><span class="comment">// 在这个文件扩展axios</span></span><br><span class="line"><span class="comment">// 比如拦截器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">&#123; $axios, redirect &#125;</span>) </span>&#123;</span><br><span class="line">  $axios.onRequest(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Making request to &#x27;</span> + config.baseURL)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  $axios.onError(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>, error.config)</span><br><span class="line">    <span class="keyword">const</span> code = <span class="built_in">parseInt</span>(error.response &amp;&amp; error.response.status)</span><br><span class="line">    <span class="keyword">if</span> (code === <span class="number">400</span>) &#123;</span><br><span class="line">      redirect(<span class="string">&#x27;/400&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>开发环境设置</p><p>package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">   <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development nuxt&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;cross-env BASE_URL=https://www.fastmock.site/mock/f439fbc065d4f2589540eb4c13c98c0d/api NODE_ENV=production nuxt start&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;cross-env BASE_URL=https://www.fastmock.site/mock/f439fbc065d4f2589540eb4c13c98c0d/api NODE_ENV=production nuxt build&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;generate&quot;</span>: <span class="string">&quot;cross-env BASE_URL=https://www.fastmock.site/mock/f439fbc065d4f2589540eb4c13c98c0d/api NODE_ENV=production nuxt generate&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;lint:js&quot;</span>: <span class="string">&quot;eslint --ext \&quot;.js,.vue\&quot; --ignore-path .gitignore .&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;yarn lint:js&quot;</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>nuxt.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">env: &#123;</span><br><span class="line">    <span class="attr">baseURL</span>: process.env.BASE_URL, <span class="comment">// 通过cross-env 传入</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">axios</span>: &#123;</span><br><span class="line">    <span class="attr">baseURL</span>: process.env.BASE_URL, <span class="comment">// api请求baseURL </span></span><br><span class="line">    <span class="attr">proxy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">prefix</span>: <span class="string">&#x27;/api&#x27;</span>,</span><br><span class="line">    <span class="attr">credentials</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">target</span>:</span><br><span class="line">        <span class="string">&#x27;https://www.fastmock.site/mock/aad51ea8550cdcd9b4dfa07f8f812ae3/api&#x27;</span>,</span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;/api&#x27;</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>api统一放在plugin/api.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">&#123; app, $axios, redirect &#125;, inject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> API = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  API.getUserInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;/getUserInfo&#x27;</span>,</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  app.api = API</span><br><span class="line">  inject(<span class="string">&#x27;api&#x27;</span>, API)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>axios 使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;nuxt-link to=&quot;/about&quot;&gt;关于&lt;/nuxt-link&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; userInfo.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; userInfo.age &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; userInfo.sex &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; userInfo.tel &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  async asyncData(&#123; $axios, app, store, $api, $nuxt &#125;) &#123;</span><br><span class="line">    // console.log($api)</span><br><span class="line">    console.log(process.env.BASE_URL)</span><br><span class="line">    const &#123; data &#125; = await $api.getUserInfo()</span><br><span class="line">    console.log(data)</span><br><span class="line">    return &#123;</span><br><span class="line">      userInfo: data.data,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 1,</span><br><span class="line">      userInfo: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  async fetch(&#123; $axios, app, store, $api, $nuxt &#125;) &#123;</span><br><span class="line">    // console.log($api)</span><br><span class="line">    // if (process.server) &#123;</span><br><span class="line">    // const &#123; data &#125; = await $api.getPublicKey()</span><br><span class="line">    // console.log(data)</span><br><span class="line">    // &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> nuxt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nuxt </tag>
            
            <tag> axios </tag>
            
            <tag> cross-dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密与哈希</title>
      <link href="post/%E5%93%88%E5%B8%8C%E5%92%8C%E5%8A%A0%E5%AF%86/"/>
      <url>post/%E5%93%88%E5%B8%8C%E5%92%8C%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h3><p>首先就概念上来说：hash是将目标文本转换成具有相同长度的、不可逆的杂凑字符串，Encrypt是将目标文本转换成不同长度的、可逆的密文。从概念上可以看出两者的区别，下面就不做具体的阐述了。举个例子标明两者的区别：</p><p>hash相当于做一份香喷喷的米饭。从将米饭和水放入电饭锅开始，在应用散列函数（混合、煮）之后，在一定时间后会得到一锅米饭。逆转的话是你不能将米饭分解成大米和水，你不能知道放入了多少大米和水，因为这些被三列功能破坏了。理论上，许多不同的输入变量产生相同的米饭，但如果给出其中一个，你就无法确定知道是什么输入产生了它。</p><p>而对于加密来说，相对简单些，把加密看作是一个保险箱，不管你用什么方法放进去，只有你拥有这把钥匙，你就会能拿出来，这个是对称的操作，给定一个键和输入，就会得到特点的输出。给定输出和相同的键，就会得到输入，这里的键可以看作是salt。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/img_convert/9d62976173785c964df64535043a8b71.png" alt="9d62976173785c964df64535043a8b71"></h3><p>从数学角度讲，哈希和加密都是一个映射。下面正式定义两者：</p><p>  <strong>一个哈希算法</strong><br>$$<br>R=H(S)<br>$$<br>是一个多对一映射，给定目标文本S，H可以将其唯一映射为R，并且对于所有S，R具有相同的长度。由于是多对一映射，所以H不存在逆映射使得R转换为唯一的S。<br>$$<br>S=H^{-1}(R)<br>$$</p><p><strong>一个加密算法</strong><br>$$<br>R=E(S,K_E)<br>$$<br>是一个一一映射，其中第二个参数叫做加密密钥，E可以将给定的明文S结合加密密钥Ke唯一映射为密文R，并且存在另一个一一映射，可以结合Kd将密文R唯一映射为对应明文S，其Kd叫做解密密钥。<br>$$<br>S=D(R,K_D)<br>$$</p><h3 id="选择应用"><a href="#选择应用" class="headerlink" title="选择应用"></a><strong>选择应用</strong></h3><p>在选择使用hash还是Encrypt基本原则是：如果被保护数据仅仅用作比较验证，在以后不需要还原成明文形式，则使用哈希；如果被保护数据在以后需要被还原成明文，则需要使用加密。目前常用的hash包括但不限于MD5，SHA1，SHA256；加密包括但不限于DES，TDES，AES，RSA等。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="post/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>post/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p><strong>在不断的操作中（键盘输入，点击，窗口resize等）最终只执行一次的一种提高性能的方法</strong> （setTimeout，clearTimeout）</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fun,time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      clearTimeouot(timer)</span><br><span class="line">      <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        fun.apply(<span class="built_in">this</span>,args)</span><br><span class="line">      &#125;,time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>在不断的高频操作中（鼠标滚动加载等），只能在规定的时间内执行一次的一种提高性能的方法</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fun,time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime())/<span class="number">1000</span> <span class="comment">// 初始时间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> end = (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime())/<span class="number">1000</span>  <span class="comment">// 结束时间</span></span><br><span class="line">     <span class="keyword">if</span>(end- start&gt;time)&#123;</span><br><span class="line">       fun.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">       start = end</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 防抖 </tag>
            
            <tag> 节流 </tag>
            
            <tag> debounce </tag>
            
            <tag> throttle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法—动态规划求最大子序列和</title>
      <link href="post/%E7%AE%97%E6%B3%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>post/%E7%AE%97%E6%B3%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><strong>题目：给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</strong></p><p><strong>思路和算法</strong></p><p>假设 <code>nums</code> 数组的长度是 <code>n</code>，下标从 <code>0</code>到 <code>n-1</code>。</p><p>我们用 <code>f(i)</code>代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：</p><p>$$<br>\max_{0 \leq i \leq n-1} { f(i) }<br>$$<br>因此我们只需要求出每个位置的 <code>f(i)</code>，然后返回 <code>f</code>数组中的最大值即可。那么我们如何求 <code>f(i)</code> 呢？我们可以考虑 <code>nums[i]</code> 单独成为一段还是加入 <code>f(i-1)</code>对应的那一段，这取决于 <code>nums[i]</code> 和 <code>f(i-1)+nums[i]</code> 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：</p><p>$$<br>f(i) = \max { f(i-1) + \textit{nums}[i], \textit{nums}[i] }<br>$$<br>不难给出一个时间复杂度 <code>O(n)</code>、空间复杂度 <code>O(n)</code>的实现，即用一个 <code>f</code>数组来保存 <code>f(i)</code> 的值，用一个循环求出所有 <code>f(i)</code>。考虑到 <code>f(i)</code> 只和 <code>f(i-1)</code> 相关，于是我们可以只用一个变量 <code>pre</code> 来维护对于当前 <code>f(i)</code> 的 <code>f(i−1)</code> 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxSum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        pre = <span class="built_in">Math</span>.max(pre + num, num)</span><br><span class="line">        maxSum = <span class="built_in">Math</span>.max(pre, maxSum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法—贪心算法求最大子序列和</title>
      <link href="post/%E7%AE%97%E6%B3%95_%E8%B4%AA%E5%BF%83%E6%B3%95/"/>
      <url>post/%E7%AE%97%E6%B3%95_%E8%B4%AA%E5%BF%83%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>题目：给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</strong></p><p><strong>思路和算法</strong></p><p>从左向右迭代，一个数一个数加过去，如果 <code>sum &lt; 0</code>，则重新开始找子序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = function (nums) &#123;</span><br><span class="line">    let sum = <span class="number">0</span></span><br><span class="line">    let ans = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (num of nums) &#123;</span><br><span class="line">        sum += num</span><br><span class="line">        ans = Math.max(sum, ans)</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法—摩尔投票法</title>
      <link href="post/%E7%AE%97%E6%B3%95_%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/"/>
      <url>post/%E7%AE%97%E6%B3%95_%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>题目：给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。</strong></p><h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><p><strong>摩尔投票法：摩尔投票法的核心思想为对拼消耗</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 摩尔投票法</span></span><br><span class="line">    <span class="comment">// 找出数组中元素出现过的次数 &gt; 数组长度/3 的元素</span></span><br><span class="line">    <span class="comment">// 1/2 至多出现1个</span></span><br><span class="line">    <span class="comment">// 1/3 至多出现2个</span></span><br><span class="line">    <span class="comment">// 1/m 至多出现 m-1 个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ele1 = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> ele2 = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> vote1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> vote2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num === ele1) &#123;</span><br><span class="line">            vote1++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num === ele2) &#123;</span><br><span class="line">            vote2++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vote1 === <span class="number">0</span>) &#123;</span><br><span class="line">            ele1 = num</span><br><span class="line">            vote1++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vote2 === <span class="number">0</span>) &#123;</span><br><span class="line">            ele2 = num</span><br><span class="line">            vote2++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vote1--</span><br><span class="line">        vote2--</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> count2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num === ele1) &#123;</span><br><span class="line">            count1++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num === ele2) &#123;</span><br><span class="line">            count2++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ans = []</span><br><span class="line">    <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; count1 &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">        ans.push(ele1)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; count2 &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">        ans.push(ele2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈希统计"><a href="#哈希统计" class="headerlink" title="哈希统计"></a>哈希统计</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> countMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (countMap.has(num)) &#123;</span><br><span class="line">            countMap.set(num,countMap.get(num) + <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countMap.set(num, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ans = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> countMap.keys()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (countMap.get(num) &gt; (nums.length / <span class="number">3</span>)) &#123;</span><br><span class="line">            ans.push(num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nuxt项目持续集成部署至阿里云</title>
      <link href="post/nuxt%E9%A1%B9%E7%9B%AE%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2%E8%87%B3%E9%98%BF%E9%87%8C%E4%BA%91/"/>
      <url>post/nuxt%E9%A1%B9%E7%9B%AE%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2%E8%87%B3%E9%98%BF%E9%87%8C%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器安装环境（Ubuntu）"><a href="#服务器安装环境（Ubuntu）" class="headerlink" title="服务器安装环境（Ubuntu）"></a>服务器安装环境（Ubuntu）</h2><h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><p><strong>推荐使用nvm安装</strong>,（不推荐apt）</p><ol><li><p>安装nvm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash</span><br></pre></td></tr></table></figure></li><li><p>是nvm命令生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>安装node版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install --lts // 安装稳定版本中最新的</span><br></pre></td></tr></table></figure></li><li><p>测试node和npm是是否安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li><li><p>nvm的使用</p><ol><li><p>nvm查看node版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash">     v14.18.1</span></span><br><span class="line">       v16.11.1</span><br><span class="line">        v17.0.0</span><br><span class="line">default -&gt; v14.18.1</span><br><span class="line">iojs -&gt; N/A (default)</span><br><span class="line">unstable -&gt; N/A (default)</span><br><span class="line">node -&gt; stable (-&gt; v17.0.0) (default)</span><br><span class="line">stable -&gt; 17.0 (-&gt; v17.0.0) (default)</span><br><span class="line">lts/* -&gt; lts/fermium (-&gt; v14.18.1)</span><br><span class="line">lts/argon -&gt; v4.9.1 (-&gt; N/A)</span><br><span class="line">lts/boron -&gt; v6.17.1 (-&gt; N/A)</span><br><span class="line">lts/carbon -&gt; v8.17.0 (-&gt; N/A)</span><br><span class="line">lts/dubnium -&gt; v10.24.1 (-&gt; N/A)</span><br><span class="line">lts/erbium -&gt; v12.22.7 (-&gt; N/A)</span><br><span class="line">lts/fermium -&gt; v14.18.1</span><br></pre></td></tr></table></figure></li><li><p>nvm安装node版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install v16.11.1</span><br></pre></td></tr></table></figure></li><li><p>nvm 切换node版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use v16.11.1</span><br></pre></td></tr></table></figure></li><li><p>设置默认版本（切记，不然下次打开shell， 版本还是原来的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm alias default v16.11.1</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="查看全局指令"><a href="#查看全局指令" class="headerlink" title="查看全局指令"></a>查看全局指令</h3><p>查看node ,npm,pm2等全局指令用的是不是自己设定的版本，通常用nvm安装的node，使用npm安装依赖包时，二进制指令都在 <strong>/root/.nvm/versions/node/v14.18.1/bin</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis node</span><br><span class="line">node: /root/.nvm/versions/node/v14.18.1/bin/node</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis npm </span><br><span class="line">npm: /root/.nvm/versions/node/v14.18.1/bin/npm</span><br></pre></td></tr></table></figure><h3 id="建立软链接，写进系统全局变量"><a href="#建立软链接，写进系统全局变量" class="headerlink" title="建立软链接，写进系统全局变量"></a>建立软链接，写进系统全局变量</h3><p>npm 安装的依赖包二进制文件在 <code>~/.nvm/versions/node/v14.18.1/bin</code>，这个目录只是用户级别的，当使用任务调度的时候，是不会读取用户的全局变量，所以需要写进系统全局变量</p><p>系统全局变量目录在  <code>/usr/local/bin</code></p><p>建立软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s  ~/.nvm/versions/node/v14.18.1/bin/node /usr/local/bin # 单个</span><br><span class="line">ln -s ~/.nvm/versions/node/v14.18.1/bin/* /usr/local/bin # 所有</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> node 命令已经和/root/.nvm/versions/node/v14.18.1/bin/node* 建立链接 npm 等命令也是</span></span><br><span class="line"></span><br><span class="line">-rwxr-xr-x  1 root root  399 Sep 22 10:14 cloud-id*</span><br><span class="line">-rwxr-xr-x  1 root root  403 Sep 22 10:14 cloud-init*</span><br><span class="line">-rwxr-xr-x  1 root root 2108 Sep 22 10:14 cloud-init-per*</span><br><span class="line">-rwxr-xr-x  1 root root  404 Sep 22 10:14 easy_install*</span><br><span class="line">-rwxr-xr-x  1 root root 1003 Sep 22 10:14 jsondiff*</span><br><span class="line">-rwxr-xr-x  1 root root 3858 Sep 22 10:14 jsonpatch*</span><br><span class="line">-rwxr-xr-x  1 root root 1837 Sep 22 10:14 jsonpointer*</span><br><span class="line">-rwxr-xr-x  1 root root  397 Sep 22 10:14 jsonschema*</span><br><span class="line">lrwxrwxrwx  1 root root   42 Oct 21 19:59 node -&gt; /root/.nvm/versions/node/v14.18.1/bin/node*</span><br><span class="line">-rwxr-xr-x  1 root root  421 Sep 22 10:14 normalizer*</span><br><span class="line">lrwxrwxrwx  1 root root   41 Oct 21 19:59 npm -&gt; /root/.nvm/versions/node/v14.18.1/bin/npm*</span><br><span class="line">lrwxrwxrwx  1 root root   41 Oct 21 19:59 npx -&gt; /root/.nvm/versions/node/v14.18.1/bin/npx*</span><br><span class="line">lrwxrwxrwx  1 root root   41 Oct 21 19:59 nrm -&gt; /root/.nvm/versions/node/v14.18.1/bin/nrm*</span><br><span class="line">lrwxrwxrwx  1 root root   41 Oct 21 19:59 pm2 -&gt; /root/.nvm/versions/node/v14.18.1/bin/pm2*</span><br><span class="line">lrwxrwxrwx  1 root root   45 Oct 21 19:59 pm2-dev -&gt; /root/.nvm/versions/node/v14.18.1/bin/pm2-dev*</span><br><span class="line">lrwxrwxrwx  1 root root   48 Oct 21 19:59 pm2-docker -&gt; /root/.nvm/versions/node/v14.18.1/bin/pm2-docker*</span><br><span class="line">lrwxrwxrwx  1 root root   49 Oct 21 19:59 pm2-runtime -&gt; /root/.nvm/versions/node/v14.18.1/bin/pm2-runtime*</span><br><span class="line">lrwxrwxrwx  1 root root   41 Oct 21 19:59 yrm -&gt; /root/.nvm/versions/node/v14.18.1/bin/yrm*</span><br></pre></td></tr></table></figure><h2 id="使用Github-Actions-实现自动化部署"><a href="#使用Github-Actions-实现自动化部署" class="headerlink" title="使用Github Actions 实现自动化部署"></a>使用Github Actions 实现自动化部署</h2><ol><li><p><strong>提交代码至github仓库</strong></p></li><li><p><strong>在github setting面板创建token</strong></p><p>点击GitHub右上角头像 - Settings - Developer settings - Personal access tokens</p><p>​    <img src="https://img-blog.csdnimg.cn/20201030162424302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5NjE0MTk=,size_16,color_FFFFFF,t_70#pic_center" alt="img">                        </p><p>输入密码，创建token，添加对仓库完全访问和操作的权限：</p><p><img src="https://img-blog.csdnimg.cn/20201030162424302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5NjE0MTk=,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20201030162437633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5NjE0MTk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>生成的token只会出现这一次，如果没有记录，忘记了，只能重新创建一个新的。</strong></p></li><li><p><strong>在项目根目录创建 GitHub Actions 工作流配置文件</strong></p><p>创建目录<code>./github/workflows</code>，在里面创建<code>.yml</code>后缀的文件，文件名随意，将作为工作流的默认名称，GitHub会自动识别到这个文件并执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    # 提交tag名以v开头的tag时执行部署任务</span><br><span class="line">    tags:</span><br><span class="line">      - &#x27;v*&#x27;</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build-and-deploy:</span><br><span class="line">    # 运行环境</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    # 执行的步骤</span><br><span class="line">    steps:</span><br><span class="line">      # 下载源码</span><br><span class="line">      - name: Checkout</span><br><span class="line">        uses: actions/checkout@master</span><br><span class="line"></span><br><span class="line">      # 打包构建</span><br><span class="line">      - name: Build</span><br><span class="line">        uses: actions/setup-node@master</span><br><span class="line">        # with: </span><br><span class="line">        #   node-version: &#x27;14.16.1&#x27; # 指定node版本</span><br><span class="line">      - run: npm install</span><br><span class="line">      - run: npm run build</span><br><span class="line">        # 生成压缩包（打包 .nuxt static nuxt.config.js package.json package-lock.json ecosystem.config.js）</span><br><span class="line">      - run: tar -zcvf release.tgz .nuxt static nuxt.config.js package.json package-lock.json ecosystem.config.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      # 发布 Release（创建Release分支）</span><br><span class="line">      - name: Create Release</span><br><span class="line">        id: create_release</span><br><span class="line">        uses: actions/create-release@master</span><br><span class="line">        env:</span><br><span class="line">          GITHUB_TOKEN: $&#123;&#123; secrets.TOKEN &#125;&#125;</span><br><span class="line">        with:</span><br><span class="line">          # 本次提交的tag的名称</span><br><span class="line">          tag_name: $&#123;&#123; github.ref &#125;&#125;</span><br><span class="line">          # Release版本的名称</span><br><span class="line">          release_name: Release $&#123;&#123; github.ref &#125;&#125;</span><br><span class="line">          # 是否是草稿</span><br><span class="line">          draft: false</span><br><span class="line">          # 是否是预发布</span><br><span class="line">          prerelease: false</span><br><span class="line"></span><br><span class="line">      # 上传构建结果（release.tgz）到 Release</span><br><span class="line">      - name: Upload Release Asset</span><br><span class="line">        id: upload-release-asset</span><br><span class="line">        uses: actions/upload-release-asset@master</span><br><span class="line">        env:</span><br><span class="line">          GITHUB_TOKEN: $&#123;&#123; secrets.TOKEN &#125;&#125;</span><br><span class="line">        with:</span><br><span class="line">          # 上传地址（创建的Release分支地址）</span><br><span class="line">          upload_url: $&#123;&#123; steps.create_release.outputs.upload_url &#125;&#125;</span><br><span class="line">          # 上传的文件</span><br><span class="line">          asset_path: ./release.tgz</span><br><span class="line">          # 上传后的文件名</span><br><span class="line">          asset_name: release.tgz</span><br><span class="line">          # 上传的文件类型</span><br><span class="line">          asset_content_type: application/x-tgz</span><br><span class="line"></span><br><span class="line">      # 部署到服务器</span><br><span class="line">      - name: Deploy</span><br><span class="line">        uses: appleboy/ssh-action@master</span><br><span class="line">        with:</span><br><span class="line">          # 远程服务器地址</span><br><span class="line">          host: $&#123;&#123; secrets.HOST &#125;&#125;</span><br><span class="line">          # 远程服务器用户名</span><br><span class="line">          username: $&#123;&#123; secrets.USERNAME &#125;&#125;</span><br><span class="line">          # 远程服务器密码</span><br><span class="line">          password: $&#123;&#123; secrets.PASSWORD &#125;&#125;</span><br><span class="line">          # 远程服务器端口号</span><br><span class="line">          port: $&#123;&#123; secrets.PORT &#125;&#125;</span><br><span class="line">          # 命令超时配置 默认10m</span><br><span class="line">          command_timeout: 20m</span><br><span class="line">          # 运行在远程服务器的命令</span><br><span class="line">          # 1. 进入项目目录</span><br><span class="line">          # 2. 下载发布包</span><br><span class="line">          # 3. 解压缩发布包</span><br><span class="line">          # 4. 安装生产环境依赖</span><br><span class="line">          # 5. pm2运行配置文件</span><br><span class="line">          script: |</span><br><span class="line">            cd /root/project/nuxt-test</span><br><span class="line">            wget https://github.com/Galaxy-Rigel/nuxt-test/releases/latest/download/release.tgz -O release.tgz</span><br><span class="line">            tar zxvf release.tgz</span><br><span class="line">            npm install --production</span><br><span class="line">            pm2 reload ecosystem.config.js</span><br></pre></td></tr></table></figure><p>工作流中使用到了 <code>secrets</code> 信息，即GitHub项目仓库 Settings 中配置的 Secrets。</p><p><img src="https://img-blog.csdnimg.cn/20201030162454968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5NjE0MTk=,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>需要配置的有（注意名称需要与文件中的保持一致）</p><ul><li>TOKEN - 之前创建并记录的token</li><li>HOST - 服务器IP地址</li><li>USERNAME - 服务器用户名，Linux默认root</li><li>PASSWORD - 服务器 ssh 连接密码</li><li>PORT - ssh连接服务器的端口号，默认22</li></ul><p><img src="https://img-blog.csdnimg.cn/20201030162506408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5NjE0MTk=,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20201030162506364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI5NjE0MTk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p><strong>Push 代码出发自动部署任务</strong></p><p>触发条件：push名称以<code>v</code>开头的 tag。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master v1.2.4</span><br></pre></td></tr></table></figure></li></ol><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>请确认服务器已安装 git、nodejs、pm2 等工具。</p><p>本人服务器构建过程中 Deploy 失败，状态码 127。</p><p>报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-bash: npm: command not found</span><br><span class="line">-bash: pm2: command not found</span><br></pre></td></tr></table></figure><p>可是手动连接服务器执行都OK（本人是nvm安装的nodejs）。</p><p>打印环境变量 echo $PATH 也添加了路径的。</p><p>于是在actions任务中执行命令打印 echo $PATH，果然没有 node 路径。</p><p>尝试在/root/.bashrc 和 /etc/profile中都添加了 环境变量配置，都没有生效。</p><p>又在actions任务中查看文件目录，node、npm、pm2都有。</p><p><strong>这个问题的原因是：</strong></p><p>手动执行任务时，是在当前 shell 环境下进行的，程序可以找到环境变量。</p><p>而系统自动执行任务调度时，是不会加载任何环境变量的，因为它不是通过 shell 环境执行的。</p><p>解决办法：</p><ol><li><p>临时办法：在actions任务中手动添加环境变量：<br>这个方式就是在每次任务执行时，npm命令执行前手动配置环境变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#...</span><br><span class="line">script: |</span><br><span class="line">  export PATH=/root/.nvm/versions/node/v14.18.1/bin:$PATH</span><br><span class="line">  cd /root/project/nuxt-test</span><br><span class="line">#...</span><br></pre></td></tr></table></figure></li><li><p>长久办法：创建软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s ~/.nvm/versions/node/v14.18.1/bin/* /usr/local/bin</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> nuxt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nuxt </tag>
            
            <tag> CI </tag>
            
            <tag> CD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—队列</title>
      <link href="post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%98%9F%E5%88%97/"/>
      <url>post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列和栈一样，也是一种对数据的”存”和”取”有严格要求的线性存储结构。与栈结构不同的是，队列的两端都”开口”，要求数据只能从一端进，从另一端出，如图1 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181203/2-1Q203200556309.gif" alt="队列存储结构"><br>图 1 队列存储结构</p><p>通常，称进数据的一端为 “队尾”，出数据的一端为 “队头”，数据元素进队列的过程称为 “入队”，出队列的过程称为 “出队”。</p><p>不仅如此，队列中数据的进出要遵循 “先进先出” 的原则，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 “先进先出” 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。</p><p>栈和队列不要混淆，栈结构是一端封口，特点是”先进后出”；而队列的两端全是开口，特点是”先进先出”。</p><p>因此，数据从表的一端进，从另一端出，且遵循 “先进先出” 原则的线性存储结构就是队列。</p><h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><p>队列存储结构的实现有以下两种方式：</p><ol><li><a href="http://data.biancheng.net/view/173.html">顺序队列</a>：在<a href="http://data.biancheng.net/view/158.html">顺序表</a>的基础上实现的队列结构；</li><li><a href="http://data.biancheng.net/view/174.html">链队列</a>：在<a href="http://data.biancheng.net/view/160.html">链表</a>的基础上实现的队列结构；</li></ol><p>两者的区别仅是顺序表和链表的区别，即在实际的物理空间中，数据集中存储的队列是顺序队列，分散存储的队列是链队列。</p><h2 id="队列的实际应用"><a href="#队列的实际应用" class="headerlink" title="队列的实际应用"></a>队列的实际应用</h2><p>实际生活中，队列的应用随处可见，比如排队买 XXX、医院的挂号系统等，采用的都是队列的结构。</p><p>拿排队买票来说，所有的人排成一队，先到者排的就靠前，后到者只能从队尾排队等待，队中的每个人都必须等到自己前面的所有人全部买票成功并从队头出队后，才轮到自己买票。这就不是典型的队列结构吗？</p><p>明白了什么是队列，接下来开始系统地学习顺序队列和链队列。</p><h2 id="队列的分类"><a href="#队列的分类" class="headerlink" title="队列的分类"></a>队列的分类</h2><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>顺序队列，即采用顺序表模拟实现的队列结构。</p><p>我们知道，队列具有以下两个特点：</p><ol><li>数据从队列的一端进，另一端出；</li><li>数据的入队和出队遵循”先进先出”的原则；</li></ol><p>因此，只要使用顺序表按以上两个要求操作数据，即可实现顺序队列。首先来学习一种最简单的实现方法。</p><h4 id="顺序队列简单实现"><a href="#顺序队列简单实现" class="headerlink" title="顺序队列简单实现"></a>顺序队列简单实现</h4><p>由于顺序队列的底层使用的是数组，因此需预先申请一块足够大的内存空间初始化顺序队列。除此之外，为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（top 和 rear）分别用于指向顺序队列中的队头元素和队尾元素，如图1 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181204/2-1Q204202R4539.gif" alt="顺序队列实现示意图"><br>图 1 顺序队列实现示意图</p><p>由于顺序队列初始状态没有存储任何元素，因此 top 指针和 rear 指针重合，且由于顺序队列底层实现靠的是数组，因此 top 和 rear 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。</p><p>在图 1 的基础上，当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。</p><p>例如，在图 1 基础上将 <code>&#123;1,2,3,4&#125;</code> 用顺序队列存储的实现操作如图 2 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181204/2-1Q20420293O01.gif" alt="数据进顺序队列的过程实现示意图"><br>图 2 数据进顺序队列的过程实现示意图</p><p>在图 2 基础上，顺序队列中数据出队列的实现过程如图 3 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181204/2-1Q204202950120.gif" alt="数据出顺序队列的过程示意图"><br>图 3 数据出顺序队列的过程示意图</p><p>因此，使用顺序表实现顺序队列最简单方法的 C 语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    a[rear]=data;</span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果 front==rear，表示队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (front!=rear) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队元素：%d\n&quot;</span>,a[front]);</span><br><span class="line">        front++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">    <span class="comment">//设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址</span></span><br><span class="line">    front=rear=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    rear=enQueue(a, rear, <span class="number">1</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">2</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">3</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    deQueue(a, front, rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此方法存在的问题</strong></p><p>先来分析以下图 2b) 和图 3b)。图 2b) 是所有数据进队成功的示意图，而图 3b) 是所有数据全部出队后的示意图。通过对比两张图，你会发现，指针 top 和 rear 重合位置指向了 a[4] 而不再是 a[0]。也就是说，整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。</p><p>顺序队列整体后移造成的影响是：</p><ul><li>顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费；</li><li>如果顺序表申请的空间不足够大，则直接造成程序中数组 a 溢出，产生溢出错误；</li></ul><p>为了避免以上两点，我建议初学者使用下面的方法实现顺序队列。</p><h4 id="顺序队列另一种实现方法"><a href="#顺序队列另一种实现方法" class="headerlink" title="顺序队列另一种实现方法"></a>顺序队列另一种实现方法</h4><p>既然明白了上面这种方法的弊端，那么我们可以试着在它的基础上对其改良。</p><p>为了解决以上两个问题，可以使用巧妙的方法将顺序表打造成一个环状表，如图 4 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181204/2-1Q204203432215.gif" alt="环状顺序队列"><br>图 4 环状顺序队列</p><p>图 4 只是一个想象图，在真正的实现时，没必要真创建这样一种结构，我们还是使用之前的顺序表，也还是使用之前的程序，只需要对其进行一点小小的改变：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 5<span class="comment">//表示顺序表申请的空间大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//添加判断语句，如果rear超过max，则直接将其从a[0]重新开始存储，如果rear+1和front重合，则表示数组已满</span></span><br><span class="line">    <span class="keyword">if</span> ((rear+<span class="number">1</span>)%max==front) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空间已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rear;</span><br><span class="line">    &#125;</span><br><span class="line">    a[rear%max]=data;</span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">deQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果front==rear，表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span>(front==rear%max) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[front]);</span><br><span class="line">    <span class="comment">//front不再直接 +1，而是+1后同max进行比较，如果=max，则直接跳转到 a[0]</span></span><br><span class="line">    front=(front+<span class="number">1</span>)%max;</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[max];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">    <span class="comment">//设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址</span></span><br><span class="line">    front=rear=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">1</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">2</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">3</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="comment">//再入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//再出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="comment">//再入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">6</span>);</span><br><span class="line">    <span class="comment">//再出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用此方法需要注意的是，顺序队列在判断数组是否已满时，出现下面情况：</p><ul><li>当队列为空时，队列的头指针等于队列的尾指针；</li><li>当数组满员时，队列的头指针等于队列的尾指针；</li></ul><p>顺序队列的存储状态不同，但是判断条件相同。为了对其进行区分，最简单的解决办法是：牺牲掉数组中的一个存储空间，判断数组满员的条件是：尾指针的下一个位置和头指针相遇，就说明数组满了，即程序中第 5 行所示。</p><h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>链式队列，简称”链队列”，即使用链表实现的队列存储结构。链式队列的实现思想同顺序队列</p><p>类似，只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素，如图1 所示:</p><p><img src="http://data.biancheng.net/uploads/allimg/181205/2-1Q205211052O7.gif" alt="链式队列的初始状态"><br>图 1 链式队列的初始状态</p><p>图 1 所示为链式队列的初始状态，此时队列中没有存储任何数据元素，因此 top 和 rear 指针都同时指向头节点。</p><p>在创建链式队列时，强烈建议初学者创建一个带有头节点的链表，这样实现链式队列会更简单。</p><p>由此，我们可以编写出创建链式队列的 C 语言实现代码为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"><span class="comment">//创建链式队列的函数</span></span><br><span class="line"><span class="function">QNode * <span class="title">initQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个头节点</span></span><br><span class="line">    QNode * <span class="built_in">queue</span>=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="comment">//对头节点进行初始化</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链式队列数据入队"><a href="#链式队列数据入队" class="headerlink" title="链式队列数据入队"></a>链式队列数据入队</h4><p>链队队列中，当有新的数据元素入队，只需进行以下 3 步操作：</p><ol><li>将该数据元素用节点包裹，例如新节点名称为 elem；</li><li>与 rear 指针指向的节点建立逻辑关系，即执行 rear-&gt;next=elem；</li><li>最后移动 rear 指针指向该新节点，即 rear=elem；</li></ol><p>由此，新节点就入队成功了。</p><p>例如，在图 1 的基础上，我们依次将 <code>&#123;1,2,3&#125;</code> 依次入队，各个数据元素入队的过程如图 2 所示:</p><p><img src="http://data.biancheng.net/uploads/allimg/181205/2-1Q2052111543C.gif" alt="{1,2,3} 入链式队列"><br>图 2 {1,2,3} 入链式队列</p><p>数据元素入链式队列的 C 语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QNode* <span class="title">enQueue</span><span class="params">(QNode * rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、用节点包裹入队元素</span></span><br><span class="line">    QNode * enElem=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    enElem-&gt;data=data;</span><br><span class="line">    enElem-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//2、新节点与rear节点建立逻辑关系</span></span><br><span class="line">    rear-&gt;next=enElem;</span><br><span class="line">    <span class="comment">//3、rear指向新节点</span></span><br><span class="line">    rear=enElem;</span><br><span class="line">    <span class="comment">//返回新的rear，为后续新元素入队做准备</span></span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链式队列数据出队"><a href="#链式队列数据出队" class="headerlink" title="链式队列数据出队"></a>链式队列数据出队</h4><p>当链式队列中，有数据元素需要出队时，按照 “先进先出” 的原则，只需将存储该数据的节点以及它之前入队的元素节点按照原则依次出队即可。这里，我们先学习如何将队头元素出队。</p><p>链式队列中队头元素出队，需要做以下 3 步操作：</p><ol><li>通过 top 指针直接找到队头节点，创建一个新指针 p 指向此即将出队的节点；</li><li>将 p 节点（即要出队的队头节点）从链表中摘除；</li><li>释放节点 p，回收其所占的内存空间；</li></ol><p>例如，在图 2b) 的基础上，我们将元素 1 和 2 出队，则操作过程如图 3 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181205/2-1Q205211240637.gif" alt="链式队列中数据元素出队"><br>图 3 链式队列中数据元素出队</p><p>链式队列中队头元素出队的 C 语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(QNode * top,QNode * rear)</span></span>&#123;</span><br><span class="line">    QNode * p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (top-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    p=top-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);</span><br><span class="line">    top-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (rear==p) &#123;</span><br><span class="line">        rear=top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—栈</title>
      <link href="post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88/"/>
      <url>post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p><img src="http://data.biancheng.net/uploads/allimg/181201/2-1Q201203Q5110.gif" alt="栈存储结构示意图"><br>图 1 栈存储结构示意图</p><p>从图 1 我们看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 “存” 和 “取” 的过程有特殊的要求：</p><ol><li>栈只能从表的一端存取数据，另一端是封闭的，如图 1 所示；</li><li>在栈中，无论是存数据还是取数据，都必须遵循”先进后出”的原则，即最先进栈的元素最后出栈。拿图 1 的栈来说，从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据”先进后出”的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。</li></ol><p>因此，我们可以给栈下一个定义，即栈是一种只能从表的一端存取数据且遵循 “先进后出” 原则的线性存储结构。</p><p>通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。因此，栈顶元素指的就是距离栈顶最近的元素，拿图 2 来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，图 2 中的栈底元素为元素 1。</p><p><img src="http://data.biancheng.net/uploads/allimg/181201/2-1Q201204153P8.gif" alt="栈顶和栈底"><br>图 2 栈顶和栈底</p><h2 id="进栈和出栈"><a href="#进栈和出栈" class="headerlink" title="进栈和出栈"></a>进栈和出栈</h2><p>基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：</p><ul><li>向栈中添加元素，此过程被称为”进栈”（入栈或压栈）；</li><li>从栈中提取出指定元素，此过程被称为”出栈”（或弹栈）；</li></ul><h2 id="栈的具体实现"><a href="#栈的具体实现" class="headerlink" title="栈的具体实现"></a>栈的具体实现</h2><p>栈是一种 “特殊” 的线性存储结构，因此栈的具体实现有以下两种方式：</p><ol><li><a href="http://data.biancheng.net/view/170.html">顺序栈</a>：采用顺序存储结构可以模拟栈存储数据的特点，从而实现栈存储结构；</li><li><a href="http://data.biancheng.net/view/171.html">链栈</a>：采用链式存储结构实现栈结构；</li></ol><p>两种实现方式的区别，仅限于数据元素在实际物理空间上存放的相对位置，顺序栈底层采用的是<a href="http://data.biancheng.net/view/181.html">数组</a>，链栈底层采用的是链表。有关顺序栈和链栈的具体实现会在后续章节中作详细讲解。</p><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><p>基于栈结构对数据存取采用 “先进后出” 原则的特点，它可以用于实现很多功能。</p><p>例如，我们经常使用浏览器在各种网站上查找信息。假设先浏览的页面 A，然后关闭了页面 A 跳转到页面 B，随后又关闭页面 B 跳转到了页面 C。而此时，我们如果想重新回到页面 A，有两个选择：</p><ul><li>重新搜索找到页面 A；</li><li>使用浏览器的”回退”功能。浏览器会先回退到页面 B，而后再回退到页面 A。</li></ul><p>浏览器 “回退” 功能的实现，底层使用的就是栈存储结构。当你关闭页面 A 时，浏览器会将页面 A 入栈；同样，当你关闭页面 B 时，浏览器也会将 B入栈。因此，当你执行回退操作时，才会首先看到的是页面 B，然后是页面 A，这是栈中数据依次出栈的效果。</p><p>不仅如此，栈存储结构还可以帮我们检测代码中的<a href="http://data.biancheng.net/view/87.html">括号匹配</a>问题。多数编程语言都会用到括号（小括号、中括号和大括号），括号的错误使用（通常是丢右括号）会导致程序编译错误，而很多开发工具中都有检测代码是否有编辑错误的功能，其中就包含检测代码中的括号匹配问题，此功能的底层实现使用的就是栈结构。</p><p>同时，栈结构还可以实现数值的<a href="http://data.biancheng.net/view/86.html">进制转换</a>功能。例如，编写程序实现从十进制数自动转换成二进制数，就可以使用栈存储结构来实现。</p><p>以上也仅是栈应用领域的冰山一角，这里不再过多举例。在后续章节的学习中，我们会大量使用到栈结构。</p><p>接下来，我们学习如何实现顺序栈和链栈，以及对栈中元素进行入栈和出栈的操作。</p><h2 id="栈的分类"><a href="#栈的分类" class="headerlink" title="栈的分类"></a>栈的分类</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>即用顺序表实现栈存储结构。通过前面的学习我们知道，使用栈存储结构操作数据元素必须遵守 “先进后出” 的原则，本节就 “如何使用顺序表模拟栈以及实现对栈中数据的基本操作（出栈和入栈）” 给大家做详细介绍。</p><p>如果你仔细观察顺序表（底层实现是数组）和栈结构就会发现，它们存储数据的方式高度相似，只不过栈对数据的存取过程有特殊的限制，而顺序表没有。</p><p>例如，我们先使用顺序表（a 数组）存储 <code>&#123;1,2,3,4&#125;</code>，存储状态如图1 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181202/2-1Q202131155H8.gif" alt="顺序表存储 {1,2,3,4}"><br>图 1 顺序表存储 {1,2,3,4}</p><p>同样，使用栈存储结构存储 <code>&#123;1,2,3,4&#125;</code>，其存储状态如图 2 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181202/2-1Q202131233249.gif" alt="栈结构存储 {1,2,3,4}"><br>图 2 栈结构存储 {1,2,3,4}</p><p>通过图 1 和图 2 的对比不难看出，使用顺序表模拟栈结构很简单，只需要将数据从 a 数组下标为 0 的位置依次存储即可。</p><p>从数组下标为 0 的模拟栈存储数据是常用的方法，从其他数组下标处存储数据也完全可以，这里只是为了方便初学者理解。</p><p>了解了顺序表模拟栈存储数据后，接下来看如何模拟栈中元素出栈的操作。由于栈对存储元素出栈的次序有”先进后出”的要求，如果想将图 1 中存储的元素 1 从栈中取出，需先将元素 4、元素 3 和元素 2 依次从栈中取出。</p><p>这里给出使用顺序表模拟栈存储结构常用的实现思路，即在顺序表中设定一个实时指向栈顶元素的变量（一般命名为 top），top 初始值为 -1，表示栈中没有存储任何数据元素，及栈是”空栈”。一旦有数据元素进栈，则 top 就做 +1 操作；反之，如果数据元素出栈，top 就做 -1 操作。</p><h4 id="顺序栈元素”入栈”"><a href="#顺序栈元素”入栈”" class="headerlink" title="顺序栈元素”入栈”"></a>顺序栈元素”入栈”</h4><p>比如，还是模拟栈存储 <code>&#123;1,2,3,4&#125;</code> 的过程。最初，栈是”空栈”，即数组是空的，top 值为初始值 -1，如图 3 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181202/2-1Q202131603419.gif" alt="空栈示意图"><br>图 3 空栈示意图</p><p>首先向栈中添加元素 1，我们默认数组下标为 0 一端表示栈底，因此，元素 1 被存储在数组 a[1] 处，同时 top 值 +1，如图 4 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181202/2-1Q2021316322O.gif" alt="模拟栈存储元素 1"><br>图 4 模拟栈存储元素 1</p><p>采用以上的方式，依次存储元素 2、3 和 4，最终，top 值变为 3，如图 5 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181202/2-1Q202131649636.gif" alt="模拟栈存储{1,2,3,4}"><br>图 5 模拟栈存储{1,2,3,4}</p><p>因此，C 语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元素elem进栈，a为数组，top值为当前栈的栈顶位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> top,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">    a[++top]=elem;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 a[++top]=elem，等价于先执行 ++top，再执行 a[top]=elem。</p><h4 id="顺序栈元素”出栈”"><a href="#顺序栈元素”出栈”" class="headerlink" title="顺序栈元素”出栈”"></a>顺序栈元素”出栈”</h4><p>其实，top 变量的设置对模拟数据的 “入栈” 操作没有实际的帮助，它是为实现数据的 “出栈” 操作做准备的。</p><p>比如，将图 5 中的元素 2 出栈，则需要先将元素 4 和元素 3 依次出栈。需要注意的是，当有数据出栈时，要将 top 做 -1 操作。因此，元素 4 和元素 3 出栈的过程分别如图 6a) 和 6b) 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181225/2-1Q225200HMC.gif" alt="数据元素出栈"><br>图 6 数据元素出栈</p><p>注意，图 6 数组中元素的消失仅是为了方便初学者学习，其实，这里只需要对 top 值做 -1 操作即可，因为 top 值本身就表示栈的栈顶位置，因此 top-1 就等同于栈顶元素出栈。并且后期向栈中添加元素时，新元素会存储在类似元素 4 这样的旧元素位置上，将旧元素覆盖。</p><p>元素 4 和元素 3 全部出栈后，元素 2 才能出栈。因此，使用顺序表模拟数据出栈操作的 C 语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> * a,<span class="keyword">int</span> top)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空栈&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹栈元素：%d\n&quot;</span>,a[top]);</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>即用链表实现栈存储结构。链栈的实现思路同顺序栈类似，顺序栈是将数顺序表（数组）的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如图1 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181202/2-1Q2021G31YC.gif" alt="链栈示意图"><br>图 1 链栈示意图</p><p>将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。</p><p>链表的头部作为栈顶，意味着：</p><ul><li>在实现数据”入栈”操作时，需要将数据从链表的头部插入；</li><li>在实现数据”出栈”操作时，需要删除链表头部的首元节点；</li></ul><p>因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表。</p><h4 id="链栈元素入栈"><a href="#链栈元素入栈" class="headerlink" title="链栈元素入栈"></a>链栈元素入栈</h4><p>例如，将元素 1、2、3、4 依次入栈，等价于将各元素采用头插法依次添加到链表中，每个数据元素的添加过程如图 2 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181202/2-1Q2021G402604.gif" alt="链栈元素依次入栈过程示意图"><br>图 2 链栈元素依次入栈过程示意图</p><p>C语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;lineStack;</span><br><span class="line"><span class="comment">//stack为当前的链栈，a表示入栈元素</span></span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建存储新元素的节点</span></span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    <span class="comment">//新节点与头节点建立逻辑关系</span></span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">//更新头指针的指向</span></span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链栈元素出栈"><a href="#链栈元素出栈" class="headerlink" title="链栈元素出栈"></a>链栈元素出栈</h4><p>例如，图 2e) 所示的链栈中，若要将元素 3 出栈，根据”先进后出”的原则，要先将元素 4 出栈，也就是从链表中摘除，然后元素 3 才能出栈，整个操作过程如图 3 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181202/2-1Q2021G432217.gif" alt="链栈元素出栈示意图"><br>图 3 链栈元素出栈示意图</p><p>因此，实现栈顶元素出链栈的 C 语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈顶元素出链栈的实现函数</span></span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">        <span class="comment">//声明一个新指针指向栈顶节点</span></span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="comment">//更新头指针</span></span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈元素：%d &quot;</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;新栈顶元素：%d\n&quot;</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;栈已空\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈内没有元素&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—静态链表</title>
      <link href="post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
      <url>post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>静态链表，也是线性存储结构的一种，它兼顾了顺序表和链表的优点于一身，可以看做是顺序表和链表的升级版。</p><p>使用静态链表存储数据，数据全部存储在<a href="http://data.biancheng.net/view/181.html">数组</a>中（和顺序表一样），但存储位置是随机的，数据之间”一对一”的逻辑关系通过一个整形变量（称为”游标”，和指针功能类似）维持（和链表类似）。</p><p>例如，使用静态链表存储 <code>&#123;1,2,3&#125;</code> 的过程如下：</p><p>创建一个足够大的数组，假设大小为 6，如图 1 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181126/2-1Q1260R610450.gif" alt="空数组"><br>图 1 空数组</p><p>接着，在将数据存放到数组中时，给各个数据元素配备一个整形变量，此变量用于指明各个元素的直接后继元素所在数组中的位置下标，如图 2 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181126/2-1Q1260RHSQ.gif" alt="静态链表存储数据"><br>图 2 静态链表存储数据</p><p>通常，静态链表会将第一个数据元素放到数组下标为 1 的位置（a[1]）中。</p><p>图 2 中，从 a[1] 存储的数据元素 1 开始，通过存储的游标变量 3，就可以在 a[3] 中找到元素 1 的直接后继元素 2；同样，通过元素 a[3] 存储的游标变量 5，可以在 a[5] 中找到元素 2 的直接后继元素 3，这样的循环过程直到某元素的游标变量为 0 截止（因为 a[0] 默认不存储数据元素）。</p><p>类似图 2 这样，通过 “数组+游标” 的方式存储具有线性关系数据的存储结构就是静态链表。</p><h2 id="静态链表中的节点"><a href="#静态链表中的节点" class="headerlink" title="静态链表中的节点"></a>静态链表中的节点</h2><p>通过上面的学习我们知道，静态链表存储数据元素也需要自定义数据类型，至少需要包含以下 2 部分信息：</p><ul><li>  数据域：用于存储数据元素的值；</li><li>  游标：其实就是数组下标，表示直接后继元素所在数组中的位置；</li></ul><p>因此，静态链表中节点的构成用 C 语言实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> cur;<span class="comment">//游标</span></span><br><span class="line">&#125;component;</span><br></pre></td></tr></table></figure><h2 id="备用链表"><a href="#备用链表" class="headerlink" title="备用链表"></a>备用链表</h2><p>图 2 显示的静态链表还不够完整，静态链表中，除了数据本身通过游标组成的链表外，还需要有一条连接各个空闲位置的链表，称为备用链表。</p><p>备用链表的作用是回收数组中未使用或之前使用过（目前未使用）的存储空间，留待后期使用。也就是说，静态链表使用数组申请的物理空间中，存有两个链表，一条连接数据，另一条连接数组中未使用的空间。</p><p>通常，备用链表的表头位于数组下标为 0（a[0]） 的位置，而数据链表的表头位于数组下标为 1（a[1]）的位置。</p><p>静态链表中设置备用链表的好处是，可以清楚地知道数组中是否有空闲位置，以便数据链表添加新数据时使用。比如，若静态链表中数组下标为 0 的位置上存有数据，则证明数组已满。</p><p>例如，使用静态链表存储 <code>&#123;1,2,3&#125;</code>，假设使用长度为 6 的数组 a，则存储状态可能如图 3 所示：<img src="http://data.biancheng.net/uploads/allimg/181126/2-1Q1260S02X93.gif" alt="备用链表和数据链表"><br>图 3 备用链表和数据链表</p><p>图 3 中，备用链表上连接的依次是 a[0]、a[2] 和 a[4]，而数据链表上连接的依次是 a[1]、a[3] 和 a[5]。</p><h2 id="静态链表的实现"><a href="#静态链表的实现" class="headerlink" title="静态链表的实现"></a>静态链表的实现</h2><p>假设使用静态链表（数组长度为 6）存储 <code>&#123;1,2,3&#125;</code>，则需经历以下几个阶段。</p><p>在数据链表未初始化之前，数组中所有位置都处于空闲状态，因此都应被链接在备用链表上，如图 4 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181126/2-1Q1260S13YN.gif" alt="未存储数据之前静态链表的状态"><br>图 4 未存储数据之前静态链表的状态</p><p>当向静态链表中添加数据时，需提前从备用链表中摘除节点，以供新数据使用。</p><p>备用链表摘除节点最简单的方法是摘除 a[0] 的直接后继节点；同样，向备用链表中添加空闲节点也是添加作为 a[0] 新的直接后继节点。因为 a[0] 是备用链表的第一个节点，我们知道它的位置，操作它的直接后继节点相对容易，无需遍历备用链表，耗费的<a href="http://data.biancheng.net/view/2.html">时间复杂度</a>为 <code>O(1)</code>。</p><p>因此，在图 4 的基础上，向静态链表中添加元素 1 的过程如图 5 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181126/2-1Q1260S229302.gif" alt="静态链表中添加元素 1"><br>图 5 静态链表中添加元素 1</p><p>在图 5 的基础上，添加元素 2 的过程如图 6 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181126/2-1Q1260S305P9.gif" alt="静态链表中继续添加元素 2"><br>图 6 静态链表中继续添加元素 2</p><p>在图 6 的基础上，继续添加元素 3 ，过程如图 7 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181126/2-1Q1260S34aS.gif" alt="静态链表中继续添加元素 3"><br>图 7 静态链表中继续添加元素 3</p><p>由此，静态链表就创建完成了。</p><p>下面给出了创建静态链表的 C 语言实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 6</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">&#125;component;</span><br><span class="line"><span class="comment">//将结构体数组中所有分量链接到备用链表中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserveArr</span><span class="params">(component *<span class="built_in">array</span>)</span></span>;</span><br><span class="line"><span class="comment">//初始化静态链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initArr</span><span class="params">(component *<span class="built_in">array</span>)</span></span>;</span><br><span class="line"><span class="comment">//输出函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayArr</span><span class="params">(component * <span class="built_in">array</span>, <span class="keyword">int</span> body)</span></span>;</span><br><span class="line"><span class="comment">//从备用链表上摘下空闲节点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mallocArr</span><span class="params">(component * <span class="built_in">array</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    component <span class="built_in">array</span>[maxSize];</span><br><span class="line">    <span class="keyword">int</span> body = initArr(<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;静态链表为：\n&quot;</span>);</span><br><span class="line">    displayArr(<span class="built_in">array</span>, body);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建备用链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserveArr</span><span class="params">(component *<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i].cur = i + <span class="number">1</span>;<span class="comment">//将每个数组分量链接到一起</span></span><br><span class="line">        <span class="built_in">array</span>[i].data = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[maxSize - <span class="number">1</span>].cur = <span class="number">0</span>;<span class="comment">//链表最后一个结点的游标值为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提取分配空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mallocArr</span><span class="params">(component * <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//若备用链表非空，则返回分配的结点下标，否则返回 0（当分配最后一个结点时，该结点的游标值为 0）</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">array</span>[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>].cur) &#123;</span><br><span class="line">        <span class="built_in">array</span>[<span class="number">0</span>].cur = <span class="built_in">array</span>[i].cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化静态链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initArr</span><span class="params">(component *<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tempBody = <span class="number">0</span>, body = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    reserveArr(<span class="built_in">array</span>);</span><br><span class="line">    body = mallocArr(<span class="built_in">array</span>);</span><br><span class="line">    <span class="comment">//建立首元结点</span></span><br><span class="line">    <span class="built_in">array</span>[body].data = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">array</span>[body].cur = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//声明一个变量，把它当指针使，指向链表的最后的一个结点，当前和首元结点重合</span></span><br><span class="line">    tempBody = body;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = mallocArr(<span class="built_in">array</span>); <span class="comment">//从备用链表中拿出空闲的分量</span></span><br><span class="line">        <span class="built_in">array</span>[j].data = i;      <span class="comment">//初始化新得到的空间结点</span></span><br><span class="line">        <span class="built_in">array</span>[tempBody].cur = j; <span class="comment">//将新得到的结点链接到数据链表的尾部</span></span><br><span class="line">        tempBody = j;             <span class="comment">//将指向链表最后一个结点的指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[tempBody].cur = <span class="number">0</span>;<span class="comment">//新的链表最后一个结点的指针设置为0</span></span><br><span class="line">    <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayArr</span><span class="params">(component * <span class="built_in">array</span>, <span class="keyword">int</span> body)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tempBody = body;<span class="comment">//tempBody准备做遍历使用</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">array</span>[tempBody].cur) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="built_in">array</span>[tempBody].data, <span class="built_in">array</span>[tempBody].cur);</span><br><span class="line">        tempBody = <span class="built_in">array</span>[tempBody].cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="built_in">array</span>[tempBody].data, <span class="built_in">array</span>[tempBody].cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态链表添加元素"><a href="#静态链表添加元素" class="headerlink" title="静态链表添加元素"></a>静态链表添加元素</h2><p><img src="http://data.biancheng.net/uploads/allimg/181126/2-1Q1260S34aS.gif" alt="图 1 建立好的静态链表"></p><p>图 1 建立好的静态链表</p><p>例如，在图 1 的基础，将元素 4 添加到静态链表中的第 3 个位置上，实现过程如下：</p><ol><li>从备用链表中摘除一个节点，用于存储元素 4；</li><li>找到表中第 2 个节点（添加位置的前一个节点，这里是数据元素 2），将元素 2 的游标赋值给新元素 4；</li><li>将元素 4 所在<a href="http://data.biancheng.net/view/181.html">数组</a>中的下标赋值给元素 2 的游标；</li></ol><p>经过以上几步操作，数据元素 4 就成功地添加到了静态链表中，此时新的静态链表如图 2 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181126/2-1Q126205601512.gif" alt="img"><br>图 2 添加元素 4 的静态链表</p><p>由此，我们通过尝试编写 C 语言程序实现以上操作。读者可参考如下程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向链表中插入数据，body表示链表的头结点在数组中的位置，add表示插入元素的位置，num表示要插入的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertArr</span><span class="params">(component * <span class="built_in">array</span>, <span class="keyword">int</span> body, <span class="keyword">int</span> add, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tempBody = body;<span class="comment">//tempBody做遍历结构体数组使用</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, insert = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到要插入位置的上一个结点在数组中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; add; i++) &#123;</span><br><span class="line">        tempBody = <span class="built_in">array</span>[tempBody].cur;</span><br><span class="line">    &#125;</span><br><span class="line">    insert = mallocArr(<span class="built_in">array</span>);<span class="comment">//申请空间，准备插入</span></span><br><span class="line">    <span class="built_in">array</span>[insert].data = num;</span><br><span class="line">    <span class="built_in">array</span>[insert].cur = <span class="built_in">array</span>[tempBody].cur;<span class="comment">//新插入结点的游标等于其直接前驱结点的游标</span></span><br><span class="line">    <span class="built_in">array</span>[tempBody].cur = insert;<span class="comment">//直接前驱结点的游标等于新插入结点所在数组中的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态链表删除元素"><a href="#静态链表删除元素" class="headerlink" title="静态链表删除元素"></a>静态链表删除元素</h2><p>静态链表中删除指定元素，只需实现以下 2 步操作：</p><ol><li>将存有目标元素的节点从数据链表中摘除；</li><li>将摘除节点添加到备用链表，以便下次再用；</li></ol><p>比较特殊的是，对于无头结点的数据链表来说，如果需要删除头结点，则势必会导致数据链表的表头不再位于数组下标为 1 的位置，换句话说，删除头结点之后，原数据链表中第二个结点将作为整个链表新的首元结点。</p><p>若问题中涉及大量删除元素的操作，建议读者在建立静态链表之初创建一个带有头节点的静态链表，方便实现删除链表中第一个数据元素的操作。</p><p>如下是针对无头结点的数据链表，实现删除操作的 C 语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除结点函数，num表示被删除结点中数据域存放的数据，函数返回新数据链表的表头位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletArr</span><span class="params">(component * <span class="built_in">array</span>, <span class="keyword">int</span> body, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tempBody = body;</span><br><span class="line">    <span class="keyword">int</span> del = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> newbody = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到被删除结点的位置</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">array</span>[tempBody].data != num) &#123;</span><br><span class="line">        tempBody = <span class="built_in">array</span>[tempBody].cur;</span><br><span class="line">        <span class="comment">//当tempBody为0时，表示链表遍历结束，说明链表中没有存储该数据的结点</span></span><br><span class="line">        <span class="keyword">if</span> (tempBody == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;链表中没有此数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//运行到此，证明有该结点</span></span><br><span class="line">    del = tempBody;</span><br><span class="line">    tempBody = body;</span><br><span class="line">    <span class="comment">//删除首元结点，需要特殊考虑</span></span><br><span class="line">    <span class="keyword">if</span> (del == body) &#123;</span><br><span class="line">        newbody = <span class="built_in">array</span>[del].cur;</span><br><span class="line">        freeArr(<span class="built_in">array</span>, del);</span><br><span class="line">        <span class="keyword">return</span> newbody;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//找到该结点的上一个结点，做删除操作</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">array</span>[tempBody].cur != del) &#123;</span><br><span class="line">            tempBody = <span class="built_in">array</span>[tempBody].cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将被删除结点的游标直接给被删除结点的上一个结点</span></span><br><span class="line">        <span class="built_in">array</span>[tempBody].cur = <span class="built_in">array</span>[del].cur;</span><br><span class="line">        <span class="comment">//回收被摘除节点的空间</span></span><br><span class="line">        freeArr(<span class="built_in">array</span>, del);</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态链表查找元素"><a href="#静态链表查找元素" class="headerlink" title="静态链表查找元素"></a>静态链表查找元素</h2><p>静态链表查找指定元素，由于我们只知道静态链表第一个元素所在数组中的位置，因此只能通过逐个遍历静态链表的方式，查找存有指定数据元素的节点。</p><p>静态链表查找指定数据元素的 C 语言实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在以body作为头结点的链表中查找数据域为elem的结点在数组中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectNum</span><span class="params">(component * <span class="built_in">array</span>, <span class="keyword">int</span> body, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当游标值为0时，表示链表结束</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">array</span>[body].cur != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[body].data == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line">        body = <span class="built_in">array</span>[body].cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断最后一个结点是否符合要求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[body].data == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//返回-1，表示在链表中没有找到该元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态链表中更改数据"><a href="#静态链表中更改数据" class="headerlink" title="静态链表中更改数据"></a>静态链表中更改数据</h2><p>更改静态链表中的数据，只需找到目标元素所在的节点，直接更改节点中的数据域即可。</p><p>实现此操作的 C 语言代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在以body作为头结点的链表中将数据域为oldElem的结点，数据域改为newElem</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">amendElem</span><span class="params">(component * <span class="built_in">array</span>, <span class="keyword">int</span> body, <span class="keyword">int</span> oldElem, <span class="keyword">int</span> newElem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> add = selectNum(<span class="built_in">array</span>, body, oldElem);</span><br><span class="line">    <span class="keyword">if</span> (add == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无更改元素&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[add].data = newElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态链表和动态链表比较"><a href="#静态链表和动态链表比较" class="headerlink" title="静态链表和动态链表比较"></a>静态链表和动态链表比较</h2><p><img src="http://data.biancheng.net/uploads/allimg/181123/2-1Q12321243O36.gif" alt="链表存储结构"><br>图 1 链表存储结构</p><p>类似图 1 这样的链表，它更喜欢人们称它为 “动态链表”。</p><p>随后又接触了静态链表。同样是存储图 1 中的数据 <code>&#123;1,2,3&#125;</code>，使用静态链表存储数据的状态如图 2 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181126/2-1Q1260S34aS.gif" alt="静态链表存储数据示意图"><br>图 2 静态链表存储数据示意图</p><p>为了让读者分清动态链表和静态链表，本节来分析一下它们之间的区别和联系。</p><p>静态链表和动态链表的共同点是，数据之间”一对一”的逻辑关系都是依靠指针（静态链表中称”游标”）来维持，仅此而已。</p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>使用静态链表存储数据，需要预先申请足够大的一整块内存空间，也就是说，静态链表存储数据元素的个数从其创建的那一刻就已经确定，后期无法更改。</p><p>比如，如果创建静态链表时只申请存储 10 个数据元素的空间，那么在使用静态链表时，数据的存储个数就不能超过 10 个，否则程序就会发生错误。</p><p>不仅如此，静态链表是在固定大小的存储空间内随机存储各个数据元素，这就造成了静态链表中需要使用另一条链表（通常称为”备用链表”）来记录空间存储空间的位置，以便后期分配给新添加元素使用，如图 2 所示。</p><p>这意味着，如果你选择使用静态链表存储数据，你需要通过操控两条链表，一条是存储数据，另一条是记录空闲空间的位置。</p><h3 id="动态链表"><a href="#动态链表" class="headerlink" title="动态链表"></a>动态链表</h3><p>使用动态链表存储数据，不需要预先申请内存空间，而是在需要的时候才向内存申请。也就是说，动态链表存储数据元素的个数是不限的，想存多少就存多少。</p><p>同时，使用动态链表的整个过程，你也只需操控一条存储数据的链表。当表中添加或删除数据元素时，你只需要通过 malloc 或 free 函数来申请或释放空间即可，实现起来比较简单。</p><p><a href="http://data.biancheng.net/view/163.html">转载自：http://data.biancheng.net/view/163.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—顺序表和链表区别</title>
      <link href="post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E5%8C%BA%E5%88%AB/"/>
      <url>post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序表和链表的优缺点（区别、特点）详解"><a href="#顺序表和链表的优缺点（区别、特点）详解" class="headerlink" title="顺序表和链表的优缺点（区别、特点）详解"></a>顺序表和链表的优缺点（区别、特点）详解</h2><p>顺序表和链表由于存储结构上的差异，导致它们具有不同的特点，适用于不同的场景。本节就来分析它们的特点，让读者明白 “在什么样的场景中使用哪种存储结构” 更能有效解决问题。</p><p>通过系统地学习顺序表和链表我们知道，虽然它们同属于线性表，但数据的存储结构有本质的不同：</p><ul><li>  顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据之间紧密贴合，不留一丝空隙，如图 1a) 所示；</li><li>  链表的存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持，如图 1b) 所示；</li></ul><p><img src="http://data.biancheng.net/uploads/allimg/181125/2-1Q12512244c10.gif" alt="顺序表和链表的存储结构对比"></p><p>基于不同的存储结构，顺序表和链表有以下几种不同。</p><h3 id="开辟空间的方式"><a href="#开辟空间的方式" class="headerlink" title="开辟空间的方式"></a>开辟空间的方式</h3><p>顺序表存储数据实行的是 “一次开辟，永久使用”，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。</p><p>而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。</p><p>因此，若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。</p><h3 id="空间利用率"><a href="#空间利用率" class="headerlink" title="空间利用率"></a>空间利用率</h3><p>从空间利用率的角度上看，顺序表的空间利用率显然要比链表高。</p><p>这是因为，链表在存储数据时，每次只申请一个节点的空间，且空间的位置是随机的，如图 2 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181125/2-1Q12512255D10.gif" alt="链表结构易产生碎片"><br>图 2 链表结构易产生碎片</p><p>这种申请存储空间的方式会产生很多空间碎片，一定程序上造成了空间浪费。不仅如此，由于链表中每个数据元素都必须携带至少一个指针，因此，链表对所申请空间的利用率也没有顺序表高。</p><blockquote><p>空间碎片，指的是某些容量很小（1KB 甚至更小）以致无法得到有效利用的物理空间。</p></blockquote><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>解决不同类型的问题，顺序表和链表对应的时间复杂度也不同。</p><p>根据顺序表和链表在存储结构上的差异，问题类型主要分为以下 2 类：</p><ol><li>问题中主要涉及访问元素的操作，元素的插入、删除和移动操作极少；</li><li>问题中主要涉及元素的插入、删除和移动，访问元素的需求很少；</li></ol><p>第 1 类问题适合使用顺序表。这是因为，顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 <code>O(1)</code>；而在链表中访问数据元素，需要从表头依次遍历，直到找到指定节点，花费的时间复杂度为 <code>O(n)</code>;</p><p>第 2 类问题则适合使用链表。链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 <code>O(1)</code>；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，因此时间复杂度至少为 <code>O(n)</code>;</p><p>综上所述，不同类型的场景，选择合适的存储结构会使解决问题效率成倍数地提高。</p><p><a href="http://data.biancheng.net/view/162.html">转载自：http://data.biancheng.net/view/162.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—链表</title>
      <link href="post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8/"/>
      <url>post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>链表，别名链式存储结构或单链表，用于存储逻辑关系为 “一对一” 的数据。与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。</p><p>例如，使用链表存储 <code>&#123;1,2,3&#125;</code>，数据的物理存储状态如图 1 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181123/2-1Q12321231CA.gif" alt="链表随机存储数据"><br>图 1 链表随机存储数据</p><p>我们看到，图 1 根本无法体现出各数据之间的逻辑关系。对此，链表的解决方案是，每个数据元素在存储时都配备一个指针，用于指向自己的直接后继元素。如图 2 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181123/2-1Q12321243O36.gif" alt="各数据元素配备指针"><br>图 2 各数据元素配备指针</p><p>像图 2 这样，数据元素随机存储，并通过指针表示数据之间逻辑关系的存储结构就是链式存储结构。</p><h2 id="链表的节点"><a href="#链表的节点" class="headerlink" title="链表的节点"></a>链表的节点</h2><p>从图 2 可以看到，链表中每个数据的存储都由以下两部分组成：</p><ol><li>数据元素本身，其所在的区域称为数据域；</li><li>指向直接后继元素的指针，所在的区域称为指针域；</li></ol><p>即链表中存储各数据元素的结构如图 3 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181123/2-1Q1232126112G.gif" alt="img"><br>图 3 节点结构</p><p>图 3 所示的结构在链表中称为节点。也就是说，链表实际存储的是一个一个的节点，真正的数据元素包含在这些节点中，如图 4 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181123/2-1Q123212Q3337.gif" alt="链表中的节点"><br>图 4 链表中的节点</p><p>因此，链表中每个节点的具体实现，需要使用 C 语言中的结构体，具体实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> elem; <span class="comment">//代表数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link</span> * <span class="title">next</span>;</span> <span class="comment">//代表指针域，指向直接后继元素</span></span><br><span class="line">&#125;link; <span class="comment">//link为节点名，每个节点都是一个 link 结构体</span></span><br></pre></td></tr></table></figure><h2 id="头节点，头指针和首元节点"><a href="#头节点，头指针和首元节点" class="headerlink" title="头节点，头指针和首元节点"></a>头节点，头指针和首元节点</h2><p>其实，图 4 所示的链表结构并不完整。一个完整的链表需要由以下几部分构成：</p><ol><li><p>头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；</p></li><li><p>节点：链表中的节点又细分为头节点首元节点和其他节点：</p><ul><li>头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；</li><li>首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；</li><li>其他节点：链表中其他的节点；</li></ul></li></ol><p>因此，一个存储 <code>&#123;1,2,3&#125;</code> 的完整链表结构如图 5 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181123/2-1Q123213124343.gif" alt="完整的链表示意图"><br>图 5 完整的链表示意图</p><p>注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。</p><h2 id="链表的创建（初始化）"><a href="#链表的创建（初始化）" class="headerlink" title="链表的创建（初始化）"></a>链表的创建（初始化）</h2><p>创建一个链表需要做如下工作：</p><ol><li>声明一个头指针（如果有必要，可以声明一个头节点）；</li><li>创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；</li></ol><p>例如，创建一个存储 <code>&#123;1,2,3,4&#125;</code> 且无头节点的链表，C 语言实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">link * <span class="title">initLink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    link * p = <span class="literal">NULL</span>;<span class="comment">//创建头指针</span></span><br><span class="line">    link * temp = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));<span class="comment">//创建首元节点</span></span><br><span class="line">    <span class="comment">//首元节点先初始化</span></span><br><span class="line">    temp-&gt;elem = <span class="number">1</span>;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p = temp;<span class="comment">//头指针指向首元节点</span></span><br><span class="line">    <span class="comment">//从第二个节点开始创建</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//创建一个新节点并初始化</span></span><br><span class="line">        link *a = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">        a-&gt;elem = i;</span><br><span class="line">        a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//将temp节点与新建立的a节点建立逻辑关系</span></span><br><span class="line">        temp-&gt;next = a;</span><br><span class="line">        <span class="comment">//指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对</span></span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想创建一个存储 <code>&#123;1,2,3,4&#125;</code> 且含头节点的链表，则 C 语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">link * <span class="title">initLink</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    link * p=(link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));<span class="comment">//创建一个头结点</span></span><br><span class="line">    link * temp=p;<span class="comment">//声明一个指针指向头结点，</span></span><br><span class="line">    <span class="comment">//生成链表</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        link *a=(link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">        a-&gt;elem=i;</span><br><span class="line">        a-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;next=a;</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表插入元素"><a href="#链表插入元素" class="headerlink" title="链表插入元素"></a>链表插入元素</h2><p>同顺序表一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：</p><ul><li>插入到链表的头部（头节点之后），作为首元节点；</li><li>插入到链表中间的某个位置；</li><li>插入到链表的最末端，作为链表中最后一个数据元素；</li></ul><p>虽然新元素的插入位置不固定，但是链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：</p><ol><li>将新结点的 next 指针指向插入位置后的结点；</li><li>将插入位置前结点的 next 指针指向插入结点；</li></ol><p>例如，我们在链表 <code>&#123;1,2,3,4&#125;</code> 的基础上分别实现在头部、中间部位、尾部插入新元素 5，其实现过程如图1 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181124/2-1Q1242005532U.gif" alt="链表中插入元素的 3 种情况示意图"><br>图 1 链表中插入元素的 3 种情况示意图</p><p>从图中可以看出，虽然新元素的插入位置不同，但实现插入操作的方法是一致的，都是先执行步骤 1 ，再执行步骤 2。</p><blockquote><p>注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，会导致插入位置后续的部分链表丢失，无法再实现步骤 1。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p为原链表，elem表示新数据元素，add表示新元素要插入的位置</span></span><br><span class="line"><span class="function">link * <span class="title">insertElem</span><span class="params">(link * p, <span class="keyword">int</span> elem, <span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">    link * temp = p;<span class="comment">//创建临时结点temp</span></span><br><span class="line">    link * c = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//首先找到要插入位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; add; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;插入位置无效\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建插入结点c</span></span><br><span class="line">    c = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">    c-&gt;elem = elem;</span><br><span class="line">    <span class="comment">//向链表中插入结点</span></span><br><span class="line">    c-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = c;</span><br><span class="line">    <span class="keyword">return</span>  p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表删除元素"><a href="#链表删除元素" class="headerlink" title="链表删除元素"></a>链表删除元素</h2><p>从链表中删除指定数据元素时，实则就是将存有该数据元素的节点从链表中摘除，但作为一名合格的程序员，要对存储空间负责，对不再利用的存储空间要及时释放。因此，从链表中删除数据元素需要进行以下 2 步操作：</p><ol><li>将结点从链表中摘下来;</li><li>手动释放掉结点，回收被结点占用的存储空间;</li></ol><p>其中，从链表上摘除某节点的实现非常简单，只需找到该节点的直接前驱节点 temp，执行一行程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp-&gt;next=temp-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure><p>例如，从存有 <code>&#123;1,2,3,4&#125;</code> 的链表中删除元素 3，则此代码的执行效果如图 2 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181124/2-1Q124200Q3239.gif" alt="链表删除元素示意图"><br>图 2 链表删除元素示意图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p为原链表，add为要删除元素的值</span></span><br><span class="line"><span class="function">link * <span class="title">delElem</span><span class="params">(link * p, <span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">    link * temp = p;</span><br><span class="line">    link * del = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//temp指向被删除结点的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; add; i++) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    del = temp-&gt;next;<span class="comment">//单独设置一个指针指向被删除结点，以防丢失</span></span><br><span class="line">    temp-&gt;next = temp-&gt;next-&gt;next;<span class="comment">//删除某个结点的方法就是更改前一个结点的指针域</span></span><br><span class="line">    <span class="built_in">free</span>(del);<span class="comment">//手动释放该结点，防止内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表查找元素"><a href="#链表查找元素" class="headerlink" title="链表查找元素"></a>链表查找元素</h2><p>在链表中查找指定数据元素，最常用的方法是：从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对，直至比对成功或遍历至链表最末端的 <code>NULL</code>（比对失败的标志）。</p><p>因此，链表中查找特定数据元素的 C 语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p为原链表，elem表示被查找元素、</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectElem</span><span class="params">(link * p, <span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建一个指针t，初始化为头指针 p</span></span><br><span class="line">    link * t = p;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//由于头节点的存在，因此while中的判断为t-&gt;next</span></span><br><span class="line">    <span class="keyword">while</span> (t-&gt;next) &#123;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;elem == elem) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//程序执行至此处，表示查找失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表更新元素"><a href="#链表更新元素" class="headerlink" title="链表更新元素"></a>链表更新元素</h2><p>更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。</p><p>直接给出链表中更新数据元素的 C 语言实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新函数，其中，add 表示更改结点在链表中的位置，newElem 为新的数据域的值</span></span><br><span class="line"><span class="function">link *<span class="title">amendElem</span><span class="params">(link * p, <span class="keyword">int</span> add, <span class="keyword">int</span> newElem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    link * temp = p;</span><br><span class="line">    temp = temp-&gt;next;<span class="comment">//在遍历之前，temp指向首元结点</span></span><br><span class="line">    <span class="comment">//遍历到被删除结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; add; i++) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;elem = newElem;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://data.biancheng.net/view/160.html">转载自：http://data.biancheng.net/view/160.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构—顺序表</title>
      <link href="post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>顺序表，全名顺序存储结构，是<a href="http://data.biancheng.net/view/157.html">线性表</a>的一种。通过《<a href="http://data.biancheng.net/view/157.html">线性表</a>》一节的学习我们知道，线性表用于存储逻辑关系为“一对一”的数据，顺序表自然也不例外。</p><p>不仅如此，顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。</p><p>例如，使用顺序表存储集合 <code>&#123;1,2,3,4,5&#125;</code>，数据最终的存储状态如图1 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181121/2-1Q121202555F0.gif" alt="img"><br>图 1 顺序存储结构示意图</p><p>由此我们可以得出，将“具有 ‘一对一’ 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构。</p><p>通过观察图 1 中数据的存储状态，我们可以发现，顺序表存储数据同<a href="http://data.biancheng.net/view/181.html">数组</a>非常接近。其实，顺序表存储数据使用的就是数组。</p><h2 id="顺序表的初始化"><a href="#顺序表的初始化" class="headerlink" title="顺序表的初始化"></a>顺序表的初始化</h2><p>使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：</p><ol><li>顺序表申请的存储容量；</li><li>顺序表的长度，也就是表中存储数据元素的个数；</li></ol><p>提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度。</p><p>因此，我们需要自定义顺序表，C 语言实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> * head;<span class="comment">//声明了一个名为head的长度不确定的数组，也叫“动态数组”</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//记录当前顺序表的长度</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">//记录顺序表分配的存储容量</span></span><br><span class="line">&#125;table;</span><br></pre></td></tr></table></figure><p>注意，head 是我们声明的一个未初始化的动态数组，不要只把它看做是普通的指针。</p><p>接下来开始学习顺序表的初始化，也就是初步建立一个顺序表。建立顺序表需要做如下工作：</p><ul><li>  给 head 动态数据申请足够大小的物理空间；</li><li>  给 size 和 length 赋初值；</li></ul><p>因此，C 语言实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Size 5 <span class="comment">//对Size进行宏定义，表示顺序表申请空间的大小</span></span></span><br><span class="line"><span class="function">table <span class="title">initTable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    table t;</span><br><span class="line">    t.head = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(Size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//构造一个空的顺序表，动态申请存储空间</span></span><br><span class="line">    <span class="keyword">if</span> (!t.head) <span class="comment">//如果申请失败，作出提示并直接退出程序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    t.length = <span class="number">0</span>;<span class="comment">//空表的长度初始化为0</span></span><br><span class="line">    t.size = Size;<span class="comment">//空表的初始存储空间为Size</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，整个顺序表初始化的过程被封装到了一个函数中，此函数返回值是一个已经初始化完成的顺序表。这样做的好处是增加了代码的可用性，也更加美观。与此同时，顺序表初始化过程中，要注意对物理空间的申请进行判断，对申请失败的情况进行处理，这里只进行了“输出提示信息和强制退出”的操作，可以根据你自己的需要对代码中的 if 语句进行改进。</p><p>通过在主函数中调用 initTable 语句，就可以成功创建一个空的顺序表，与此同时我们还可以试着向顺序表中添加一些元素，C 语言实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  <span class="comment">//malloc()、exit()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Size 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> * head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;table;</span><br><span class="line"><span class="function">table <span class="title">initTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    table t;</span><br><span class="line">    t.head = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(Size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!t.head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    t.length = <span class="number">0</span>;</span><br><span class="line">    t.size = Size;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出顺序表中元素的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayTable</span><span class="params">(table t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t.head[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    table t = initTable();</span><br><span class="line">    <span class="comment">//向顺序表中添加元素</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Size; i++) &#123;</span><br><span class="line">        t.head[i - <span class="number">1</span>] = i;</span><br><span class="line">        t.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;顺序表中存储的元素分别是：\n&quot;</span>);</span><br><span class="line">    displayTable(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><p>顺序表中存储的元素分别是：<br>1 2 3 4 5</p><p>可以看到，顺序表初始化成功。</p><h2 id="顺序表插入元素"><a href="#顺序表插入元素" class="headerlink" title="顺序表插入元素"></a>顺序表插入元素</h2><p>向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：</p><ol><li>插入到顺序表的表头；</li><li>在表的中间位置插入元素；</li><li>尾随顺序表中已有元素，作为顺序表中的最后一个元素；</li></ol><p>虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：</p><ul><li>将要插入位置元素以及后续的元素整体向后移动一个位置；</li><li>将元素放到腾出来的位置上；</li></ul><p>例如，在 <code>&#123;1,2,3,4,5&#125;</code> 的第 3 个位置上插入元素 6，实现过程如下：</p><ul><li><p>遍历至顺序表存储第 3 个数据元素的位置，如图 1 所示：<img src="http://data.biancheng.net/uploads/allimg/181122/2-1Q122201300X8.gif" alt="找到目标元素位置"><br>图 1 找到目标元素位置</p></li><li><p>将元素 3 以及后续元素 4 和 5 整体向后移动一个位置，如图 2 所示：<br><img src="http://data.biancheng.net/uploads/allimg/181122/2-1Q122201355232.gif" alt="将插入位置腾出"><br>图 2 将插入位置腾出</p></li><li><p>将新元素 6 放入腾出的位置，如图 3 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181122/2-1Q12220142H50.gif" alt="插入目标元素"><br>图 3 插入目标元素</p></li></ul><h2 id="顺序表删除元素"><a href="#顺序表删除元素" class="headerlink" title="顺序表删除元素"></a>顺序表删除元素</h2><p>从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。</p><p>后续元素整体前移一个位置，会直接将目标元素删除，可间接实现删除元素的目的。</p><p>例如，从 <code>&#123;1,2,3,4,5&#125;</code> 中删除元素 3 的过程如图 4 所示：</p><p><img src="http://data.biancheng.net/uploads/allimg/181122/2-1Q122201629521.gif" alt="img"><br>图 4 顺序表删除元素的过程示意图</p><p>因此，顺序表删除元素的 C 语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">table <span class="title">delTable</span><span class="params">(table t, <span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (add &gt; t.length || add &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;被删除元素的位置有误&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="keyword">for</span> (i = add; i &lt; t.length; i++) &#123;</span><br><span class="line">        t.head[i - <span class="number">1</span>] = t.head[i];</span><br><span class="line">    &#125;</span><br><span class="line">    t.length--;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序表查找元素"><a href="#顺序表查找元素" class="headerlink" title="顺序表查找元素"></a>顺序表查找元素</h2><p>顺序表中查找目标元素，可以使用多种查找算法实现，比如说二分查找算法、插值查找算法等。</p><p>这里，我们选择顺序查找算法，具体实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找函数，其中，elem表示要查找的数据元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectTable</span><span class="params">(table t, <span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.head[i] == elem) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//如果查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序表更改元素"><a href="#顺序表更改元素" class="headerlink" title="顺序表更改元素"></a>顺序表更改元素</h2><p>顺序表更改元素的实现过程是：</p><ol><li>找到目标元素；</li><li>直接修改该元素的值；</li></ol><p>顺序表更改元素的 C 语言实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更改函数，其中，elem为要更改的元素，newElem为新的数据元素</span></span><br><span class="line"><span class="function">table <span class="title">amendTable</span><span class="params">(table t, <span class="keyword">int</span> elem, <span class="keyword">int</span> newElem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> add = selectTable(t, elem);</span><br><span class="line">    t.head[add - <span class="number">1</span>] = newElem;<span class="comment">//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://data.biancheng.net/view/159.html">转载自：http://data.biancheng.net/view/159.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
      <url>post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><h2 id="数据结构三要数"><a href="#数据结构三要数" class="headerlink" title="数据结构三要数"></a>数据结构三要数</h2><h3 id="数据逻辑结构"><a href="#数据逻辑结构" class="headerlink" title="数据逻辑结构"></a>数据逻辑结构</h3><p>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。数据的逻辑结构分类见图 1-1。</p><ul><li>  集合结构中的数据元素之间除了 “同属于一个集合”的关系外，别无其他关系。</li><li>  线性结构中的数据元素之间只存在一对一的关系。即线性表：顺序表（一维数组）、链表、栈、队列</li><li>  树形结构中的数据元素之间存在一对多的关系。普通树、二叉树、线索二叉树等</li><li>  图状结构或网状结构结构中的数据元素之间存在多对多的关系。</li></ul><p><img src="/img/%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.jpg"></p><h3 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h3><p>存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。</p><ol><li><p>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元里，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。</p></li><li><p>链接存储：不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针表示元素之间的逻辑关系。其优点是不会出现碎片现象，充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，并且只能实现顺序存取。</p></li><li><p>索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每一项称为索引项，索引项的一般形式是：（关键字，地址）。其优点是检索速度快；缺点是增加了附加的索引表，会占用较多的存储空间。另外，在增加和删除数据时要修改索引表，因而会花费较多的时间。</p></li></ol><p> 4 .散列存储：根据元素的关键字直接计算出该元素的存储地址，又称为 Hash 存储。其优点是检索、增加和删除结点的操作都很快；缺点是如果散列函数不好可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。</p><h3 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h3><p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js事件循环</title>
      <link href="post/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>post/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>最近在看关于 js 的事件循环机制，（很多公司必问的面试题）看了几篇文章后准备总结出来分享给大家</p><blockquote><p>众所周知，JavaScript 是一门单线程语言，虽然在 html5 中提出了 Web-Worker ，但这并未改变 JavaScript 是单线程这一核心,，可是浏览器又能很好的处理异步请求，那么到底是为什么呢？</p></blockquote><p><strong>浏览器执行线程</strong></p><blockquote><p>在解释事件循环之前首先先解释一下浏览器的执行线程：<br>浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程，其中浏览器渲染进程（浏览器内核）属于浏览器多进程中的一种，主要负责页面渲染，脚本执行，事件处理等<br>其包含的线程有：GUI 渲染线程（负责渲染页面，解析 HTML，CSS 构成 DOM 树）、JS 引擎线程、事件触发线程、定时器触发线程、http 请求线程等主要线程</p></blockquote><h3 id="关于执行中的线程："><a href="#关于执行中的线程：" class="headerlink" title="关于执行中的线程："></a>关于执行中的线程：</h3><p><strong>主线程</strong>：也就是 js 引擎执行的线程，这个线程只有一个，页面渲染、函数处理都在这个主线程上执行。<br><strong>工作线程</strong>：也称幕后线程，这个线程可能存在于浏览器或 js 引擎内，与主线程是分开的，处理文件读取、网络请求等异步事件。</p><p><strong>任务队列( Event Queue )</strong></p><blockquote><p>所有的任务可以分为同步任务和异步任务，同步任务，顾名思义，就是立即执行的任务，同步任务一般会直接进入到主线程中执行；而异步任务，就是异步执行的任务，比如 ajax 网络请求，setTimeout 定时函数等都属于异步任务，异步任务会通过任务队列的机制(先进先出的机制)来进行协调。具体的可以用下面的图来大致说明一下：</p></blockquote><p><img src="https://pic4.zhimg.com/80/v2-1337770fcc29d10325ee4eb127496fff_1440w.jpg" alt="img"></p><h3 id="同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。-上述过程的不断重复就是我们说的-Event-Loop-事件循环-。"><a href="#同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。-上述过程的不断重复就是我们说的-Event-Loop-事件循环-。" class="headerlink" title="同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。"></a>同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。</h3><p>在事件循环中，每进行一次循环操作称为 tick，通过阅读规范可知，每一次 tick 的任务处理模型是比较复杂的，其关键的步骤可以总结如下：</p><h3 id="1-在此次-tick-中选择最先进入队列的任务-oldest-task-，如果有则执行-一次"><a href="#1-在此次-tick-中选择最先进入队列的任务-oldest-task-，如果有则执行-一次" class="headerlink" title="1.在此次 tick 中选择最先进入队列的任务( oldest task )，如果有则执行(一次)"></a>1.在此次 tick 中选择最先进入队列的任务( oldest task )，如果有则执行(一次)</h3><h3 id="2-检查是否存在-Microtasks-，如果存在则不停地执行，直至清空-Microtask-Queue"><a href="#2-检查是否存在-Microtasks-，如果存在则不停地执行，直至清空-Microtask-Queue" class="headerlink" title="2.检查是否存在 Microtasks ，如果存在则不停地执行，直至清空 Microtask Queue"></a>2.检查是否存在 Microtasks ，如果存在则不停地执行，直至清空 Microtask Queue</h3><h3 id="3-更新-render"><a href="#3-更新-render" class="headerlink" title="3.更新 render"></a>3.更新 render</h3><h3 id="4-主线程重复执行上述步骤"><a href="#4-主线程重复执行上述步骤" class="headerlink" title="4.主线程重复执行上述步骤"></a>4.主线程重复执行上述步骤</h3><p>可以用一张图来说明下流程：</p><p><img src="https://pic3.zhimg.com/80/v2-a38ad24f9109e1a4cb7b49cc1b90cafe_1440w.jpg" alt="img"></p><p>这里相信有人会想问，什么是 microtasks ?规范中规定，task 分为两大类, 分别是 Macro Task （宏任务）和 Micro Task（微任务）, 并且每个宏任务结束后, 都要清空所有的微任务,这里的 Macro Task 也是我们常说的 task ，有些文章并没有对其做区分，后面文章中所提及的 task 皆看做宏任务( macro task)。</p><h3 id="宏任务主要包含：script-整体代码-、setTimeout、setInterval、I-O、UI-交互事件、setImmediate-Node-js-环境"><a href="#宏任务主要包含：script-整体代码-、setTimeout、setInterval、I-O、UI-交互事件、setImmediate-Node-js-环境" class="headerlink" title="宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)"></a>宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)</h3><h3 id="微任务主要包含：Promise、MutaionObserver、process-nextTick-Node-js-环境"><a href="#微任务主要包含：Promise、MutaionObserver、process-nextTick-Node-js-环境" class="headerlink" title="微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)"></a>微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)</h3><p>setTimeout/Promise 等 API 便是任务源，而进入任务队列的是由他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中 setTimeout 与 setInterval 是同源的。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>掌握概念之后，我们来做一个例子强化一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>整体 script 作为第一个宏任务进入主线程，遇到 console.log，输出 script start<br>遇到 setTimeout，其回调函数被分发到宏任务 Event Queue 中<br>遇到 Promise，其 then 函数被分到到微任务 Event Queue 中,记为 then1，之后又遇到了 then 函数，将其分到微任务 Event Queue 中，记为 then2<br>遇到 console.log，输出 script end</p></blockquote><h3 id="至此，Event-Queue-中存在三个任务：宏任务：setTimeout-微任务：then1、then2"><a href="#至此，Event-Queue-中存在三个任务：宏任务：setTimeout-微任务：then1、then2" class="headerlink" title="至此，Event Queue 中存在三个任务：宏任务：setTimeout 微任务：then1、then2"></a>至此，Event Queue 中存在三个任务：宏任务：setTimeout 微任务：then1、then2</h3><p>执行微任务，首先执行 then1，输出 promise1, 然后执行 then2，输出 promise2，这样就清空了所有微任务<br>执行 setTimeout 任务，输出 setTimeout 至此，输出的顺序是：script start, script end, promise1, promise2, setTimeout</p><p>再来一个题目，来做个练习：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout1&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;timeout2&#x27;</span>), <span class="number">10</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这个题目就稍微有点复杂了，我们再分析下：</p><p>首先，事件循环从宏任务 (macrotask) 队列开始，最初始，宏任务队列中，只有一个 scrip t(整体代码)任务；当遇到任务源 (task source) 时，则会先分发任务到对应的任务队列中去。所以，就和上面例子类似，首先遇到了 console.log，输出 script start； 接着往下走，遇到 setTimeout 任务源，将其分发到任务队列中去，记为 timeout1； 接着遇到 promise，new promise 中的代码立即执行，输出 promise1, 然后执行 resolve ,遇到 setTimeout ,将其分发到任务队列中去，记为 timemout2, 将其 then 分发到微任务队列中去，记为 then1； 接着遇到 console.log 代码，直接输出 script end 接着检查微任务队列，发现有个 then1 微任务，执行，输出 then1 再检查微任务队列，发现已经清空，则开始检查宏任务队列，执行 timeout1,输出 timeout1； 接着执行 timeout2，输出 timeout2 至此，所有的都队列都已清空，执行完毕。其输出的顺序依次是：script start, promise1, script end, then1, timeout1, timeout2</p><p>用流程图看更清晰：</p><p><img src="https://pic1.zhimg.com/80/v2-a3ac02a230c49c9aa8c45af46eae2e1c_1440w.jpg" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有个小 tip：从规范来看，microtask 优先于 task 执行，所以如果有需要优先执行的逻辑，放入 microtask 队列会比 task 更早的被执行。</p><h3 id="最后的最后，记住，JavaScript-是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。"><a href="#最后的最后，记住，JavaScript-是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。" class="headerlink" title="最后的最后，记住，JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。"></a>最后的最后，记住，JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。</h3><p><a href="https://zhuanlan.zhihu.com/p/87684858">转载自：https://zhuanlan.zhihu.com/p/87684858</a></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js引擎解析过程</title>
      <link href="post/js%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
      <url>post/js%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h2><p>语法检查是 JavaScript 解析器的工作之一，包括 Î<strong>词法分析</strong>和<strong>语法分析</strong></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>把 JavaScript 代码（字符创）逐字转换为<strong>标记流</strong></p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a = (b - c);</span></span><br></pre></td></tr></table></figure><p>转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME <span class="string">&quot;a&quot;</span></span><br><span class="line">EQUALS</span><br><span class="line">OPEN_PARENTHESIS</span><br><span class="line">NAME <span class="string">&quot;b&quot;</span></span><br><span class="line">MINUS</span><br><span class="line">NAME <span class="string">&quot;c&quot;</span></span><br><span class="line">CLOSE_PARENTHESIS</span><br><span class="line">SEMICOLON</span><br></pre></td></tr></table></figure><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析：JavaScript 语法分析器在经过词法分析后，将记号流按照 ECMAScript 标准把词法分析所产生的记号生成<strong>语法树 AS</strong>T。</p><h2 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h2><h3 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h3><ol><li>将 JavaScript 引擎将语法检查正确后生成的语法树复制到当前执行上下文中。</li><li>JavaScript 引擎会对语法树当中的<strong>变量声明</strong>、<strong>函数声明</strong>以及<strong>函数的形参</strong>进行属性填充（ 声明提升）。</li></ol><p><strong>执行上下文包括：变量对象、作用域链、this</strong></p><ul><li>  变量对象（Variable Object）:由变量声明（var declaration）、函数声明（function declaration）、参数（arguments）构成。</li><li>  作用域链（Scope Chain）: 变量对象+父级作用域</li><li>  this ：一旦进入代码执行阶段的上下文中（预编译后的代码执行阶段），this 的值就不会变了。</li></ul><p><strong>变量对象/活动对象（VO/AO）属性填充</strong></p><ul><li><p>  变量对象/活动对象（VO/AO）填充的顺序：函数的形参-&gt;函数声明-&gt;变量声明；在变量对象/活动对象（VO/AO）中权重高低也按照函数的形参-&gt;函数声明-&gt;变量声明顺序来。</p></li><li><p>  函数的形参：执行上下文的变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为 undefined。</p></li><li><p>  函数声明：执行上下文的变量对象的一个属性，属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则会替换它的值。</p></li><li><p>变量声明：执行上下文的变量对象的一个属性，其属性名即为变量名，其值为 undefined；如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的函数声明的属性，该声明会被忽略掉，但其包含的赋值操作不会忽略。</p><pre><code>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数提升优先级高于变量提升，所以b取函数</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    alert(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b <span class="comment">// 被忽略，因为函数声明优先级高于变量声明</span></span><br><span class="line">alert(b) <span class="comment">// function b(a) &#123; alert(a); &#125;</span></span><br><span class="line">b() <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>经过“预解析”创建执行上下文之后，就进入执行代码阶段，VO/AO 就会重新赋予真实的值，“预解析”阶段赋予的 undefined 值会被覆盖。</p><p>此阶段才是程序真正进入执行阶段，Javascript 引擎会一行一行的读取并运行代码。此时那些变量都会重新赋值。</p><p>假如变量是定义在函数内的，而函数从头到尾都没被激活（调用）的话，则变量值永远都是 undefined 值。</p><p>进入了执行代码阶段，在“预解析”阶段所创建的任何东西可能都会改变，不仅仅是 VO/AO，this 和作用域链也会因为某些语句而改变，后面会讲到。</p><p>​ <strong>作用域链（Scope Chain）</strong></p><p>​ 作用域链是处理标识符时进行<strong>变量查询</strong>的变量对象列表，每个执行上下文都有自己的变量对象：对于全局上下文而言，其变量对象就是全局对象本身；对于函数而言，其变量对象就是活动对象。</p><p><strong>作用域链和执行上下文的关系</strong></p><p>在 Javascript 中只有函数能规定作用域，全局执行上下文中的 Scope 是全局上下文中的属性，也是最外层的作用域链。<br>函数内部的属性（作用域）是在“预解析”的时候就已经存在的了，它包含了所有上层变量对象，并一直保存在函数中。就算函数永远都没被激活（调用），也都还是存在函数对象上。</p><p><strong>执行上下文定义的 Scope 属性变化过程</strong></p><p>执行上下文中的[AO]是函数的活动对象，而[[Scope]]则是该函数属性作用域。当前函数的 AO 永远是在最前面的，保存在堆栈上，而每当函数激活的时候，这些 AO 都会压栈到该堆栈上，查询变量是先从栈顶开始查找，也就是说作用域链的栈顶永远是当前正在执行的代码所在环境的 VO/AO（当函数调用结束后，则会从栈顶移除）。</p><p>通俗点讲就是：JavaScript 解释器通过作用域链将不同执行位置上的变量对象串连成列表，并借助这个列表帮助 JavaScript 解释器检索变量的值。作用域链相当于一个索引表，并通过编号来存储它们的嵌套关系。当 JavaScript 解释器检索变量的值，会按着这个索引编号进行快速查找，直到找到全局对象为止，如果没有找到值，则传递一个特殊的 undefined 值。</p><p>是不是又想到了一条 JavaScript 高效准则：为什么说在该函数内定义的变量，能减少函数嵌套能提高 JavaScript 的效率？因为函数定义的变量，此变量永远在栈顶，这样子查询变量的时间变短了。</p><p><strong>作用域链特性</strong><br>闭包是作用域链特性的应用</p><p>保证查询有序的访问所有变量和函数<br>作用域链感觉就是一个 VO 链表，当访问一个变量时，先在链表的第一个 VO 上查找，如果没有找到则继续在第二个 VO 上查找，直到搜索结束，也就是搜索到全局执行环境的 VO 中。这也就形成了作用域链的概念。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js原型链</title>
      <link href="post/js%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>post/js%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/prototype.jpg" alt="prototype"></p><h3 id="先看第一行"><a href="#先看第一行" class="headerlink" title="先看第一行"></a>先看第一行</h3><p>我们定义的 show 函数在 Foo.prototype 中，当我们执行 f1.show()时，js 发现 f1 本身没有 show 这个属性，所以它就到 f1 的原型（也就是__proto__指向的对象）去找，找到了就可以调用。</p><blockquote><p>注：每个对象都有一个方法 hasOwnProperty()来检查对象本身是否有某个属性，如果有则返回 true；如果这个属性在它的原型链上或原型链上都没有，则返回 false；</p></blockquote><p>图片第一行告诉了我们 4 点：</p><ol><li>所有函数都有一个 prototype 指针，指向原型对象，如图中的 Foo 的 prototype 指针。prototype 指针的意义是，当我们使用这个构造函数 new 出新对象的时候，新对象的原型是谁。</li><li>构造函数的 prototype 所指向的原型对象有一个 constructor 指针，指回构造函数。如图中 Foo.prototype 的 constructor 指针指向 Foo。constructor 指针有助于我们找到一个对象的构造函数是谁。</li><li>__proto__每个对象都有，js 在 new 一个对象的时候，会将它的__proto__指向构造函数的 prototype 指向的那个对象。在上图中，f1、f2 这些实例对象的__proto__都指向了 Foo.prototype。</li><li>如果一个对象的__proto__`指向了另一个对象，那么前者就继承了后者的所有属性。</li></ol><h3 id="接着图片往下看，它展示了-js-对象继承关系"><a href="#接着图片往下看，它展示了-js-对象继承关系" class="headerlink" title="接着图片往下看，它展示了 js 对象继承关系"></a>接着图片往下看，它展示了 js 对象继承关系</h3><p>我们先看看 Foo 的原型吧！Foo 是一个函数，它的构造函数是 js 内部的 function Function()，Function 的 prototype 指向了一个对象 Function.prototype，因此 Foo 的__proto__就指向了 Function.prototype，如图。</p><blockquote><p>所有的函数都以 function Function()为构造函数，因此，所有函数（包括 function Function()和 function Object()）的__proto__都指向 Function.prototype 这个对象，这个对象中定义了所有函数都共有的方法，比如 call()、apply()等。</p></blockquote><p>我们继续深入下去，Function.prototype 这个对象，它就是一个普通的对象，它的构造函数是 js 内置的 function Object()，function Object()的 prototype 指向 Object.prototype，因此 Function.prototype.__proto__就指向 Object.prototype，这个对象中定义了所有对象共有的属性，比如我们之前说的 hasOwnProperty()和 toString()等。</p><blockquote><p>同理，Foo.prototype 和其他自定义的对象也是__proto__指向 Object.prototype 对象，就不需要说明了。</p></blockquote><p>Object.prototype 就是原型链的终点了，它的__proto__是 null，js 查找属性时，如果到这里还没有找到，那就是 undefined 了。</p><p>到这里就不难理解为什么我们说在 js 中，函数也是对象了，它就是继承自对象的！</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> prototype </tag>
            
            <tag> 原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强大的Grid网格布局</title>
      <link href="post/%E5%BC%BA%E5%A4%A7%E7%9A%84Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"/>
      <url>post/%E5%BC%BA%E5%A4%A7%E7%9A%84Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Grid 网格布局是网页最强大的布局方案</p><p><img src="/img/grid.png"></p><p>上图就是 Grid 的拿手好戏</p><p>Grid 布局将容器划分为“行”和“列”横纵分布的“单元格”，组成“二维布局”，然后将“项目”放置在指定的单元格内，形成复杂布局。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>容器和项目</strong></p><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，最外层的 &lt;div&gt;元素就是容器，内层的三个&lt;div&gt;元素就是项目。<br>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的&lt;p&gt;元素就不是项目。Grid 布局只对项目生效。</p><p><strong>行和列</strong></p><p>容器水平方向区域称为：“行” （row），垂直方向区域称为：“列” （column）</p><p><img src="/img/grid-row-column.png"></p><p><strong>单元格</strong></p><p>行和列的交叉区域，称为”单元格”（cell）。<br>正常情况下，n 行和 m 列会产生 n x m 个单元格。比如，3 行 3 列会产生 9 个单元格。</p><p><strong>网格线</strong></p><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。<br>正常情况下，n 行有 n + 1 根水平网格线，m 列有 m + 1 根垂直网格线，比如三行就有四根水平网格线。</p><p><img src="/img/grid-line.png"></p><p>上图是一个 4 x 4 的网格，共有 5 根水平网格线和 5 根垂直网格线。</p><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性</p><h3 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h3><p>display: grid 指定一个容器采用网格布局。</p><pre><code>注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</code></pre><h3 id="grid-template-columns-grid-template-rows"><a href="#grid-template-columns-grid-template-rows" class="headerlink" title="grid-template-columns/grid-template-rows"></a>grid-template-columns/grid-template-rows</h3><p>容器指定了网格布局以后，接着就要划分行和列。grid-template-columns 属性定义每一列的列宽，grid-template-rows 属性定义每一行的行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定了一个三行三列的网格，列宽和行高都是 100px。</p><p><img src="/img/grid-template-1.png"></p><p>除了使用绝对单位，也可以使用百分比。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">    grid-template-rows: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>repeat()</strong><br>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用 repeat()函数，简化重复的值。上面的代码用 repeat()改写如下。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br><span class="line">    grid-template-rows: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> repeat()接受两个参数，第一个参数是重复的次数（上例是 3），第二个参数是所要重复的值。</p><p> repeat()重复某种模式也是可以的。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">20px</span> <span class="number">80px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面代码定义了 6 列，第一列和第四列的宽度为 100px，第二列和第五列为 20px，第三列和第六列为 80px。</p><p> <img src="/img/grid-template-2.png"></p></li><li><p><strong>auto-fill 关键字</strong><br>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用 auto-fill 关键字表示自动填充。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面代码表示每列宽度 100px，然后自动填充，直到容器不能放置更多的列。</p><p> <img src="/img/grid-auto-fill.png"></p></li><li><p><strong>fr 关键字</strong></p><p> 为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面代码表示两个相同宽度的列。</p><p> <img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032509.png" alt="1_bg2019032509"></p><p> <code>fr</code>可以与绝对长度的单位结合使用，这时会非常方便。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面代码表示，第一列的宽度为 150 像素，第二列的宽度是第三列的一半。</p><p> <img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032510.png" alt="bg2019032510"></p></li><li><p><strong>minmax()</strong></p><p> <code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure><p> 上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p></li><li><p>auto 关键字</p><p> <code>auto</code>关键字表示由浏览器自己决定长度。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br></pre></td></tr></table></figure><p> 上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>，且这个值大于最大宽度。</p></li><li><p>网格线的名称</p><p> <code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">    grid-template-rows: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面代码指定网格布局为 3 行 x 3 列，因此有 4 根垂直网格线和 4 根水平网格线。方括号里面依次是这八根线的名字。</p><p> 网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。</p></li><li><p>布局实例</p><p> <code>grid-template-columns</code>属性对于网页布局非常有用。两栏式布局只需要一行代码。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面代码将左边栏设为 70%，右边栏设为 30%。</p><p> 传统的十二网格布局，写起来也很容易。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">12</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure></li></ol><h3 id="grid-row-gap、grid-column-gap、grid-gap"><a href="#grid-row-gap、grid-column-gap、grid-gap" class="headerlink" title="grid-row-gap、grid-column-gap、grid-gap"></a>grid-row-gap、grid-column-gap、grid-gap</h3><p><code>grid-row-gap</code>属性设置行与行的间隔（行间距），<code>grid-column-gap</code>属性设置列与列的间隔（列间距）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    grid-row-gap: <span class="number">20px</span>;</span><br><span class="line">    grid-<span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，grid-row-gap 用于设置行间距，grid-column-gap 用于设置列间距。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032511.png" alt="bg2019032511"></p><p><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式，语法如下。</p><p>因此，上面一段 CSS 代码等同于下面的代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    grid-gap: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>根据最新标准，上面三个属性名的<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>，<code>grid-gap</code>写成<code>gap</code>。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    gap: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="grid-template-area"><a href="#grid-template-area" class="headerlink" title="grid-template-area"></a>grid-template-area</h3><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-template-areas:</span><br><span class="line">        <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">        <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">        <span class="string">&#x27;g h i&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码先划分出 9 个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p><p>多个单元格合并成一个区域的写法如下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas:</span><br><span class="line">    <span class="string">&#x27;a a a&#x27;</span></span><br><span class="line">    <span class="string">&#x27;b b b&#x27;</span></span><br><span class="line">    <span class="string">&#x27;c c c&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码将 9 个单元格分成<code>a</code>、<code>b</code>、<code>c</code>三个区域。</p><p>下面是一个布局实例。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas:</span><br><span class="line">    <span class="string">&#x27;header header header&#x27;</span></span><br><span class="line">    <span class="string">&#x27;main main sidebar&#x27;</span></span><br><span class="line">    <span class="string">&#x27;footer footer footer&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，顶部是页眉区域<code>header</code>，底部是页脚区域<code>footer</code>，中间部分则为<code>main</code>和<code>sidebar</code>。</p><p>如果某些区域不需要利用，则使用”点”（<code>.</code>）表示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas:</span><br><span class="line">    <span class="string">&#x27;a . c&#x27;</span></span><br><span class="line">    <span class="string">&#x27;d . f&#x27;</span></span><br><span class="line">    <span class="string">&#x27;g . i&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p><p><strong>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</strong></p><p><strong>比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</strong></p><h3 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h3><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。<img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032506.png" alt="bg2019032506"></p><p>这个顺序由<code>grid-auto-flow</code>属性决定，默认值是<code>row</code>，即”先行后列”。也可以将它设成<code>column</code>，变成”先列后行”。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: column;</span><br></pre></td></tr></table></figure><p>上面代码设置了 column 以后，放置顺序就变成了下图。<img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032512.png" alt="bg2019032512"></p><p>grid-auto-flow 属性除了设置成 row 和 column，还可以设成 row dense 和 column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p><p>下面的例子让 1 号项目和 2 号项目各占据两个单元格，然后在默认的 grid-auto-flow: row 情况下，会产生下面这样的布局。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032513.png" alt="bg2019032513"></p><p>上图中，1 号项目后面的位置是空的，这是因为 3 号项目默认跟着 2 号项目，所以会排在 2 号项目后面。</p><p>现在修改设置，设为<code>row dense</code>，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: row dense;</span><br></pre></td></tr></table></figure><p>上面代码的效果如下。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032514.png" alt="bg2019032514"></p><p>上图会先填满第一行，再填满第二行，所以 3 号项目就会紧跟在 1 号项目的后面。8 号项目和 9 号项目就会排到第四行。</p><p>如果将设置改为<code>column dense</code>，表示”先列后行”，并且尽量填满空格</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: column dense;</span><br></pre></td></tr></table></figure><p>上面代码的效果如下。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032515.png" alt="bg2019032515"></p><p>上图会先填满第一列，再填满第 2 列，所以 3 号项目在第一列，4 号项目在第二列。8 号项目和 9 号项目被挤到了第四列。</p><h3 id="Justify-items-algin-items-place-items"><a href="#Justify-items-algin-items-place-items" class="headerlink" title="Justify-items/algin-items/place-items"></a>Justify-items/algin-items/place-items</h3><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    justify-items: start | end | center | stretch;</span><br><span class="line">    <span class="attribute">align-items</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性的写法完全相同，都可以取下面这些值。</p><ul><li>  start：对齐单元格的起始边缘。</li><li>  end：对齐单元格的结束边缘。</li><li>  center：单元格内部居中。</li><li>  stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    justify-items: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，单元格的内容左对齐，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032516.png" alt="bg2019032516"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，单元格的内容头部对齐，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032517.png" alt="bg2019032517"></p><p><strong><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-items: &lt;align-items&gt; &lt;justify-items&gt;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-items: start end;</span><br></pre></td></tr></table></figure><p>如果省略第二个值，则浏览器认为与第一个值相等。</p><h3 id="justify-content-align-content-place-content"><a href="#justify-content-align-content-place-content" class="headerlink" title="justify-content/align-content/place-content"></a>justify-content/align-content/place-content</h3><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">    <span class="attribute">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以<code>justify-content</code>属性为例，<code>align-content</code>属性的图完全一样，只是将水平方向改成垂直方向。）</p><ul><li>  start - 对齐容器的起始边框。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032519.png" alt="bg2019032519"></p><ul><li>  end - 对齐容器的结束边框。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032518.png" alt="bg2019032518"></p><ul><li>  stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032521.png" alt="bg2019032521"></p><ul><li>  space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032522.png" alt="bg2019032522"></p><ul><li>  space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032523.png" alt="bg2019032523"></p><ul><li>  space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032524.png" alt="bg2019032524"></p><p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: space-around space-evenly;</span><br></pre></td></tr></table></figure><p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p><h3 id="grid-auto-rows-grid-auto-columns"><a href="#grid-auto-rows-grid-auto-columns" class="headerlink" title="grid-auto-rows/grid-auto-columns"></a>grid-auto-rows/grid-auto-columns</h3><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有 3 列，但是某一个项目指定在第 5 行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有 3 列，但是某一个项目指定在第 5 行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p>grid-auto-columns 属性和 grid-auto-rows 属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与 grid-template-columns 和 grid-template-rows 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-<span class="attribute">auto</span>-rows: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定新增的行高统一为 50px（原始的行高为 100px）。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032525.png" alt="bg2019032525"></p><h3 id="grid-template-grid"><a href="#grid-template-grid" class="headerlink" title="grid-template / grid"></a>grid-template / grid</h3><p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p><p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p><p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性"><a href="#grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性" class="headerlink" title="grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性"></a>grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性</h3><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><ul><li>  <code>grid-column-start</code>属性：左边框所在的垂直网格线</li><li>  <code>grid-column-end</code>属性：右边框所在的垂直网格线</li><li>  <code>grid-row-start</code>属性：上边框所在的水平网格线</li><li>  <code>grid-row-end</code>属性：下边框所在的水平网格线</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    grid-column-start: <span class="number">2</span>;</span><br><span class="line">    grid-column-end: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/yukobuf/edit?css,output">上面代码</a>指定，1 号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032526.png" alt="img"></p><p>上图中，只指定了 1 号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p><p>除了 1 号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成<code>column</code>、<code>row dense</code>和<code>column dense</code>，看看其他项目的位置发生了怎样的变化。</p><p>下面的例子是指定四个边框位置的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    grid-column-start: <span class="number">1</span>;</span><br><span class="line">    grid-column-end: <span class="number">3</span>;</span><br><span class="line">    grid-row-start: <span class="number">2</span>;</span><br><span class="line">    grid-row-end: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032527.png" alt="img"></p><p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    grid-column-start: header-start;</span><br><span class="line">    grid-column-end: header-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p><p>这四个属性的值还可以使用<code>span</code>关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    grid-column-start: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，1 号项目的左边框距离右边框跨越 2 个网格。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032528.png" alt="img"></p><p>这与下面的代码效果完全一样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    grid-column-end: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p><h3 id="grid-column-属性，-grid-row-属性"><a href="#grid-column-属性，-grid-row-属性" class="headerlink" title="grid-column 属性， grid-row 属性"></a>grid-column 属性， grid-row 属性</h3><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    grid-column: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">    grid-row: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    grid-column: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">    grid-row: <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    grid-column-start: <span class="number">1</span>;</span><br><span class="line">    grid-column-end: <span class="number">3</span>;</span><br><span class="line">    grid-row-start: <span class="number">1</span>;</span><br><span class="line">    grid-row-end: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，项目<code>item-1</code>占据第一行，从第一根列线到第三根列线。</p><p>这两个属性之中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">    grid-column: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">    grid-row: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">    grid-column: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">    grid-row: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/volugow/edit?html,css,output">上面代码</a>中，项目<code>item-1</code>占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032529.png" alt="img"></p><p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    grid-column: <span class="number">1</span>;</span><br><span class="line">    grid-row: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，项目<code>item-1</code>占据左上角第一个网格。</p><h3 id="grid-area-属性"><a href="#grid-area-属性" class="headerlink" title="grid-area 属性"></a>grid-area 属性</h3><p><code>grid-area</code>属性指定项目放在哪一个区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    grid-area: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jsbin.com/qokexob/edit?css,output">上面代码</a>中，1 号项目位于<code>e</code>区域，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032530.png" alt="img"></p><p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output">例子</a>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    grid-area: <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="justify-self-属性，-align-self-属性，-place-self-属性"><a href="#justify-self-属性，-align-self-属性，-place-self-属性" class="headerlink" title="justify-self 属性， align-self 属性， place-self 属性"></a>justify-self 属性， align-self 属性， place-self 属性</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    justify-self: start | end | center | stretch;</span><br><span class="line">    <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个属性都可以取下面四个值。</p><ul><li>  start：对齐单元格的起始边缘。</li><li>  end：对齐单元格的结束边缘。</li><li>  center：单元格内部居中。</li><li>  stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><p>下面是<code>justify-self: start</code>的例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    justify-self: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032532.png" alt="img"></p><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-self: &lt;align-self&gt; &lt;justify-self&gt;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">place-self: center center;</span><br></pre></td></tr></table></figure><p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">本文转载自阮一峰的网络日志-CSS Grid 网格布局教程</a></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> Grid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前端面筋 (JS篇)</title>
      <link href="post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart4/"/>
      <url>post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart4/</url>
      
        <content type="html"><![CDATA[<h3 id="JS-中的-8-种数据类型及区别"><a href="#JS-中的-8-种数据类型及区别" class="headerlink" title="JS 中的 8 种数据类型及区别"></a>JS 中的 8 种数据类型及区别</h3><p>包括值类型(基本对象类型)和引用类型(复杂对象类型)</p><p><strong>基本类型(值类型)：</strong> Number(数字),String(字符串),Boolean(布尔),Symbol(符号),null(空),undefined(未定义)在内存中占据固定大小，保存在栈内存中</p><p><strong>引用类型(复杂数据类型)：</strong> Object(对象)、Function(函数)。其他还有 Array(数组)、Date(日期)、RegExp(正则表达式)、特殊的基本包装类型(String、Number、Boolean) 以及单体内置对象(Global、Math)等 引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。</p><h3 id="JS-中的数据类型检测方案"><a href="#JS-中的数据类型检测方案" class="headerlink" title="JS 中的数据类型检测方案"></a>JS 中的数据类型检测方案</h3><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>) <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>) <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">console</span>.log()) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>优点：能够快速区分基本数据类型</p><p>缺点：不能将 Object、Array 和 Null 区分，都返回 object</p><h4 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>优点：能够区分 Array、Object 和 Function，适合用于判断自定义的类实例对象</p><p>缺点：Number，Boolean，String 基本数据类型不能判断</p><h4 id="3-Object-prototype-toString-call"><a href="#3-Object-prototype-toString-call" class="headerlink" title="3.Object.prototype.toString.call()"></a>3.Object.prototype.toString.call()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">1</span>)) <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">true</span>)) <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="string">&#x27;mc&#x27;</span>)) <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call([])) <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(&#123;&#125;)) <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)) <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">undefined</span>)) <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">null</span>)) <span class="comment">//[object Null]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>优点：精准判断数据类型</p><p>缺点：写法繁琐不容易记，推荐进行封装后使用</p><h3 id="var-amp-amp-let-amp-amp-const"><a href="#var-amp-amp-let-amp-amp-const" class="headerlink" title="var &amp;&amp; let &amp;&amp; const"></a>var &amp;&amp; let &amp;&amp; const</h3><p>ES6 之前创建变量用的是 var,之后创建变量用的是 let/const</p><p><strong>三者区别</strong>：</p><ol><li>var 定义的变量，<code>没有块的概念，可以跨块访问</code>, 不能跨函数访问。<br>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。<br>const 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。</li><li>var 可以<code>先使用，后声明</code>，因为存在变量提升；let 必须先声明后使用。</li><li>var 是允许在相同作用域内<code>重复声明同一个变量</code>的，而 let 与 const 不允许这一现象。</li><li>在全局上下文中，基于 let 声明的全局变量和全局对象 GO（window）没有任何关系 ;<br>var 声明的变量会和 GO 有映射关系；</li><li><code>会产生暂时性死区</code>：</li></ol><blockquote><p>暂时性死区是浏览器的 bug：检测一个未被声明的变量类型时，不会报错，会返回 undefined<br>如：console.log(typeof a) //undefined<br>而：console.log(typeof a)//未声明之前不能使用<br>let a</p></blockquote><ol><li>let /const/function 会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于 let 的块作用特征即可解决</li></ol><h3 id="JS-垃圾回收机制"><a href="#JS-垃圾回收机制" class="headerlink" title="JS 垃圾回收机制"></a>JS 垃圾回收机制</h3><ol><li><p>项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。</p></li><li><p>浏览器垃圾回收机制/内存回收机制:</p><blockquote><p>浏览器的<code>Javascript</code>具有自动垃圾回收机制(<code>GC:Garbage Collecation</code>)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p></blockquote><p> <strong>标记清除</strong>:在<code>js</code>中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间。<br> <strong>谷歌浏览器</strong>：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。<br> <strong>IE 浏览器</strong>：“引用计数法”，当前内存被占用一次，计数累加 1 次，移除占用就减 1，减到 0 时，浏览器就回收它。</p></li><li><p>优化手段：内存优化 ; 手动释放：取消内存的占用即可。</p><p> （1）堆内存：fn = null 【null：空指针对象】</p><p> （2）栈内存：把上下文中，被外部占用的堆的占用取消即可。</p></li><li><p>内存泄漏</p><p> 在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器</p></li></ol><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>创建函数的时候，已经声明了当前函数的作用域==&gt;<code>当前创建函数所处的上下文</code>。如果是在全局下创建的函数就是<code>[[scope]]:EC(G)</code>，函数执行的时候，形成一个全新的私有上下文<code>EC(FN)</code>，供字符串代码执行(进栈执行)</p><p>定义：简单来说作用域就是变量与函数的可访问范围，<code>由当前环境与上层环境的一系列变量对象组成</code> 1.全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。 2.函数作用域：在固定的代码片段才能被访问</p><p>作用：作用域最大的用处就是<code>隔离变量</code>，不同作用域下同名变量不会有冲突。</p><p><strong>作用域链参考链接</strong>一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p><h3 id="闭包的两大作用：保存-保护"><a href="#闭包的两大作用：保存-保护" class="headerlink" title="闭包的两大作用：保存/保护"></a>闭包的两大作用：保存/保护</h3><ul><li><p><strong>闭包的概念</strong></p><p>  函数执行时形成的私有上下文 EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文。 函数执行函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会被释放，不论释放与否，他的作用是：</p></li></ul><p>（1）保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；</p><p>（2）保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</p><p>我们把函数执行形成私有上下文，来保护和保存私有变量机制称为<code>闭包</code>。</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数–《JavaScript 高级程序设计》</p></blockquote><p><strong>稍全面的回答</strong>： 在 js 中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,即使上级函数执行完后作用域内的值也不会被销毁。</p><ul><li><p><strong>闭包的特性</strong>：</p><ul><li><p>1、内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。</p><p>  1.1.闭包是密闭的容器，，类似于 set、map 容器，存储数据的</p><p>  1.2.闭包是一个对象，存放数据的格式为 key-value 形式</p></li><li><p>  2、函数嵌套函数</p></li><li><p>  3、本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</p></li></ul></li><li><p><strong>闭包形成的条件</strong>：</p><ol><li>函数的嵌套</li><li>内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li></ol></li><li><p><strong>闭包的用途</strong>：</p><ol><li>模仿块级作用域</li><li>保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li>封装私有化变量</li><li>创建模块</li></ol></li><li><p><strong>闭包应用场景</strong></p><p>  闭包的两个场景，闭包的两大作用：<code>保存/保护</code>。 在开发中, 其实我们随处可见闭包的身影, 大部分前端 JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送 ajax 请求成功|失败的回调;setTimeout 的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。</p></li><li><p>  <strong>闭包的优点</strong>：延长局部变量的生命周期</p></li><li><p>  <strong>闭包缺点</strong>：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p></li></ul><h3 id="JS-中-this-的五种情况"><a href="#JS-中-this-的五种情况" class="headerlink" title="JS 中 this 的五种情况"></a>JS 中 this 的五种情况</h3><ol><li>作为普通函数执行时，<code>this</code>指向<code>window</code>。</li><li>当函数作为对象的方法被调用时，<code>this</code>就会指向<code>该对象</code>。</li><li>构造器调用，<code>this</code>指向<code>返回的这个对象</code>。</li><li>箭头函数 箭头函数的<code>this</code>绑定看的是<code>this所在函数定义在哪个对象下</code>，就绑定哪个对象。如果有嵌套的情况，则 this 绑定到最近的一层对象上。</li><li>基于 Function.prototype 上的 <code>apply 、 call 和 bind </code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，`` bind<code>方法通过传入一个对象，返回一个</code>this<code>绑定了传入对象的新函数。这个函数的 </code>this<code>指向除了使用</code>new `时会被改变，其他情况下都不会改变。若为空默认是指向全局对象 window。</li></ol><h3 id="原型-amp-amp-原型链"><a href="#原型-amp-amp-原型链" class="headerlink" title="原型 &amp;&amp; 原型链"></a>原型 &amp;&amp; 原型链</h3><p><strong>原型关系：</strong></p><ul><li>  每个 class 都有显示原型 prototype</li><li>  每个实例都有隐式原型 _ proto_</li><li>  实例的* proto*指向对应 class 的 prototype</li></ul><p>‌ <strong>原型:</strong> 在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个<code>函数对象</code>都有一个<code>prototype</code> 属性，这个属性指向函数的<code>原型对象</code>。</p><p>原型链：函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针<strong>proto</strong>,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用<strong>proto</strong>一直指向 Object 的原型对象上，而 Object 原型对象用 Object.prototype.** proto** = null 表示原型链顶端。如此形成了 js 的原型链继承。同时所有的 js 对象都有 Object 的基本防范</p><p><strong>特点:</strong> <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><h3 id="new-运算符的实现机制"><a href="#new-运算符的实现机制" class="headerlink" title="new 运算符的实现机制"></a>new 运算符的实现机制</h3><ol><li>首先创建了一个新的<code>空对象</code></li><li><code>设置原型</code>，将对象的原型设置为函数的<code>prototype</code>对象。</li><li>让函数的<code>this</code>指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li><li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><h3 id="EventLoop-事件循环"><a href="#EventLoop-事件循环" class="headerlink" title="EventLoop 事件循环"></a>EventLoop 事件循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JS`是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，`Promise.then`，`MutationObserver`，宏任务的话就是`setImmediate setTimeout setInterval</span><br></pre></td></tr></table></figure><p>JS 运行的环境。一般为浏览器或者 Node。 在浏览器环境中，有 JS 引擎线程和渲染线程，且两个线程互斥。 Node 环境中，只有 JS 线程。 不同环境执行机制有差异，不同任务进入不同 Event Queue 队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p><h4 id="浏览器中的事件环（Event-Loop"><a href="#浏览器中的事件环（Event-Loop" class="headerlink" title="浏览器中的事件环（Event Loop)"></a><strong>浏览器中的事件环（Event Loop)</strong></h4><p>事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p><ul><li><p>  eventLoop 是由 JS 的宿主环境（浏览器）来实现的；</p></li><li><p>事件循环可以简单的描述为以下四个步骤:</p><ol><li>函数入栈，当 Stack 中执行到异步任务的时候，就将他丢给 WebAPIs,接着执行同步任务,直到 Stack 为空；</li><li>此期间 WebAPIs 完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>执行栈为空时，Event Loop 把微任务队列执行清空；</li><li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入 Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复 4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ol><p>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/342e581223d2471d9484fc48beb9f8e1~tplv-k3u1fbpfcp-watermark.awebp" alt="事件循环流程"></p></li><li><p>浏览器中的任务源(task):</p><ul><li><code>宏任务(macrotask)</code>：<br>  宿主环境提供的，比如浏览器<br>  ajax、setTimeout、setInterval、setTmmediate(只兼容 ie)、script、requestAnimationFrame、messageChannel、UI 渲染、一些浏览器 api</li><li><code>微任务(microtask)</code>：<br>  语言本身提供的，比如 promise.then<br>  then、queueMicrotask(基于 then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve</li></ul></li></ul><h4 id="Node-环境中的事件环（Event-Loop"><a href="#Node-环境中的事件环（Event-Loop" class="headerlink" title="Node 环境中的事件环（Event Loop)"></a><strong>Node 环境中的事件环（Event Loop)</strong></h4><p><code>Node</code>是基于 V8 引擎的运行在服务端的<code>JavaScript</code>运行环境，在处理高并发、I/O 密集(文件操作、网络操作、数据库操作等)场景有明显的优势。虽然用到也是 V8 引擎，但由于服务目的和环境不同，导致了它的 API 与原生 JS 有些区别，其 Event Loop 还要处理一些 I/O，比如新的网络连接等，所以 Node 的 Event Loop(事件环机制)与浏览器的是不太一样。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e362c1770f62428fbf3faabd99d2a64c~tplv-k3u1fbpfcp-watermark.awebp" alt="2020120317343116.png"> 执行顺序如下：</p><ul><li>  <code>timers</code>: 计时器，执行 setTimeout 和 setInterval 的回调</li><li>  <code>pending callbacks</code>: 执行延迟到下一个循环迭代的 I/O 回调</li><li>  <code>idle, prepare</code>: 队列的移动，仅系统内部使用</li><li>  <code>poll轮询</code>: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</li><li>  <code>check</code>: 执行<code>setImmediate</code>回调，setImmediate 在这里执行</li><li>  <code>close callbacks</code>: 执行<code>close</code>事件的<code>callback</code>，一些关闭的回调函数，如：socket.on(‘close’, …)</li></ul><h3 id="setTimeout、Promise、Async-Await-的区别"><a href="#setTimeout、Promise、Async-Await-的区别" class="headerlink" title="setTimeout、Promise、Async/Await 的区别"></a>setTimeout、Promise、Async/Await 的区别</h3><ol><li><p>setTimeout</p><p> settimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行。</p></li><li><p>Promise</p><p> Promise 本身是<strong>同步的立即执行函数</strong>， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>async/await</p><p> async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line">async1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ol><h3 id="Async-Await-如何通过同步的方式实现异步"><a href="#Async-Await-如何通过同步的方式实现异步" class="headerlink" title="Async/Await 如何通过同步的方式实现异步"></a>Async/Await 如何通过同步的方式实现异步</h3><p>Async/Await 就是一个<strong>自执行</strong>的 generate 函数。利用 generate 函数的特性把异步的代码写成“同步”的形式,第一个请求的返回值作为后面一个请求的参数,其中每一个参数都是一个 promise 对象.</p><h3 id="介绍节流防抖原理、区别以及应用"><a href="#介绍节流防抖原理、区别以及应用" class="headerlink" title="介绍节流防抖原理、区别以及应用"></a>介绍节流防抖原理、区别以及应用</h3><p><code>节流</code>：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。</p><p><code>防抖</code>：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行！</p><p><code>使用场景</code>：<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……<br>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次。有个需要频繁触发的函数，出于优化性能的角度，在规定时间内，只让函数触发的第一次生效，后面的不生效。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn要被节流的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//记录上一次函数触发的时间</span></span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//记录当前函数触发的时间</span></span><br><span class="line">        <span class="keyword">var</span> nowTime = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">if</span> (nowTime - lastTime &gt; delay) &#123;</span><br><span class="line">            <span class="comment">//修正this指向问题</span></span><br><span class="line">            fn.call(<span class="built_in">this</span>)</span><br><span class="line">            <span class="comment">//同步执行结束时间</span></span><br><span class="line">            lastTime = nowTime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;scllor事件被触发了&#x27;</span> + <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数  一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn要被节流的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//记录上一次的延时器</span></span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//清除上一次的演示器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="comment">//重新设置新的延时器</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//修正this指向问题</span></span><br><span class="line">            fn.apply(<span class="built_in">this</span>)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;按钮被点击了&#x27;</span> + <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="简述-MVVM"><a href="#简述-MVVM" class="headerlink" title="简述 MVVM"></a>简述 MVVM</h3><p><strong>什么是 MVVM？</strong></p><p><code>视图模型双向绑定</code>，是<code>Model-View-ViewModel</code>的缩写，也就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel。Model</code>层代表数据模型，<code>View</code>代表 UI 组件，<code>ViewModel</code>是<code>View</code>和<code>Model</code>层的桥梁，数据会绑定到<code>viewModel</code>层并自动将数据渲染到页面中，视图变化的时候会通知<code>viewModel</code>层更新数据。以前是操作 DOM 结构更新视图，现在是<code>数据驱动视图</code>。</p><p><strong>MVVM 的优点：</strong></p><p>1.<code>低耦合</code>。视图（View）可以独立于 Model 变化和修改，一个 Model 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变化，当 Model 变化的时候 View 也可以不变； 2.<code>可重用性</code>。你可以把一些视图逻辑放在一个 Model 里面，让很多 View 重用这段视图逻辑。 3.<code>独立开发</code>。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。 4.<code>可测试</code>。</p><h3 id="Vue-底层实现原理"><a href="#Vue-底层实现原理" class="headerlink" title="Vue 底层实现原理"></a>Vue 底层实现原理</h3><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter 和 getter，在数据变动时发布消息给订阅者，触发相应的监听回调<br>Vue 是一个典型的 MVVM 框架，模型（Model）只是普通的 javascript 对象，修改它则试图（View）会自动更新。这种设计让状态管理变得非常简单而直观</p><p><strong>Observer（数据监听器）</strong> : Observer 的核心是通过 Object.defineProprtty()来监听数据的变动，这个函数内部可以定义 setter 和 getter，每当数据发生变化，就会触发 setter。这时候 Observer 就要通知订阅者，订阅者就是 Watcher</p><p><strong>Watcher（订阅者）</strong> : Watcher 订阅者作为 Observer 和 Compile 之间通信的桥梁，主要做的事情是：</p><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个 update()方法</li><li>待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调</li></ol><p><strong>Compile（指令解析器）</strong> : Compile 主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图</p><h3 id="谈谈对-vue-生命周期的理解？"><a href="#谈谈对-vue-生命周期的理解？" class="headerlink" title="谈谈对 vue 生命周期的理解？"></a>谈谈对 vue 生命周期的理解？</h3><p>每个<code>Vue</code>实例在创建时都会经过一系列的初始化过程，<code>vue</code>的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件</p><ul><li><code>create阶段</code>：vue 实例被创建<br>  <code>beforeCreate</code>: 创建前，此时 data 和 methods 中的数据都还没有初始化<br>  <code>created</code>： 创建完毕，data 中有值，未挂载</li><li><code>mount阶段</code>： vue 实例被挂载到真实 DOM 节点<br>  <code>beforeMount</code>：可以发起服务端请求，去数据<br>  <code>mounted</code>: 此时可以操作 DOM</li><li><code>update阶段</code>：当 vue 实例里面的 data 数据变化时，触发组件的重新渲染<br>  <code>beforeUpdate</code> :更新前<br>  <code>updated</code>：更新后</li><li><code>destroy阶段</code>：vue 实例被销毁<br>  <code>beforeDestroy</code>：实例被销毁前，此时可以手动销毁一些方法<br>  <code>destroyed</code>:销毁后</li></ul><h4 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h4><p>生命周期（父子组件） 父组件 beforeCreate –&gt; 父组件 created –&gt; 父组件 beforeMount –&gt; 子组件 beforeCreate –&gt; 子组件 created –&gt; 子组件 beforeMount –&gt; 子组件 mounted –&gt; 父组件 mounted –&gt;父组件 beforeUpdate –&gt;子组件 beforeDestroy–&gt; 子组件 destroyed –&gt; 父组件 updated</p><p><strong>加载渲染过程</strong> 父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p><p><strong>挂载阶段</strong> 父 created-&gt;子 created-&gt;子 mounted-&gt;父 mounted</p><p><strong>父组件更新阶段</strong> 父 beforeUpdate-&gt;父 updated</p><p><strong>子组件更新阶段</strong> 父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p><p><strong>销毁阶段</strong> 父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p><h3 id="computed与watch"><a href="#computed与watch" class="headerlink" title="computed与watch"></a><code>computed与watch</code></h3><p>通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能 computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变； watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</p><p><strong>watch 属性监听</strong> 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用</p><p><strong>computed 计算属性</strong> 属性的结果会被<code>缓存</code>，当<code>computed</code>中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 <code>computed</code>中的函数必须用<code>return</code>返回最终的结果 <code>computed</code>更高效，优先使用。<code>data 不改变，computed 不更新。</code></p><p><strong>使用场景</strong> <code>computed</code>：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能 <code>watch</code>：当一条数据影响多条数据的时候使用，例：搜索数据</p><h4 id="组件中的-data-为什么是一个函数？"><a href="#组件中的-data-为什么是一个函数？" class="headerlink" title="组件中的 data 为什么是一个函数？"></a>组件中的 data 为什么是一个函数？</h4><p>1.一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。 2.如果 data 是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间 data 不冲突，data 必须是一个函数。</p><h4 id="为什么-v-for-和-v-if-不建议用在一起"><a href="#为什么-v-for-和-v-if-不建议用在一起" class="headerlink" title="为什么 v-for 和 v-if 不建议用在一起"></a>为什么 v-for 和 v-if 不建议用在一起</h4><p>1.当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费 2.这种场景建议使用 computed，先对数据进行过滤</p><h3 id="React-Vue-项目中-key-的作用"><a href="#React-Vue-项目中-key-的作用" class="headerlink" title="React/Vue 项目中 key 的作用"></a>React/Vue 项目中 key 的作用</h3><ul><li><p>key 的作用是为了在 diff 算法执行时更快的找到对应的节点，<code>提高diff速度，更高效的更新虚拟DOM</code>;</p><p>  vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。</p></li><li><p>为了在数据变化时强制更新组件，以避免<code>“就地复用”</code>带来的副作用。</p><p>  当 Vue.js 用 <code>v-for</code> 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的 key 会造成渲染错误。</p></li></ul><h3 id="vue-组件的通信方式"><a href="#vue-组件的通信方式" class="headerlink" title="vue 组件的通信方式"></a>vue 组件的通信方式</h3><ul><li><p><code>props</code>/<code>$emit</code> 父子组件通信</p><p>  父-&gt;子<code>props</code>，子-&gt;父 <code>$on、$emit</code> 获取父子组件实例 <code>parent、children</code> <code>Ref </code>获取实例的方式调用组件的属性或者方法 父-&gt;子孙 <code>Provide、inject</code> 官方不推荐使用，但是写组件库时很常用</p></li><li><p><code>$emit</code>/<code>$on</code> 自定义事件 兄弟组件通信</p><p>  <code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue()</code> 自定义事件</p></li><li><p>vuex 跨级组件通信</p><p>  Vuex、<code>$attrs、$listeners</code> <code>Provide、inject</code></p></li></ul><h3 id="nextTick-的实现"><a href="#nextTick-的实现" class="headerlink" title="nextTick 的实现"></a>nextTick 的实现</h3><ol><li><code>nextTick</code>是<code>Vue</code>提供的一个全局<code>API</code>,是在下次<code>DOM</code>更新循环结束之后执行延迟回调，在修改数据之后使用<code>$nextTick</code>，则可以在回调中获取更新后的<code>DOM</code>；</li><li>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，<code>Vue</code>将开启 1 个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的 dom 操作完成后才调用；</li><li>比如，我在干什么的时候就会使用 nextTick，传一个回调函数进去，在里面执行 dom 操作即可；</li><li>我也有简单了解<code>nextTick</code>实现，它会在<code>callbacks</code>里面加入我们传入的函数，然后用<code>timerFunc</code>异步方式调用它们，首选的异步方式会是<code>Promise</code>。这让我明白了为什么可以在<code>nextTick</code>中看到<code>dom</code>操作结果。</li></ol><h3 id="nextTick-的实现原理是什么？"><a href="#nextTick-的实现原理是什么？" class="headerlink" title="nextTick 的实现原理是什么？"></a>nextTick 的实现原理是什么？</h3><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick 主要使用了宏任务和微任务。 根据执行环境分别尝试采用 Promise、MutationObserver、setImmediate，如果以上都不行则采用 setTimeout 定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。</p><h3 id="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"><a href="#使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽" class="headerlink" title="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"></a>使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽</h3><p>vue 中的插槽是一个非常好用的东西 slot 说白了就是一个占位的 在 vue 当中插槽包含三种一种是默认插槽（匿名）一种是具名插槽还有一种就是作用域插槽 匿名插槽就是没有名字的只要默认的都填到这里具名插槽指的是具有名字的</p><h3 id="keep-alive-的实现"><a href="#keep-alive-的实现" class="headerlink" title="keep-alive 的实现"></a>keep-alive 的实现</h3><p>作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染</p><p>场景：tabs 标签页 后台导航，vue 性能优化</p><p>原理：<code>Vue.js</code>内部将<code>DOM</code>节点抽象成了一个个的<code>VNode</code>节点，<code>keep-alive</code>组件的缓存也是基于<code>VNode</code>节点的而不是直接存储<code>DOM</code>结构。它将满足条件<code>（pruneCache与pruneCache）</code>的组件在<code>cache</code>对象中缓存起来，在需要重新渲染的时候再将<code>vnode</code>节点从<code>cache</code>对象中取出并渲染。</p><h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p>mixin 项目变得复杂的时候，多个组件间有重复的逻辑就会用到 mixin 多个组件有相同的逻辑，抽离出来 mixin 并不是完美的解决方案，会有一些问题 vue3 提出的 Composition API 旨在解决这些问题【追求完美是要消耗一定的成本的，如开发成本】 场景：PC 端新闻列表和详情页一样的右侧栏目，可以使用 mixin 进行混合 劣势：1.变量来源不明确，不利于阅读 2.多 mixin 可能会造成命名冲突 3.mixin 和组件可能出现多对多的关系，使得项目复杂度变高</p><h3 id="Vuex-的理解及使用场景"><a href="#Vuex-的理解及使用场景" class="headerlink" title="Vuex 的理解及使用场景"></a>Vuex 的理解及使用场景</h3><p>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。</p><ol><li>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，</li></ol><p>若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新 2. 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation， 这样使得我们可以方便地跟踪每一个状态的变化 Vuex 主要包括以下几个核心模块：</p><ol><li>State：定义了应用的状态数据</li><li>Getter：在 store 中定义“getter”（可以认为是 store 的计算属性），</li></ol><p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算 3. Mutation：是唯一更改 store 中状态的方法，且必须是同步函数 4. Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作 5. Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7249773a1634f779c48f3f0ffabf968~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><h3 id="hooks-用过吗？聊聊-react-中-class-组件和函数组件的区别"><a href="#hooks-用过吗？聊聊-react-中-class-组件和函数组件的区别" class="headerlink" title="hooks 用过吗？聊聊 react 中 class 组件和函数组件的区别"></a>hooks 用过吗？聊聊 react 中 class 组件和函数组件的区别</h3><p>类组件是使用 ES6 的 class 来定义的组件。 函数组件是接收一个单一的 <code>props</code> 对象并返回一个 React 元素。</p><p>关于 React 的两套 API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较”轻”，而类比较”重”。而且，钩子是函数，更符合 React 函数式的本质。</p><p>函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。</p><p>类（class）是数据和逻辑的封装。 也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面。</p><p><strong>类组件的缺点</strong> :</p><p>大型组件很难拆分和重构，也很难测试。<br>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。<br>组件类引入了复杂的编程模式，比如 render props 和高阶组件。<br>难以理解的 class，理解 JavaScript 中 <code>this</code> 的工作方式。</p><p><strong>区别</strong>：</p><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。</p><p>1.状态的有无<br>hooks 出现之前，函数组件<code>没有实例</code>，<code>没有生命周期</code>，<code>没有state</code>，<code>没有this</code>，所以我们称函数组件为无状态组件。 hooks 出现之前，react 中的函数组件通常只考虑负责 UI 的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数 props 决定，不受其他任何因素影响。</p><p>2.调用方式的不同<br>函数组件重新渲染，将重新调用组件方法返回新的 react 元素。类组件重新渲染将 new 一个新的组件实例，然后调用 render 类方法返回 react 元素，这也说明为什么类组件中 this 是可变的。</p><p>3.因为调用方式不同，在函数组件使用中会出现问题<br>在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值</p><p><strong>React Hooks（钩子的作用）</strong></p><p><em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><p>React Hooks 的几个常用钩子:</p><ol><li><code>useState()</code> //状态钩子</li><li><code>useContext()</code> //共享状态钩子</li><li><code>useReducer()</code> //action 钩子</li><li><code>useEffect()</code> //副作用钩子</li></ol><p>还有几个不常见的大概的说下，后续会专门写篇文章描述下</p><ul><li><p>1.useCallback 记忆函数 一般把<strong>函数式组件理解为 class 组件 render 函数的语法糖</strong>，所以每次重新渲染的时候，函数式组件内部所有的代码都会重新执行一遍。而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> memoizedHandleClick = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Click happened&#x27;</span>)</span><br><span class="line">    &#125;, []) <span class="comment">// 空数组代表无论什么情况下该函数都不会发生改变</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">onClick</span>=<span class="string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">SomeComponent</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>  第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。</p></li><li><p>2.useMemo 记忆组件 useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 唯一的区别是：<strong>useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你</strong>。<br>  所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</p></li><li><p>3.useRef 保存引用值</p><p>  useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值<strong>访问组件或真实的 DOM 节点，重点是组件也是可以访问到的</strong>，从而可以对 DOM 进行一些操作，比如监听事件等等。</p></li><li><p>4.useImperativeHandle 穿透 Ref</p><p>  通过 useImperativeHandle 用于让父组件获取子组件内的索引</p></li><li><p>5.useLayoutEffect 同步执行副作用</p><p>  大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。</p><p>  <strong>useEffect 和 useLayoutEffect 有什么区别</strong>：简单来说就是调用时机不同，useLayoutEffect 和原来 componentDidMount&amp;componentDidUpdate 一致，在 react 完成 DOM 更新后马上同步调用的代码，会阻塞页面渲染。而 useEffect 是会在整个页面渲染完才会调用的代码。<code>官方建议优先使用useEffect</code></p></li></ul><h3 id="React-组件通信方式"><a href="#React-组件通信方式" class="headerlink" title="React 组件通信方式"></a>React 组件通信方式</h3><p>react 组件间通信常见的几种情况:</p><ul><li><ol><li>父组件向子组件通信</li></ol></li><li><ol><li>子组件向父组件通信</li></ol></li><li><ol><li>跨级组件通信</li></ol></li><li><ol><li>非嵌套关系的组件通信</li></ol></li></ul><h4 id="1）父组件向子组件通信"><a href="#1）父组件向子组件通信" class="headerlink" title="1）父组件向子组件通信"></a>1）父组件向子组件通信</h4><p>父组件通过 props 向子组件传递需要的信息。父传子是在父组件中直接绑定一个正常的属性，这个属性就是指具体的值，在子组件中，用 props 就可以获取到这个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&#x27;京程一灯&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2）子组件向父组件通信"><a href="#2）子组件向父组件通信" class="headerlink" title="2）子组件向父组件通信"></a>2）子组件向父组件通信</h4><p>props+回调的方式，使用公共组件进行状态提升。子传父是先在父组件上绑定属性设置为一个函数，当子组件需要给父组件传值的时候，则通过 props 调用该函数将参数传入到该函数当中，此时就可以在父组件中的函数中接收到该参数了，这个参数则为子组件传过来的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cb = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            props.callback(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;cb(</span>&#x27;京程一灯欢迎你!&#x27;)&#125;&gt;</span>京程一灯欢迎你<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">callback</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">callback</span>=<span class="string">&#123;this.callback.bind(this)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="3）跨级组件通信"><a href="#3）跨级组件通信" class="headerlink" title="3）跨级组件通信"></a>3）跨级组件通信</h4><p>即父组件向子组件的子组件通信，向更深层子组件通信。</p><ul><li>  使用 props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递 props，增加了复杂度，并且这些 props 并不是中间组件自己需要的。</li><li>  使用 context，context 相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用 context 实现。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context方式实现跨级组件通信</span></span><br><span class="line"><span class="comment">// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BatteryContext = createContext()</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子组件的子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">BatteryContext.Consumer</span>&gt;</span>&#123;(color) =&gt; <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">color</span> &#125;&#125;&gt;</span>我是红色的:&#123;color&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">BatteryContext.Consumer</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子组件</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GrandChild</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; color &#125; = <span class="built_in">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">BatteryContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Child</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">BatteryContext.Provider</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="4）非嵌套关系的组件通信"><a href="#4）非嵌套关系的组件通信" class="headerlink" title="4）非嵌套关系的组件通信"></a>4）非嵌套关系的组件通信</h4><p>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。</p><ul><li><ol><li>可以使用自定义事件通信（发布订阅模式），使用 pubsub-js</li></ol></li><li><ol><li>可以通过 redux 等进行全局状态管理</li></ol></li><li><ol><li>如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li></ol></li><li><ol><li>也可以 new 一个 Vue 的 EventBus,进行事件监听，一边执行监听，一边执行新增 VUE 的 eventBus 就是发布订阅模式，是可以在 React 中使用的;</li></ol></li></ul><h3 id="setState-既存在异步情况也存在同步情况"><a href="#setState-既存在异步情况也存在同步情况" class="headerlink" title="setState 既存在异步情况也存在同步情况"></a>setState 既存在异步情况也存在同步情况</h3><p>1.异步情况 在<code>React事件当中是异步操作</code></p><p>2.同步情况 如果是在<code>setTimeout事件或者自定义的dom事件</code>中，都是同步的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setTimeout事件</span></span><br><span class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.btnAction&#125;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    btnAction = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//不能直接修改state，需要通过setState进行修改</span></span><br><span class="line">        <span class="comment">//同步</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.count);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Count;</span><br><span class="line">复制代码</span><br><span class="line"><span class="comment">//自定义dom事件</span></span><br><span class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>绑定点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//自定义dom事件，也是同步修改</span></span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.count);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Count;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bae01e6eb804d849e5bb889f787707d~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">安装</span><br><span class="line">当组件的实例被创建并插入到 DOM 中时，这些方法按以下顺序调用：</span><br><span class="line"></span><br><span class="line"><span class="title">constructor</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">static</span> <span class="title">getDerivedStateFromProps</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">render</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">componentDidMount</span>(<span class="params"></span>)</span><br><span class="line"></span><br><span class="line">更新中</span><br><span class="line">更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：</span><br><span class="line"></span><br><span class="line"><span class="title">static</span> <span class="title">getDerivedStateFromProps</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">shouldComponentUpdate</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">render</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">getSnapshotBeforeUpdate</span>(<span class="params"></span>)</span><br><span class="line"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span><br><span class="line"></span><br><span class="line">卸载</span><br><span class="line">当组件从 <span class="title">DOM</span> 中移除时调用此方法：</span><br><span class="line"></span><br><span class="line"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="说一下-react-fiber"><a href="#说一下-react-fiber" class="headerlink" title="说一下 react-fiber"></a>说一下 react-fiber</h3><h4 id="1）背景"><a href="#1）背景" class="headerlink" title="1）背景"></a>1）背景</h4><p>react-fiber 产生的根本原因，是<code>大量的同步计算任务阻塞了浏览器的 UI 渲染</code>。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用<code>setState</code>更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p><h4 id="2）实现原理"><a href="#2）实现原理" class="headerlink" title="2）实现原理"></a>2）实现原理</h4><ul><li>react 内部运转分三层：<ul><li>  Virtual DOM 层，描述页面长什么样。</li><li>  Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li><li>  Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li></ul></li></ul><p><code>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fiber = &#123;</span><br><span class="line">    stateNode,    <span class="comment">// 节点实例</span></span><br><span class="line">    child,        <span class="comment">// 子节点</span></span><br><span class="line">    sibling,      <span class="comment">// 兄弟节点</span></span><br><span class="line">    <span class="keyword">return</span>,       <span class="comment">// 父节点</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如 Diff）的执行，从而更快的生效。任务的优先级有六种：<ul><li>  synchronous，与之前的 Stack Reconciler 操作一样，同步执行</li><li>  task，在 next tick 之前执行</li><li>  animation，下一帧之前执行</li><li>  high，在不久的将来立即执行</li><li>  low，稍微延迟执行也没关系</li><li>  offscreen，下一次 render 时或 scroll 时才执行</li></ul></li><li>Fiber Reconciler（react ）执行过程分为 2 个阶段：<ul><li>  阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</li><li>  阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。</li></ul></li><li>  Fiber 树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</li></ul><p>从 Stack Reconciler 到 Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情</p><h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用 portals 进行创建</p><h3 id="何时要使用异步组件？如和使用异步组件"><a href="#何时要使用异步组件？如和使用异步组件" class="headerlink" title="何时要使用异步组件？如和使用异步组件"></a>何时要使用异步组件？如和使用异步组件</h3><ul><li>  加载大组件的时候</li><li>  路由异步加载的时候</li></ul><p>react 中要配合 Suspense 使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步懒加载</span></span><br><span class="line"><span class="keyword">const</span> Box = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./components/Box&#x27;</span>))</span><br><span class="line"><span class="comment">// 使用组件的时候要用suspense进行包裹</span></span><br><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;&#123;show &amp;&amp; <span class="tag">&lt;<span class="name">Box</span> /&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="React-事件绑定原理"><a href="#React-事件绑定原理" class="headerlink" title="React 事件绑定原理"></a>React 事件绑定原理</h3><p>React 并不是将 click 事件绑在该 div 的真实 DOM 上，而是<code>在document处监听所有支持的事件</code>，当事件发生并冒泡至 document 处时，React 将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。<br>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 <code>event.preventDefault</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2089718f74b342869de15f01588f033f~tplv-k3u1fbpfcp-watermark.awebp" alt="react事件绑定原理"></p><h3 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h3><p><strong>1. 概念</strong></p><p>节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span> <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout) <span class="comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span></span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span></span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;防抖成功&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inp = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;inp&#x27;</span>)</span><br><span class="line">inp.addEventListener(<span class="string">&#x27;input&#x27;</span>, debounce(sayHi)) <span class="comment">// 防抖</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> canRun = <span class="literal">true</span> <span class="comment">// 通过闭包保存一个标记</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!canRun) <span class="keyword">return</span> <span class="comment">// 在函数开头判断标记是否为true，不为true则return</span></span><br><span class="line">        canRun = <span class="literal">false</span> <span class="comment">// 立即设置为false</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 将外部传入的函数的执行放在setTimeout中</span></span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            <span class="comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span></span><br><span class="line">            canRun = <span class="literal">true</span></span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target.innerWidth, e.target.innerHeight)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, throttle(sayHi))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>2. 使用场景：</strong></p><p>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……</p><p>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。</p><h3 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h3><p><code>移除生产环境的控制台打印</code>。方案很多，esling+pre-commit、使用插件自动去除，插件包括 babel-plugin-transform-remove-console、uglifyjs-webpack-plugin、terser-webpack-plugin。最后选择了 terser-webpack-plugin，脚手架 vue-cli 用这个插件来开启缓存和多线程打包，无需安装额外的插件，仅需在 configureWebpack 中设置 terser 插件的 drop_console 为 true 即可。最好还是养成良好的代码习惯，在开发基本完成后去掉无用的 console，vscode 中的 turbo console 就蛮好的。</p><p><code>第三方库的按需加载</code>。echarts，官方文档里是使用配置文件指定使用的模块，另一种使用 babel-plugin-equire 实现按需加载。element-ui 使用 babel-plugin-component 实现按需引入。</p><p>公有样式，比如对 element-ui 部分组件（如弹框、表格、下拉选框等）<code>样式的统一调整</code>。公共组件，比如 date-picker、upload-file 等在 element-ui 提供的组件基本上做进一步的封装。自定义组件包括 preview-file、搜索框等。</p><p>前后端数据交换方面，推动项目组使用蓝湖、接口文档，与后端同学协商，规范后台数据返回。</p><p>雅虎军规提到的，<code>避免css表达式、滤镜，较少DOM操作，优化图片、精灵图，避免图片空链接等</code>。</p><p><code>性能问题：页面加载性能、动画性能、操作性能</code>。Performance API，记录性能数据。</p><p>winter 重学前端 优化技术方案：</p><p>缓存：<code>客户端控制的强缓存策略</code>。</p><p><code>降低请求成本</code>：DNS 由客户端控制，隔一段时间主动请求获取域名 IP，不走系统 DNS（完全看不懂）。TCP/TLS 连接复用，服务器升级到 HTTP2，尽量合并域名。</p><p><code>减少请求数</code>：JS、CSS 打包到 HTML。JS 控制图片异步加载、懒加载。小型图片使用 data-uri。</p><p><code>较少传输体积</code>：尽量使用 SVG\gradient 代替图片。根据机型和网络状况控制图片清晰度。对低清晰度图片使用锐化来提升体验。设计上避免大型背景图。</p><p><code>使用CDN加速</code>，内容分发网络，是建立再承载网基础上的虚拟分布式网络，能够将源站内容缓存到全国或全球的节点服务器上。用户就近获取内容，提高了资源的访问速度，分担源站压力。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前端面筋 (CSS篇)</title>
      <link href="post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart3/"/>
      <url>post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart3/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5-新特性、语义化"><a href="#HTML5-新特性、语义化" class="headerlink" title="HTML5 新特性、语义化"></a>HTML5 新特性、语义化</h2><ol><li><p>概念：<br>HTML5 的语义化指的是合理正确的使用语义化的标签来创建页面结构。【正确的标签做正确的事】</p></li><li><p>语义化标签：<br>header nav main article section aside footer</p></li><li><p>语义化的优点:</p><ul><li>在没 CSS 样式的情况下，页面整体也会呈现很好的结构效果</li><li>代码结构清晰，易于阅读，</li><li>利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li><li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ul></li></ol><h2 id="CSS-选择器及其优先级"><a href="#CSS-选择器及其优先级" class="headerlink" title="CSS 选择器及其优先级"></a>CSS 选择器及其优先级</h2><p><strong>选择器</strong></p><ul><li>  选择器(#myid)</li><li>  类选择器(.myclass)</li><li>  属性选择器(a[rel=”external”])</li><li>  伪类选择器(a:hover, li:nth-child)</li><li>  标签选择器(div, h1,p)</li><li>  相邻选择器（h1 + p）</li><li>  子选择器(ul &gt; li)</li><li>  后代选择器(li a)</li><li>  通配符选择器(*)</li></ul><p><strong>优先级</strong></p><ul><li>  !important</li><li>  内联（1000）</li><li>  id 选择器（0100）</li><li>  类/属性/伪类选择器 （0010）</li><li>  元素/伪元素选择器 （0001）</li><li>  关系选择器/通配 （0000）</li></ul><blockquote><p>!important &gt; 内联选择器 &gt; id 选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配 &gt; 继承 &gt; 浏览器默认</p></blockquote><h2 id="position-的值及其区别"><a href="#position-的值及其区别" class="headerlink" title="position 的值及其区别"></a>position 的值及其区别</h2><p><strong>固定定位 fixed：</strong> 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。</p><p><strong>相对定位 relative：</strong> 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</p><p><strong>绝对定位 absolute：</strong> 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</p><p><strong>粘性定位 sticky：</strong> 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。</p><p><strong>默认定位 Static：</strong> 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。</p><h2 id="box-sizing-属性"><a href="#box-sizing-属性" class="headerlink" title="box-sizing 属性"></a>box-sizing 属性</h2><p><strong>box-sizing</strong> 规定两个并排的带边框的框，语法为 box-sizing：content-box/border-box/inherit<br><strong>content-box</strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】<br><strong>border-box：</strong>为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】<br><strong>inherit：</strong>继承父元素的 box-sizing 值。</p><h2 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h2><p>CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。</p><p>在标准的盒子模型中，width 指 content 部分的宽度。<br>在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度。</p><p>故在计算盒子的宽度时存在差异：<br><strong>标准盒模型：</strong> 一个块的总宽度 = width+margin(左右)+padding(左右)+border(左右)<br><strong>怪异盒模型：</strong> 一个块的总宽度 = width+margin（左右）（既 width 已经包含了 padding 和 border 值）</p><h2 id="BFC-块级格式上下文"><a href="#BFC-块级格式上下文" class="headerlink" title="BFC(块级格式上下文)"></a>BFC(块级格式上下文)</h2><p><strong>概念</strong></p><p>BFC 是 Block Formatting Context 的缩写，即块级格式化上下文。BFC 是 CSS 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。</p><p><strong>BFC 的原理布局规则</strong></p><ul><li>  内部的 Box 会在垂直方向，一个接一个地放置</li><li>  Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li><li>  每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反</li><li>  BFC 的区域不会与 float box 重叠</li><li>  BFC 是一个独立容器，容器里面的子元素不会影响到外面的元素</li><li>  计算 BFC 的高度时，浮动元素也参与计算高度</li><li>  元素的类型和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。</li></ul><p><strong>如何创建 BFC？</strong></p><ul><li>  根元素，即 HTML 元素</li><li>  float 的值不为 none</li><li>  position 为 absolute 或 fixed</li><li>  display 的值为 inline-block、table-cell、table-caption</li><li>  overflow 的值不为 visible</li></ul><p><strong>BFC 的使用场景</strong></p><ul><li>  去除边距重叠现象</li><li>  清除浮动（让父元素的高度包含子浮动元素）</li><li>  避免某元素被浮动元素覆盖</li><li>  避免多列布局由于宽度计算四舍五入而自动换行</li></ul><h2 id="元素水平垂直居中"><a href="#元素水平垂直居中" class="headerlink" title="元素水平垂直居中"></a>元素水平垂直居中</h2><p><strong>水平居中</strong></p><p>对于 行内元素 : text-align: center;</p><p>对于确定宽度的块级元素：</p><ol><li>width 和 margin 实现。margin: 0 auto;</li><li>绝对定位和 margin-left: -width/2, 前提是父元素 position: relative</li></ol><p>对于宽度未知的块级元素</p><ol><li>table 标签配合 margin 左右 auto 实现水平居中。使用 table 标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右 margin 为 auto。</li><li>inline-block 实现水平居中方法。display：inline-block 和 text-align:center 实现水平居中。</li><li>绝对定位+transform，translateX 可以移动本身元素的 50%。</li><li>flex 布局使用 justify-content:center</li></ol><p><strong>垂直居中</strong></p><ol><li>利用 line-height 实现居中，这种方法适合纯文字类</li><li>通过设置父容器 相对定位 ，子级设置 绝对定位，标签通过 margin 实现自适应居中</li><li>弹性布局 flex :父级设置 display: flex; 子级设置 margin 为 auto 实现自适应居中</li><li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现<br>table 布局，父级通过转换成表格形式，然后子级设置 vertical-align 实现。（需要注意的是：vertical-align: middle 使用的前提条件是内联元素以及 display 值为 table-cell 的元素）。</li></ol><h2 id="隐藏页面中某个元素"><a href="#隐藏页面中某个元素" class="headerlink" title="隐藏页面中某个元素"></a>隐藏页面中某个元素</h2><ol><li>opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如 click 事件，那么点击该区域，也能触发点击事件的</li><li>visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</li><li>display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</li></ol><h2 id="css-实现三角符号"><a href="#css-实现三角符号" class="headerlink" title="css 实现三角符号"></a>css 实现三角符号</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记忆口诀：盒子宽高均为零，三面边框皆透明。 */</span></span><br><span class="line"><span class="selector-tag">div</span>:after &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">100px</span> solid <span class="number">#ff0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><h3 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h3><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”,用来为盒状模型提供最大的灵活性。指定容器 display: flex 即可。 简单的分为容器属性和元素属性。</p><p><strong>容器的属性：</strong></p><ul><li>flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column |<br>  column-reverse;</li><li>  flex-wrap：决定换行规则 flex-wrap: nowrap | wrap | wrap-reverse;</li><li>  flex-flow：属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</li><li>  justify-content：对其方式，水平主轴对齐方式</li><li>  align-items：对齐方式，竖直轴线方向</li><li>  align-content:属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p><strong>项目的属性（元素的属性）：</strong></p><ul><li>  order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0</li><li>  flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大</li><li>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不<br>  缩小</li><li>  flex-basis 属性：定义了在分配多余的空间，项目占据的空间。</li><li>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。该属性有三个常用快捷值：auto (1 1<br>  auto) 和 1 (1 1 0%) 和 none (0 0 auto)。</li><li>  align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖</li><li>  align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局</li></ul><h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><p>通过百分比单位 “ % “ 来实现响应式的效果。通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相 对于 height，width 百分比相对于 width。 padding、border、margin 等等不论是垂直方向还是水平方向，都相对于直接父元素的 width。 除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。</p><p><strong>缺点：</strong></p><ul><li>  计算困难</li><li>  各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。</li></ul><h3 id="table-布局"><a href="#table-布局" class="headerlink" title="table 布局"></a>table 布局</h3><p>table 布局在如今已经很少使用，原因是：table 布局比其它 html 标记占更多的字节，会阻挡浏览器渲染引擎的渲染顺序，会影响其内部的某些布局属性的生效。</p><p>使用 table 布局有两种方式</p><ul><li>  table 标签</li><li>  display：table</li></ul><h3 id="float-布局"><a href="#float-布局" class="headerlink" title="float 布局"></a>float 布局</h3><p>浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。</p><p><strong>优点</strong></p><p>这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与 inline-block 还是有一些区别的，第一个就是关于横向排序的时候，float 可以设置方向而 inline-block 方向是固定的；还有一个就是 inline-block 在使用时有时会有空白间隙的问题<br><strong>缺点</strong></p><p>最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，会造成父级元素高度塌陷。</p><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。传统的开发方式是 PC 端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就够。</p><p><strong>实现方案</strong></p><ul><li>  媒体查询+百分比布局</li><li>  媒体查询+flex 布局</li><li>  媒体查询+grid 布局</li></ul><p><strong>优点</strong></p><p>面对不同分辨率设备灵活性强<br>能够快捷解决多设备显示适应问题</p><p><strong>缺点</strong></p><ul><li>  仅适用布局、信息、框架并不复杂的部门类型网站</li><li>  兼容各种设备工作量大，效率低下</li><li>  代码累赘，会出现隐藏无用的元素，加载时间加长</li><li>  其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li><li>  一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li></ul><h3 id="grid-网格布局"><a href="#grid-网格布局" class="headerlink" title="grid 网格布局"></a>grid 网格布局</h3><p>（具体看另一篇文章：<a href="/post/%E5%BC%BA%E5%A4%A7%E7%9A%84Grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80">强大的 Grid 布局</a>）</p><h2 id="使用-rem-vw-实现移动端适配"><a href="#使用-rem-vw-实现移动端适配" class="headerlink" title="使用 rem+vw 实现移动端适配"></a>使用 rem+vw 实现移动端适配</h2><p>如何利用 rem+vw 进行屏幕适配呢？我们以设计稿为 750px 为基准</p><ol><li>设置 meta 标签 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>设置根元素 html 的 font-size:13.3333333vw</li></ol><p>为什么 font-size=13.33333333vw?</p><blockquote><p>100vw=750px =&gt; 1px = 0.1333333vw =&gt; 1rem=100px=13.333333vw,取 100px 是为了方便计算</p></blockquote><p>下面分析下原理吧, 上面我们说了 vw 表示 1%的屏幕宽度,而我们的设计稿通常是 750px 的,屏幕一共是 100vw,对应 750px,那么 1px 就是 0.1333333vw,。</p><p>同时我们知道 rem,rem 是相对 html 元素的字体大小，为了方便计算,我们取 html 的 font-size=100px,通过上面的计算结果 1px 是 0.13333333vw,那么 100px 就是 13.333333vw 了</p><p>所以，我们让 1rem=100px=13.333333vw</p><p>那么在项目上就很好地可以进行使用了</p><p>当我们通过 ps 测量一个 div 的大小为 width:200px,height:137px 时，我们就可以这样写，ps 量出来的像素直接除以 100，计算小数很方便</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2rem</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.37rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;float&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.float</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>容器设置 overflow:hidden/auto</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden/auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>容器创建伪元素，伪元素 clear：both</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>浮动元素后新增空标签 clear:both</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;float&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.clearfix&#123; clear:both &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前端面筋（浏览器篇）</title>
      <link href="post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart2/"/>
      <url>post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart2/</url>
      
        <content type="html"><![CDATA[<h2 id="从输入-URL-到页面加载的全过程"><a href="#从输入-URL-到页面加载的全过程" class="headerlink" title="从输入 URL 到页面加载的全过程"></a>从输入 URL 到页面加载的全过程</h2><p><img src="/img/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B.png"></p><ol><li><p>在浏览器中输入 URL。</p></li><li><p>查找 DNS 缓存</p><ul><li>浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求；</li><li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的 DNS 查询缓存)；</li><li>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存；</li><li>ISP 缓存：若上述均失败，继续向 ISP 搜索。</li></ul></li><li><p>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址。DNS 服务器是基于 UDP 的，因此会用到 UDP 协议。</p></li><li><p>建立 TCP 连接：解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接。</p></li><li><p>发起 HTTP 请求：浏览器发起读取文件的 HTTP 请求，该请求报文作为 TCP 三次握手的第三次数据发送给服务器</p></li><li><p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 html 文件发送给浏览器</p></li><li><p>关闭 TCP 连接：通过四次挥手释放 TCP 连接</p></li><li><p>浏览器渲染（渲染引擎）：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后的解析流程为：</p><ol><li>构建 DOM 树：词法分析然后解析成 DOM 树（dom tree），是由 dom 元素及属性节点组成，树的根是 document 对象</li><li>构建 CSS 规则树：生成 CSS 规则树（CSS Rule Tree）</li><li>构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，并构建出渲染树（render tree）</li><li>布局（Layout）：计算出每个节点在屏幕中的位置</li><li>绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。</li></ol><p> <img src="/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png"></p></li><li><p>JS 引擎解析过程（具体看另一篇文章：<a href="/post/js%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B">js 引擎解析详解</a>）</p><ol><li>语法检查</li><li>预编译</li><li>执行</li></ol></li></ol><h2 id="浏览器重绘与重排"><a href="#浏览器重绘与重排" class="headerlink" title="浏览器重绘与重排"></a>浏览器重绘与重排</h2><ul><li>  重排/回流（Reflow）：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li><li>  重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</li><li>  『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』</li></ul><h2 id="如何出发重排和重绘"><a href="#如何出发重排和重绘" class="headerlink" title="如何出发重排和重绘"></a>如何出发重排和重绘</h2><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>  添加、删除、更新 DOM 节点</li><li>  通过 display: none 隐藏一个 DOM 节点-触发重排和重绘</li><li>  通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化</li><li>  移动或者给页面中的 DOM 节点添加动画</li><li>  添加一个样式表，调整样式属性</li><li>  用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><h2 id="如何避免重绘或者重排"><a href="#如何避免重绘或者重排" class="headerlink" title="如何避免重绘或者重排"></a>如何避免重绘或者重排</h2><ul><li>  集中改变样式，不要一条一条地修改 DOM 的样式。</li><li>  不要把 DOM 结点的属性值放在循环里当成循环里的变量。</li><li>  为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</li><li>  不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</li><li>  尽量只修改 position：absolute 或 fixed 元素，对其他元素影响不大</li><li>  动画开始 GPU 加速，translate 使用 3D 变化</li><li>  提升为合成层</li></ul><h2 id="浏览器缓存-强制缓存-amp-协商缓存"><a href="#浏览器缓存-强制缓存-amp-协商缓存" class="headerlink" title="浏览器缓存 强制缓存&amp;协商缓存"></a>浏览器缓存 强制缓存&amp;协商缓存</h2><ul><li><p>强制缓存<br>  强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <strong>Expires</strong> 和 <strong>Cache-Control</strong>，其中 Cache-Control 优先级比 Expires 高。<br>  强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol></li><li><p>协商缓存<br>  协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<strong>Last-Modified / If-Modified-Since</strong> 和 <strong>Etag / If-None-Match</strong>，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。协商缓存主要有以下两种情况：</p><ul><li>  协商缓存生效，返回 304</li><li>  协商缓存失效，返回 200 和请求结果结果</li></ul></li></ul><h2 id="介绍一下-304-过程"><a href="#介绍一下-304-过程" class="headerlink" title="介绍一下 304 过程"></a>介绍一下 304 过程</h2><ol><li>浏览器请求资源时首先命中资源的 <strong>Expires</strong> 和 <strong>Cache-Control</strong>，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过 <strong>Cache-control: max-age</strong> 指定最大生命周期，<strong>状态仍然返回 200</strong>，但不会请求数据，在浏览器中能明显看到 from cache 字样。</li><li>强缓存失效，进入协商缓存阶段，首先验证 <strong>ETag</strong> ,ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据客户端上送的 <strong>If-None-Match</strong> 值来判断是否命中缓存。</li><li>协商缓存 <strong>Last-Modify/If-Modify-Since</strong> 阶段，客户端第一次请求资源时，服务服返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;no-cache&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> hash = crypto.createHash(<span class="string">&#x27;sha1&#x27;</span>).update(content).digest(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">res.setHeader(<span class="string">&#x27;Etag&#x27;</span>, hash)</span><br><span class="line"><span class="keyword">if</span> (req.headers[<span class="string">&#x27;if-none-match&#x27;</span>] === hash) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Etag协商缓存命中.....&#x27;</span>)</span><br><span class="line">    res.statusCode = <span class="number">304</span></span><br><span class="line">    res.end()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说一下进程、线程和协程"><a href="#说一下进程、线程和协程" class="headerlink" title="说一下进程、线程和协程"></a>说一下进程、线程和协程</h2><ul><li><p>  进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p></li><li><p>  线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程 ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p></li><li><p>  协程，英文 Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p></li><li><p>进程和线程的区别与联系</p><p>  【区别】：</p><ul><li>  调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li><li>  并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</li><li>  拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</li><li>  系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</li></ul><p>  【联系】：</p><ul><li>  一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</li><li>  资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li><li>  处理机分给线程，即真正在处理机上运行的是线程；</li><li>  线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 重绘 </tag>
            
            <tag> 重排 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前端面筋（网络篇）</title>
      <link href="post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart1/"/>
      <url>post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart1/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h4 id="HTTP-和-HTTPS-基本概念"><a href="#HTTP-和-HTTPS-基本概念" class="headerlink" title="HTTP 和 HTTPS 基本概念"></a>HTTP 和 HTTPS 基本概念</h4><ul><li>  HTTP 是超文本协议，用于从服务器传输超文本到客户端的超文本协议。</li><li>  HTTPS 是安全的 HTTP 通道，在 HTTP 下加入 SSL 层进行加密处理数据。其作用是保证数据传输的安全性和完整性。</li></ul><h4 id="HTTP-和-HTTPS-的区别和优缺点"><a href="#HTTP-和-HTTPS-的区别和优缺点" class="headerlink" title="HTTP 和 HTTPS 的区别和优缺点"></a>HTTP 和 HTTPS 的区别和优缺点</h4><ul><li>  HTTP 是超文本传输协议，明文传输数据；HTTPS 要比 HTTP 更安全，HTTPS 通过 SSL 层加密数据，在传输过程中保证数据安全，可靠，完整。</li><li>  HTTP 默认端口 80；HTTPS 默认端口 443。</li><li>  HTTP 连接简单，无状态；HTTPS 在握手阶段相对耗时，会增加页面加载时长。</li><li>  HTTPS 的缓存不如 HTTP 高效。</li><li>  HTTPS 需要 CA 证书，费用较高。</li><li>  SSL 证书需要绑定 IP，不能在用一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ul><h4 id="HTTPS-协议的工作原理"><a href="#HTTPS-协议的工作原理" class="headerlink" title="HTTPS 协议的工作原理"></a>HTTPS 协议的工作原理</h4><ol><li>客户端使用 HTTPS url 访问服务端，服务端<strong>建立 ssl 连接</strong>。</li><li>服务端接收到客户端请求后，会将<strong>网站证书（证书包含公钥）</strong>发送给客户端。</li><li>服务端和客户端开始协商 ssl 链接的<strong>安全等级</strong>。</li><li>客户端建立<strong>会话密钥</strong>，然后通过公钥加密数据后发送服务端。</li><li>服务端通过<strong>私钥</strong>解密数据完成通信。</li></ol><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><ol><li>第一次握手：建立连接时，客户端发送<strong>syn 包</strong>（syn=j）到服务器，并进入<strong>SYN_SENT</strong>状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到 syn 包并确认客户的 SYN（ack=j+1），同时也发送一个自己的 SYN 包（syn=k），即<strong>SYN+ACK 包</strong>，此时服务器进入<strong>SYN_RECV</strong>状态。</li><li>第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送<strong>确认包 ACK</strong>(ack=k+1），此包发送完毕，客户端和服务器进入<strong>ESTABLISHED</strong>（TCP 连接成功）状态，完成三次握手。</li></ol><h2 id="TCP-IP-如何保证数据包传输的有序可靠"><a href="#TCP-IP-如何保证数据包传输的有序可靠" class="headerlink" title="TCP/IP 如何保证数据包传输的有序可靠"></a>TCP/IP 如何保证数据包传输的有序可靠</h2><p>对字节流分段并进行编号然后通过  <strong>ACK 回复</strong>和<strong>超时重发</strong>这两个机制来保证。</p><ol><li>为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区。</li><li>并为每个已发送的数据包启动一个超时定时器。</li><li>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区。</li><li>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</li><li>接收方收到数据包后，先进行 CRC 校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</li></ol><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><ol><li>TCP 是面向连接的，而 UDP 是面向无连接的。</li><li>TCP 仅支持单播传输，UDP 支持单播，多播，广播。</li><li>TCP 传输的可靠性，UDP 面向无连接，不可靠的传输协议。</li><li>UDP 传输速率比 TCP 快，实时性好。</li></ol><h2 id="HTTP-跨域请求问题"><a href="#HTTP-跨域请求问题" class="headerlink" title="HTTP 跨域请求问题"></a>HTTP 跨域请求问题</h2><ul><li><p>跨域原理<br>  跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。<br>  同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p></li><li><p>解决方案</p><ol><li>JSONP:前端构造 script 标签请求指定 URL(由 script 标签发出的 GET 请求不受同源策略限制)，服务器返 回一个函数执行语句，该函数名称通常由查询参 callback 的值决定，函数的参数为服务器返回的 json 数据。该函数在前端执行后即可获取数据。</li><li>代理服务器：请求同源服务器，通过该服务器转发请求至目标服务器，得到结果再转发给前端。前端开发中测试服务器的代理功能就是采用的该解决方案，但是最终发布上线时如果 web 应用和 接口服务器不在一起仍会跨域。</li><li>CORS（Cross Origin Resource Share） 跨域资源共享，后端方案</li></ol><ul><li><p>响应简单请求：<br>  简单请求：method 为 get/post/head,并且没有自定义请求头，且 Content-Type 为 application/x-www-form-urlencoded,multipart/form-data 或者 text/plain 之一,否则都是复杂请求。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://localhost:3000&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>响应复杂请求：预检 preflight 请求,需要响应浏览器发出的 options 请求</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端,定义了自定义请求头，属于复杂请求</span></span><br><span class="line">axios.post(<span class="string">&#x27;api/users&#x27;</span>, &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, &#123; <span class="attr">headers</span>: &#123; <span class="string">&#x27;x-token&#x27;</span>: <span class="string">&#x27;xxxxxx&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端响应,post请求的复杂请求还需要在&quot;Access-Control-Allow-Headers&quot; 允许 &quot;Content-Type&quot;</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Method&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;custom-header,Content-Type&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果要携带 cookie 信息，则请求变为 credential 请求：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端，为true时，服务端需要 &#x27;Access-Control-Allow-Credentials&#x27;:&#x27;true&#x27;</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// credential请求，预检options中和/users接口中均需添加</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置cookie</span></span><br><span class="line">res.setHeaders(<span class="string">&#x27;Set-Cookie&#x27;</span>, <span class="string">&#x27;cookie1=aaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应复杂请求</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Method&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;custom-header,Content-Type&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Cookie、sessionStorage、localStorage-区别"><a href="#Cookie、sessionStorage、localStorage-区别" class="headerlink" title="Cookie、sessionStorage、localStorage 区别"></a>Cookie、sessionStorage、localStorage 区别</h2><ul><li>相同点：<br>  存储在客户端</li><li>不同点：<ul><li>  cookie 数据大小不能超过 4k；sessionStorage 和 localStorage 的存储比 cookie 大得多，可以达到 5M+</li><li>  cookie 设置的过期时间之前一直有效；localStorage 永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除</li><li>  cookie 的数据会自动的传递到服务器；sessionStorage 和 localStorage 数据保存在本地</li></ul></li></ul><h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><p>TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><ul><li><p>粘包出现原因<br>  简单得说，在流传输中出现，UDP 不会出现粘包，因为它有消息边界粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。</p></li><li><p>为了避免粘包现象，可采取以下几种措施：</p><ol><li>对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP 提供了强制数据立即传送的操作指令 push，TCP 软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</li><li>对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</li><li>由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。分包多发。</li></ol></li><li><p>以上提到的三种措施，都有其不足之处。</p><ol><li>第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</li><li>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</li><li>第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
