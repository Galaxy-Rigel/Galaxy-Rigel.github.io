<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js引擎解析过程</title>
      <link href="post/js%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
      <url>post/js%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h2><p>语法检查是 JavaScript 解析器的工作之一，包括 Î<strong>词法分析</strong>和<strong>语法分析</strong></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>把 JavaScript 代码（字符创）逐字转换为<strong>标记流</strong></p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a = (b - c);</span></span><br></pre></td></tr></table></figure><p>转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME <span class="string">&quot;a&quot;</span></span><br><span class="line">EQUALS</span><br><span class="line">OPEN_PARENTHESIS</span><br><span class="line">NAME <span class="string">&quot;b&quot;</span></span><br><span class="line">MINUS</span><br><span class="line">NAME <span class="string">&quot;c&quot;</span></span><br><span class="line">CLOSE_PARENTHESIS</span><br><span class="line">SEMICOLON</span><br></pre></td></tr></table></figure><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析：JavaScript 语法分析器在经过词法分析后，将记号流按照 ECMAScript 标准把词法分析所产生的记号生成<strong>语法树 AS</strong>T。</p><h2 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h2><h3 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h3><ol><li>将 JavaScript 引擎将语法检查正确后生成的语法树复制到当前执行上下文中。</li><li>JavaScript 引擎会对语法树当中的<strong>变量声明</strong>、<strong>函数声明</strong>以及<strong>函数的形参</strong>进行属性填充（ 声明提升）。</li></ol><p><strong>执行上下文包括：变量对象、作用域链、this</strong></p><ul><li>  变量对象（Variable Object）:由变量声明（var declaration）、函数声明（function declaration）、参数（arguments）构成。</li><li>  作用域链（Scope Chain）: 变量对象+父级作用域</li><li>  this ：一旦进入代码执行阶段的上下文中（预编译后的代码执行阶段），this 的值就不会变了。</li></ul><p><strong>变量对象/活动对象（VO/AO）属性填充</strong></p><ul><li><p>  变量对象/活动对象（VO/AO）填充的顺序：函数的形参-&gt;函数声明-&gt;变量声明；在变量对象/活动对象（VO/AO）中权重高低也按照函数的形参-&gt;函数声明-&gt;变量声明顺序来。</p></li><li><p>  函数的形参：执行上下文的变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为 undefined。</p></li><li><p>  函数声明：执行上下文的变量对象的一个属性，属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则会替换它的值。</p></li><li><p>变量声明：执行上下文的变量对象的一个属性，其属性名即为变量名，其值为 undefined；如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的函数声明的属性，该声明会被忽略掉，但其包含的赋值操作不会忽略。</p><pre><code>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数提升优先级高于变量提升，所以b取函数</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    alert(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b <span class="comment">// 被忽略，因为函数声明优先级高于变量声明</span></span><br><span class="line">alert(b) <span class="comment">// function b(a) &#123; alert(a); &#125;</span></span><br><span class="line">b() <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>经过“预解析”创建执行上下文之后，就进入执行代码阶段，VO/AO 就会重新赋予真实的值，“预解析”阶段赋予的 undefined 值会被覆盖。</p><p>此阶段才是程序真正进入执行阶段，Javascript 引擎会一行一行的读取并运行代码。此时那些变量都会重新赋值。</p><p>假如变量是定义在函数内的，而函数从头到尾都没被激活（调用）的话，则变量值永远都是 undefined 值。</p><p>进入了执行代码阶段，在“预解析”阶段所创建的任何东西可能都会改变，不仅仅是 VO/AO，this 和作用域链也会因为某些语句而改变，后面会讲到。</p><p>​ <strong>作用域链（Scope Chain）</strong></p><p>​ 作用域链是处理标识符时进行<strong>变量查询</strong>的变量对象列表，每个执行上下文都有自己的变量对象：对于全局上下文而言，其变量对象就是全局对象本身；对于函数而言，其变量对象就是活动对象。</p><p><strong>作用域链和执行上下文的关系</strong></p><p>在 Javascript 中只有函数能规定作用域，全局执行上下文中的 Scope 是全局上下文中的属性，也是最外层的作用域链。<br>函数内部的属性（作用域）是在“预解析”的时候就已经存在的了，它包含了所有上层变量对象，并一直保存在函数中。就算函数永远都没被激活（调用），也都还是存在函数对象上。</p><p><strong>执行上下文定义的 Scope 属性变化过程</strong></p><p>执行上下文中的[AO]是函数的活动对象，而[[Scope]]则是该函数属性作用域。当前函数的 AO 永远是在最前面的，保存在堆栈上，而每当函数激活的时候，这些 AO 都会压栈到该堆栈上，查询变量是先从栈顶开始查找，也就是说作用域链的栈顶永远是当前正在执行的代码所在环境的 VO/AO（当函数调用结束后，则会从栈顶移除）。</p><p>通俗点讲就是：JavaScript 解释器通过作用域链将不同执行位置上的变量对象串连成列表，并借助这个列表帮助 JavaScript 解释器检索变量的值。作用域链相当于一个索引表，并通过编号来存储它们的嵌套关系。当 JavaScript 解释器检索变量的值，会按着这个索引编号进行快速查找，直到找到全局对象为止，如果没有找到值，则传递一个特殊的 undefined 值。</p><p>是不是又想到了一条 JavaScript 高效准则：为什么说在该函数内定义的变量，能减少函数嵌套能提高 JavaScript 的效率？因为函数定义的变量，此变量永远在栈顶，这样子查询变量的时间变短了。</p><p><strong>作用域链特性</strong><br>闭包是作用域链特性的应用</p><p>保证查询有序的访问所有变量和函数<br>作用域链感觉就是一个 VO 链表，当访问一个变量时，先在链表的第一个 VO 上查找，如果没有找到则继续在第二个 VO 上查找，直到搜索结束，也就是搜索到全局执行环境的 VO 中。这也就形成了作用域链的概念。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前端面筋（浏览器篇）</title>
      <link href="post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart2/"/>
      <url>post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart2/</url>
      
        <content type="html"><![CDATA[<h2 id="从输入-URL-到页面加载的全过程"><a href="#从输入-URL-到页面加载的全过程" class="headerlink" title="从输入 URL 到页面加载的全过程"></a>从输入 URL 到页面加载的全过程</h2><p><img src="/img/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B.png"></p><ol><li><p>在浏览器中输入 URL。</p></li><li><p>查找 DNS 缓存</p><ul><li>浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求；</li><li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的 DNS 查询缓存)；</li><li>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存；</li><li>ISP 缓存：若上述均失败，继续向 ISP 搜索。</li></ul></li><li><p>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址。DNS 服务器是基于 UDP 的，因此会用到 UDP 协议。</p></li><li><p>建立 TCP 连接：解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接。</p></li><li><p>发起 HTTP 请求：浏览器发起读取文件的 HTTP 请求，该请求报文作为 TCP 三次握手的第三次数据发送给服务器</p></li><li><p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 html 文件发送给浏览器</p></li><li><p>关闭 TCP 连接：通过四次挥手释放 TCP 连接</p></li><li><p>浏览器渲染（渲染引擎）：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后的解析流程为：</p><ol><li>构建 DOM 树：词法分析然后解析成 DOM 树（dom tree），是由 dom 元素及属性节点组成，树的根是 document 对象</li><li>构建 CSS 规则树：生成 CSS 规则树（CSS Rule Tree）</li><li>构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，并构建出渲染树（render tree）</li><li>布局（Layout）：计算出每个节点在屏幕中的位置</li><li>绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。</li></ol><p> <img src="/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png"></p></li><li><p>JS 引擎解析过程（具体看另一篇文章：<a href="/post/js%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B">js 引擎解析详解</a>）</p><ol><li>语法检查</li><li>预编译</li><li>执行</li></ol></li></ol><h2 id="浏览器重绘与重排"><a href="#浏览器重绘与重排" class="headerlink" title="浏览器重绘与重排"></a>浏览器重绘与重排</h2><ul><li>  重排/回流（Reflow）：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li><li>  重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</li><li>  『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』</li></ul><h2 id="如何出发重排和重绘"><a href="#如何出发重排和重绘" class="headerlink" title="如何出发重排和重绘"></a>如何出发重排和重绘</h2><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>  添加、删除、更新 DOM 节点</li><li>  通过 display: none 隐藏一个 DOM 节点-触发重排和重绘</li><li>  通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化</li><li>  移动或者给页面中的 DOM 节点添加动画</li><li>  添加一个样式表，调整样式属性</li><li>  用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><h2 id="如何避免重绘或者重排"><a href="#如何避免重绘或者重排" class="headerlink" title="如何避免重绘或者重排"></a>如何避免重绘或者重排</h2><ul><li>  集中改变样式，不要一条一条地修改 DOM 的样式。</li><li>  不要把 DOM 结点的属性值放在循环里当成循环里的变量。</li><li>  为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</li><li>  不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</li><li>  尽量只修改 position：absolute 或 fixed 元素，对其他元素影响不大</li><li>  动画开始 GPU 加速，translate 使用 3D 变化</li><li>  提升为合成层</li></ul><h2 id="浏览器缓存-强制缓存-amp-协商缓存"><a href="#浏览器缓存-强制缓存-amp-协商缓存" class="headerlink" title="浏览器缓存 强制缓存&amp;协商缓存"></a>浏览器缓存 强制缓存&amp;协商缓存</h2><ul><li><p>强制缓存<br>  强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <strong>Expires</strong> 和 <strong>Cache-Control</strong>，其中 Cache-Control 优先级比 Expires 高。<br>  强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol></li><li><p>协商缓存<br>  协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<strong>Last-Modified / If-Modified-Since</strong> 和 <strong>Etag / If-None-Match</strong>，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。协商缓存主要有以下两种情况：</p><ul><li>  协商缓存生效，返回 304</li><li>  协商缓存失效，返回 200 和请求结果结果</li></ul></li></ul><h2 id="介绍一下-304-过程"><a href="#介绍一下-304-过程" class="headerlink" title="介绍一下 304 过程"></a>介绍一下 304 过程</h2><ol><li>浏览器请求资源时首先命中资源的 <strong>Expires</strong> 和 <strong>Cache-Control</strong>，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过 <strong>Cache-control: max-age</strong> 指定最大生命周期，<strong>状态仍然返回 200</strong>，但不会请求数据，在浏览器中能明显看到 from cache 字样。</li><li>强缓存失效，进入协商缓存阶段，首先验证 <strong>ETag</strong> ,ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据客户端上送的 <strong>If-None-Match</strong> 值来判断是否命中缓存。</li><li>协商缓存 <strong>Last-Modify/If-Modify-Since</strong> 阶段，客户端第一次请求资源时，服务服返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;no-cache&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> hash = crypto.createHash(<span class="string">&#x27;sha1&#x27;</span>).update(content).digest(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">res.setHeader(<span class="string">&#x27;Etag&#x27;</span>, hash)</span><br><span class="line"><span class="keyword">if</span> (req.headers[<span class="string">&#x27;if-none-match&#x27;</span>] === hash) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Etag协商缓存命中.....&#x27;</span>)</span><br><span class="line">    res.statusCode = <span class="number">304</span></span><br><span class="line">    res.end()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说一下进程、线程和协程"><a href="#说一下进程、线程和协程" class="headerlink" title="说一下进程、线程和协程"></a>说一下进程、线程和协程</h2><ul><li><p>  进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p></li><li><p>  线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程 ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p></li><li><p>  协程，英文 Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p></li><li><p>进程和线程的区别与联系</p><p>  【区别】：</p><ul><li>  调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li><li>  并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</li><li>  拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</li><li>  系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</li></ul><p>  【联系】：</p><ul><li>  一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</li><li>  资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li><li>  处理机分给线程，即真正在处理机上运行的是线程；</li><li>  线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 重绘 </tag>
            
            <tag> 重排 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈前端面筋（网络篇）</title>
      <link href="post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart1/"/>
      <url>post/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%AD%8Bpart1/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h4 id="HTTP-和-HTTPS-基本概念"><a href="#HTTP-和-HTTPS-基本概念" class="headerlink" title="HTTP 和 HTTPS 基本概念"></a>HTTP 和 HTTPS 基本概念</h4><ul><li>  HTTP 是超文本协议，用于从服务器传输超文本到客户端的超文本协议。</li><li>  HTTPS 是安全的 HTTP 通道，在 HTTP 下加入 SSL 层进行加密处理数据。其作用是保证数据传输的安全性和完整性。</li></ul><h4 id="HTTP-和-HTTPS-的区别和优缺点"><a href="#HTTP-和-HTTPS-的区别和优缺点" class="headerlink" title="HTTP 和 HTTPS 的区别和优缺点"></a>HTTP 和 HTTPS 的区别和优缺点</h4><ul><li>  HTTP 是超文本传输协议，明文传输数据；HTTPS 要比 HTTP 更安全，HTTPS 通过 SSL 层加密数据，在传输过程中保证数据安全，可靠，完整。</li><li>  HTTP 默认端口 80；HTTPS 默认端口 443。</li><li>  HTTP 连接简单，无状态；HTTPS 在握手阶段相对耗时，会增加页面加载时长。</li><li>  HTTPS 的缓存不如 HTTP 高效。</li><li>  HTTPS 需要 CA 证书，费用较高。</li><li>  SSL 证书需要绑定 IP，不能在用一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ul><h4 id="HTTPS-协议的工作原理"><a href="#HTTPS-协议的工作原理" class="headerlink" title="HTTPS 协议的工作原理"></a>HTTPS 协议的工作原理</h4><ol><li>客户端使用 HTTPS url 访问服务端，服务端<strong>建立 ssl 连接</strong>。</li><li>服务端接收到客户端请求后，会将<strong>网站证书（证书包含公钥）</strong>发送给客户端。</li><li>服务端和客户端开始协商 ssl 链接的<strong>安全等级</strong>。</li><li>客户端建立<strong>会话密钥</strong>，然后通过公钥加密数据后发送服务端。</li><li>服务端通过<strong>私钥</strong>解密数据完成通信。</li></ol><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><ol><li>第一次握手：建立连接时，客户端发送<strong>syn 包</strong>（syn=j）到服务器，并进入<strong>SYN_SENT</strong>状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到 syn 包并确认客户的 SYN（ack=j+1），同时也发送一个自己的 SYN 包（syn=k），即<strong>SYN+ACK 包</strong>，此时服务器进入<strong>SYN_RECV</strong>状态。</li><li>第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送<strong>确认包 ACK</strong>(ack=k+1），此包发送完毕，客户端和服务器进入<strong>ESTABLISHED</strong>（TCP 连接成功）状态，完成三次握手。</li></ol><h2 id="TCP-IP-如何保证数据包传输的有序可靠"><a href="#TCP-IP-如何保证数据包传输的有序可靠" class="headerlink" title="TCP/IP 如何保证数据包传输的有序可靠"></a>TCP/IP 如何保证数据包传输的有序可靠</h2><p>对字节流分段并进行编号然后通过  <strong>ACK 回复</strong>和<strong>超时重发</strong>这两个机制来保证。</p><ol><li>为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区。</li><li>并为每个已发送的数据包启动一个超时定时器。</li><li>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区。</li><li>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</li><li>接收方收到数据包后，先进行 CRC 校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</li></ol><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><ol><li>TCP 是面向连接的，而 UDP 是面向无连接的。</li><li>TCP 仅支持单播传输，UDP 支持单播，多播，广播。</li><li>TCP 传输的可靠性，UDP 面向无连接，不可靠的传输协议。</li><li>UDP 传输速率比 TCP 快，实时性好。</li></ol><h2 id="HTTP-跨域请求问题"><a href="#HTTP-跨域请求问题" class="headerlink" title="HTTP 跨域请求问题"></a>HTTP 跨域请求问题</h2><ul><li><p>跨域原理<br>  跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。<br>  同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p></li><li><p>解决方案</p><ol><li>JSONP:前端构造 script 标签请求指定 URL(由 script 标签发出的 GET 请求不受同源策略限制)，服务器返 回一个函数执行语句，该函数名称通常由查询参 callback 的值决定，函数的参数为服务器返回的 json 数据。该函数在前端执行后即可获取数据。</li><li>代理服务器：请求同源服务器，通过该服务器转发请求至目标服务器，得到结果再转发给前端。前端开发中测试服务器的代理功能就是采用的该解决方案，但是最终发布上线时如果 web 应用和 接口服务器不在一起仍会跨域。</li><li>CORS（Cross Origin Resource Share） 跨域资源共享，后端方案</li></ol><ul><li><p>响应简单请求：<br>  简单请求：method 为 get/post/head,并且没有自定义请求头，且 Content-Type 为 application/x-www-form-urlencoded,multipart/form-data 或者 text/plain 之一,否则都是复杂请求。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://localhost:3000&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>响应复杂请求：预检 preflight 请求,需要响应浏览器发出的 options 请求</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端,定义了自定义请求头，属于复杂请求</span></span><br><span class="line">axios.post(<span class="string">&#x27;api/users&#x27;</span>, &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, &#123; <span class="attr">headers</span>: &#123; <span class="string">&#x27;x-token&#x27;</span>: <span class="string">&#x27;xxxxxx&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端响应,post请求的复杂请求还需要在&quot;Access-Control-Allow-Headers&quot; 允许 &quot;Content-Type&quot;</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Method&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;custom-header,Content-Type&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果要携带 cookie 信息，则请求变为 credential 请求：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端，为true时，服务端需要 &#x27;Access-Control-Allow-Credentials&#x27;:&#x27;true&#x27;</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// credential请求，预检options中和/users接口中均需添加</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置cookie</span></span><br><span class="line">res.setHeaders(<span class="string">&#x27;Set-Cookie&#x27;</span>, <span class="string">&#x27;cookie1=aaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应复杂请求</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Method&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;custom-header,Content-Type&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Cookie、sessionStorage、localStorage-区别"><a href="#Cookie、sessionStorage、localStorage-区别" class="headerlink" title="Cookie、sessionStorage、localStorage 区别"></a>Cookie、sessionStorage、localStorage 区别</h2><ul><li>相同点：<br>  存储在客户端</li><li>不同点：<ul><li>  cookie 数据大小不能超过 4k；sessionStorage 和 localStorage 的存储比 cookie 大得多，可以达到 5M+</li><li>  cookie 设置的过期时间之前一直有效；localStorage 永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除</li><li>  cookie 的数据会自动的传递到服务器；sessionStorage 和 localStorage 数据保存在本地</li></ul></li></ul><h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><p>TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><ul><li><p>粘包出现原因<br>  简单得说，在流传输中出现，UDP 不会出现粘包，因为它有消息边界粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。</p></li><li><p>为了避免粘包现象，可采取以下几种措施：</p><ol><li>对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP 提供了强制数据立即传送的操作指令 push，TCP 软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</li><li>对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</li><li>由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。分包多发。</li></ol></li><li><p>以上提到的三种措施，都有其不足之处。</p><ol><li>第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</li><li>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</li><li>第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
